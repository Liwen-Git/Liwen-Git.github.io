<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[composer autoload]]></title>
    <url>%2F2019%2F09%2F19%2Fcomposer-autoload%2F</url>
    <content type="text"><![CDATA[对于类库的自动加载，Composer 生成了一个 vendor/autoload.php 文件。引入这个文件，就能得到一个免费的自动加载支持。 本文主要是介绍如何利用 Composer 自带的自动加载机制，加载本地自定义的包（即不是来自于 packagist）。 使用在 composer.json 文件中的 autoload 字段中添加自己的 autoloader。 介绍PSR-4自动加载方式12345678&#123; &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;First\\&quot;: &quot;src/&quot;, &quot;Temp\\&quot;: &quot;lib/&quot; &#125; &#125;&#125; 上面的代码采用 PSR-4 规范，该规范包含了 PHP 最新的自动加载标准，它要求必须使用 namespace （命名空间）的方式。 First\ 表示命名空间，必须以 \ 结尾，避免相似的命名空间导致冲突，若包含子命名空间，可以这样表示：First\Second\。 src/ 表示命名空间所在目录为与 Composer 的 vendor 目录同级的 src 目录，如下所示： 123456789First/ |---examples/ |---get.php |---src/ |---Curl.php |---vendor/ |---composer/ |---autoload.php |---composer.json 如果需要在多个目录下搜索相同的命名前缀，可以用一个数组提供： 1234567&#123; &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;First\\&quot;: [&quot;src/&quot;, &quot;lib/&quot;] &#125; &#125;&#125; 修改完 composer.json 的 autoload 字段后需要更新一下 Composer 的自动加载类： 1composer dump-autoload 对应 Curl.php 的命名空间如下表示： 1234567&lt;?phpnamespace First;class Curl&#123;&#125; 引用 Curl.php 的方式如下： 12345678&lt;?phprequire &apos;../vendor/autoload.php&apos;;use First\Curl;$curl = new Curl();. . .. . .]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer镜像]]></title>
    <url>%2F2019%2F09%2F19%2Fcomposer-images%2F</url>
    <content type="text"><![CDATA[启用镜像服务的方式有两种：系统全局配置 ：即将配置信息添加到composer的全局配置文件config.json中。单个项目配置 ：将配置信息添加到某个项目的composer.json文件中 修改composer 的全局配置文件打开命令行（windows用户）或控制台（Linux、Mac用户）并执行如下命令： 1234--- phpcomposer ---composer config -g repo.packagist composer https://packagist.phpcomposer.com--- aliyun 推荐 ---composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 修改当前项目的composer.json配置文件：进入项目根目录（也就是composer.json文件所在目录），执行如下命令： 1composer config repo.packagist composer https://packagist.phpcomposer.com 上述命令将会在当前项目中的composer.json文件的末尾自动添加镜像的配置信息（你自己也可以手动添加）： 123456&quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot; : &quot;https://packagist.phpcomposer.com&quot; &#125;&#125; 查看composer镜像地址 1composer config -gl 取消配置 1composer config -g --unset repos.packagist]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer简介]]></title>
    <url>%2F2019%2F09%2F19%2Fcomposer%2F</url>
    <content type="text"><![CDATA[PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。 简单解释 composer install - 如有 composer.lock 文件，直接安装，否则从 composer.json 安装最新扩展包和依赖； composer update - 从 composer.json 安装最新扩展包和依赖； composer update vendor/package - 从 composer.json 或者对应包的配置，并更新到最新； composer require new/package - 添加安装 new/package , 可以指定版本，如： composer require new/package ~2.5。 介绍几个日常生产流程 新项目流程 运行 composer install ，安装扩展包并生成 composer.lock ； 提交 composer.lock 到代码版本控制器中，如：git; 项目协作者安装现有项目 克隆项目后，根目录下直接运行 composer install 从 composer.lock 中安装 指定版本 的扩展包以及其依赖； 此流程适用于生产环境代码的部署。 为项目添加新扩展包 使用 composer require vendor/package 添加扩展包； 提交更新后的 composer.json 和 composer.lock 到代码版本控制器中，如：git; 关于 composer.lock 文件 composer.lock 文件里保存着对每一个代码依赖的版本记录（见下图），提交到版本控制器中，并配合 composer install 使用，保证了团队所有协作者开发环境、线上生产环境中运行的代码版本的一致性。 关于扩展包的安装方法那么，准备添加一个扩展包，install, update, require 三个命令都可以用来安装扩展包，选择哪一个才是正确的呢？答案是：使用 composer require 命令 另外，在手动修改 composer.json 添加扩展包后， composer update new/package 进行指定扩展包更新的方式，也可以正确的安装，不过不建议使用这种方法，因为，一旦你忘记敲定后面的扩展包名，就会进入万劫不复的状态，别给自己留坑呀。 上面的概念不论对新手或者老手来说，都比较混淆，主要记住这个概念： 原有项目新添加扩展的，都使用 composer require new/package 这种方式来安装。 更新指定扩展到指定版本可以指定版本号： 1composer require &quot;foo/bar:1.0.0&quot; composer其他 composer 自身升级：composer self-update composer 回滚：composer self-update –rollback composer中require 和 require-dev的区别：前者用于声明项目发布版本的依赖包，后者用于声明项目开发或测试中依赖的包。 composer版本号 前置~和^符号的区别~和^的意思很接近，在x.y的情况下是一样的都是代表x.y &lt;= 版本号 &lt; (x+1).0，但是在版本号是x.y.z的情况下有区别，举个例子吧： ~1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 1.3.0 ^1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 2.0.0]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[govendor]]></title>
    <url>%2F2019%2F09%2F18%2Fgovendor%2F</url>
    <content type="text"><![CDATA[安装go get -u github.com/kardianos/govendor 初始化在项目根目录下执行以下命令进行vendor初始化：govendor init 项目根目录下即会自动生成 vendor 目录和 vendor.json 文件 常用命令 将 已被引用 且在 $GOPATH 下的所有包复制到vendor目录govendor add +external 仅从 $GOPATH 中复制指定包govendor add gopkg.in/yaml.v2 列出代码中所有被引用到的包及其状态govendor list 从远程仓库添加或更新某个包(不会在 $GOPATH 也存一份)govendor fetch golang.org/x/net/context 安装指定版本的包 123govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55govendor fetch golang.org/x/net/context@v1 # Get latest v1.*.* tag or branch.govendor fetch golang.org/x/net/context@=v1 # Get the tag or branch named &quot;v1&quot;. 删除vendor中已有 但是代码中未使用的包govendor remove +unused]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>govendor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor 维护 golang 进程]]></title>
    <url>%2F2019%2F09%2F18%2Fgo-supervisor%2F</url>
    <content type="text"><![CDATA[代码准备工作在代码目录执行go build或者go install来生成可执行文件 注意：如果使用go install生成在bin目录下的可执行文件，需要注意代码中的日志目录问题 安装supervisor官网地址：http://supervisord.org/index.html 12sudo yum install python-setuptoolssudo easy_install supervisor 或者 sudo pip install supervisor 安装成功后，生成配置文件 1sudo echo_supervisord_conf &gt; /etc/supervisord.conf 添加配置文件新建一个文件夹专门放置.conf文件 在/etc/下新建supervisor_conf_file文件夹，并在该文件加下新建gin_api.conf： 12345678910111213141516[program:gin_api]user=rootcommand=/home/go/src/gin_api/gin_api #go可执行文件路劲autostart=trueautorestart=truestartsecs=10stdout_logfile=/root/supervisor_log/gin_api.log #标准输出log，得去相应的目录下新建logstdout_logfile_maxbytes=1MBstdout_logfile_backups=10stdout_capture_maxbytes=1MBstderr_logfile=/root/supervisor_log/gin_api_err.log #错误输出log，得去相应的目录下新建logstderr_logfile_maxbytes=1MBstderr_logfile_backups=10stderr_capture_maxbytes=1MBstopsignal=INT[supervisord] 说明： 12345command：表示运行的命令，我这是填写的我demo安装包的原则路径。autostart：表示是否跟随supervisor一起启动。autorestart：如果该程序挂了，是否重新启动。stdout_logfile：终端标准输出重定向文件。stderr_logfile：终端错误输出重定向文件。 修改配置文件编辑 /etc/supervisord.conf，将文件最下面的 12;[include];files = relative/directory/*.ini 修改为： 12[include]files = /etc/supervisor_conf_file/*.conf 启动supervisord1sudo /usr/bin/supervisord -c /etc/supervisord.conf 若报如下错误： 1Error: Another program is already listening on a port that one of our HTTP servers is configured to use. Shut this program down first before starting supervisord. 解决办法： 12find / -name supervisor.sockunlink /xxx/supervisor.sock 之后再次执行启动命令。 执行命令查看gin_api服务是否启动成功： 1sudo supervisorctl status 输出： 1gin_api RUNNING pid 7648, uptime 0:09:57 ps: 123456789101112[root@accapp /home/go/src/gin_api]# supervisorctl gin_api RUNNING pid 7648, uptime 0:02:39supervisor&gt; helpdefault commands (type help &lt;topic&gt;):=====================================add exit open reload restart start tail avail fg pid remove shutdown status update clear maintail quit reread signal stop versionsupervisor&gt; exit[root@accapp /home/go/src/gin_api]# 相关命令 停止supervisor(子进程也会被停止) 1supervisorctl shutdown 把 supervisor 相关的进程都杀掉 1kill -9 $(ps -ef|grep supervisor | awk &apos;&#123;print $2&#125;&apos;) 解决unix:///tmp/supervisor.sock no such file的问题原因：tmp目录中的文件被Linux自动清除了 新建目录和修改权限 12345sudo mkdir -p /var/supervisor_tmp/runsudo mkdir -p /var/supervisor_tmp/logsudo chmod 777 /var/supervisor_tmp/runsudo chmod 777 /var/supervisor_tmp/log 修改/etc/supervisor.conf配置文件把所有的/tmp路径修改掉：/tmp/supervisor.sock 改成 /var/supervisor_tmp/run/supervisor.sock/tmp/supervisord.log 改成 /var/supervisor_tmp/log/supervisor.log/tmp/supervisord.pid 改成 /var/supervisor_tmp/run/supervisor.pid 重启杀掉supervisor进程和子进程，再启动supervisor]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[provide 和 inject]]></title>
    <url>%2F2019%2F09%2F18%2Fprovide-and-inject%2F</url>
    <content type="text"><![CDATA[官网解释：provider/inject provider/inject：简单的来说就是在父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。 需要注意的是这里不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据。 示例： first：定义一个parent component, 在这里我们在父组件中provide for这个变量。 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;childOne&gt;&lt;/childOne&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childOne from &apos;../components/test/ChildOne&apos; export default &#123; name: &quot;Parent&quot;, provide() &#123; return &#123; for: &quot;demo&quot; &#125; &#125;, components:&#123; childOne &#125; &#125; second 定义一个子组件 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &#123;&#123;demo&#125;&#125; &lt;childtwo&gt;&lt;/childtwo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childtwo from &apos;./ChildTwo&apos; export default &#123; name: &quot;childOne&quot;, inject: [&apos;for&apos;], data() &#123; return &#123; demo: this.for &#125; &#125;, components: &#123; childtwo &#125; &#125;&lt;/script&gt; third 定义另一个子组件 1234567891011121314151617&lt;template&gt; &lt;div&gt; &#123;&#123;demo&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;&quot;, inject: [&apos;for&apos;], data() &#123; return &#123; demo: this.for &#125; &#125; &#125;&lt;/script&gt; 在2个子组件中我们使用jnject注入了provide提供的变量for，并将它提供给了data属性。 运行结果是 demo demo 从上面这个例子可以看出，只要在父组件中调用了，那么在这个父组件生效的生命周期内，所有的子组件都可以调用inject来注入父组件中的值。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keep-alive的作用]]></title>
    <url>%2F2019%2F09%2F18%2Fkeep-alive%2F</url>
    <content type="text"><![CDATA[问题描述在vue项目中,难免会有列表页面或者搜索结果列表页面,点击某个结果之后,返回回来时,如果不对结果页面进行缓存,那么返回列表页面的时候会回到初始状态,但是我们想要的结果是返回时这个页面还是之前搜索的结果列表,这时候就需要用到vue的keep-alive技术了. keep-alive 简介keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 用法也很简单： 12345&lt;keep-alive&gt; &lt;component&gt; &lt;!-- 该组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; props include - 字符串或正则表达，只有匹配的组件会被缓存 exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存 1234567// 组件 aexport default &#123; name: &apos;a&apos;, data () &#123; return &#123;&#125; &#125;&#125; 12345&lt;keep-alive include=&quot;a&quot;&gt; &lt;component&gt; &lt;!-- name 为 a 的组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染 12345&lt;keep-alive exclude=&quot;a&quot;&gt; &lt;component&gt; &lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染 配合vue-router共同使用但实际项目中,常需要配合vue-router共同使用. router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存： 12345&lt;keep-alive&gt; &lt;router-view&gt; &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt; 如果只想 router-view 里面某个组件被缓存，怎么办？ 增加 router.meta 属性 123456789101112131415161718// routes 配置export default [ &#123; path: &apos;/&apos;, name: &apos;home&apos;, component: Home, meta: &#123; keepAlive: true // 需要被缓存 &#125; &#125;, &#123; path: &apos;/:id&apos;, name: &apos;edit&apos;, component: Edit, meta: &#123; keepAlive: false // 不需要被缓存 &#125; &#125;] 12345678&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;&lt;/router-view&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel篇]]></title>
    <url>%2F2019%2F08%2F08%2Flaravel-question%2F</url>
    <content type="text"><![CDATA[1. 简述laravel的生命周期 导入composer自动加载功能，加载框架类库 引入laravel应用程序实例App 启动容器 注册http处理器 注册console处理器 注册异常处理器 启动http处理器，接收request请求 以管道的设计模式，执行部分（全局）中间件 路由解析调度 实例化当前控制器 执行web中间件 执行控制器中间件 执行控制器操作 返回response 结束框架 Laravel采用了单一的入口模式，应用的所有请求入口都是public/index.php文件。 注册类文件自动加载器：laravel通过composer进行依赖管理，无需开发者手动导入各种类文件，而由自动加载器自行导入。 创建服务容器：从bootstrap/app.php文件中取得laravel应用实例$app（服务容器） 创建HTTP/Console内核：传入的请求会被发送给HTTP内核或者console内核进行处理 载入服务提供者至容器：在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的应用，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件 分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给路由进行分发。路由将分发请求给一个路由或控制器，同时运行路由指定的中间件 2. 服务提供者是什么？ 服务提供者是所有laravel应用程序引导启动的中心，laravel的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。 3. IoC容器是什么？ IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。 其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。 Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。 4. Facades 是什么？ Facades（一种设计模式，通常翻译为外观模式）提供了一个”static”（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。 5. Contract 是什么？ Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。 6. 谈谈 Laravel 和 YII 框架的区别 在 YII 框架中的路由是通过书写 Controller、Action 间接定义路由，而 Laravel 中是在 route 路由文件中直接定义路由入口 Laravel 提供 ORM 对象关系映射，使读写数据库的操作更加简单 Laravel 提供更多的 Artisan 命令和脚手架开发 Laravel 的 Composer 扩展包比 Yii 框架更多，开发更加高效 7. 谈谈 Laravel 和 TP5 框架的区别 提交数据的方式：laravel在提交表单的时候需要在表单中加入{csrc_field}来防止跨域攻击；TP不会。 路由：laravel必须先定义，再使用；TP在配置文件中开启路由。 中间件：laravel中间件，就是http请求到达之前经过的层，通过中间件我们可以验证用户是否登录等一些通用操作。 操作数据库的方式：都可以使用实例化（建立相对应的模型类）和DB::table来操作数据库。使用原生查询时不太一样，laravel使用Db::操作(‘原生sql’)，TP使用Db::query(‘原生sql’)。 Laravel升级十分简易，而TP大版本的升级要重构代码。 条件判断语句书写方式的差异： laravel框架里 if else判断语句和foreach语句 书写时必须以@if开头 以@endif结尾,如果没有则报语法错误,@foreach @endforeach同理；而TP框架则和PHP语法规则使用方式一致直接ifesle语句判断和foreach循环遍历。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx和php-fpm结合]]></title>
    <url>%2F2019%2F08%2F08%2Fnginx-and-php-fpm%2F</url>
    <content type="text"><![CDATA[Nginx不只有处理http请求的功能，还能做反向代理。 Nginx通过反向代理功能将动态请求转向后端Php-fpm。 在 Linux 上，nginx 与 php-fpm 的通信有 tcp socket 和 unix socket 两种方式。 tcp socket 的优点是可以跨服务器，当 nginx 和 php-fpm 不在同一台机器上时，只能使用这种方式。 Unix socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信，这种方式需要在 nginx配置文件中填写 php-fpm 的 socket 文件位置。 两种方式的数据传输过程如下图所示： 二者的不同： 由于 Unix socket 不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。所以其效率比 tcp socket 的方式要高，可减少不必要的 tcp 开销。不过，unix socket 高并发时不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。而 tcp 这样的面向连接的协议，可以更好的保证通信的正确性和完整性。 下面我们来配置一个全新的Nginx+Php-fpm 配置nginx.conf文件进入nginx目录下，编辑nginx.conf文件。如图，在nginx.conf最后一行，添加include文件 添加对应的server进入上面的include的路径，添加一个serverunix socket 方式 修改fastcgi_pass如下fastcgi_pass unix:/usr/run/php-fpm.sock 下面我们解释下配置项的含义 123456789101112131415161718server &#123; listen 80; #监听80端口，接收http请求 server_name www.example.com; #就是网站地址 root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径 #路由到网站根目录www.example.com时候的处理 location / &#123; index index.php; #跳转到www.example.com/index.php autoindex on; &#125; #当请求网站下php文件的时候，反向代理到php-fpm location ~ \.php$ &#123; include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块 fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口 # fasrcgi_pass /usr/run/php-fpm.sock #unix socket 连接方式 &#125;&#125; 下面我们启用php的php-fpm来处理这个请求打开php-fpm.conf文件，我们看到如下配置：unix socket 方式 修改php-fpm.conf如下listen = /usr/run/php-fpm.sock 即：php-fpm模块监听127.0.0.1:9000端口 或者 php-fpm.sock文件，等待请求到来去处理。 注意：在使用 unix socket 方式连接时，由于 socket 文件本质上是一个文件，存在权限控制的问题，所以需要注意 nginx 进程的权限与 php-fpm 的权限问题，不然会提示无权限访问。（在各自的配置文件里设置用户）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac + Hexo + GitHub + Next 搭建博客]]></title>
    <url>%2F2019%2F07%2F09%2Fmac-hexo%2F</url>
    <content type="text"><![CDATA[1. 安装node.js 和 gitmac上使用brew安装node 和 git测试安装是否成功： 12345node -vnpm -v # 同时可以配置下npm镜像：npm config set registry https://registry.npm.taobao.org# 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info expressgit --versoin 2. 安装Hexo安装时注意权限问题，加上sudo，其中-g表示全局安装 1sudo npm install -g hexo-cli npm全局安装的包的存储路径是/usr/local/lib/node_modules/ 3. 博客初始化创建博客的文件夹，并进入 12sudo mkdir blogcd blog 初始化博客 1sudo hexo init 安装依赖 12## 安装时 node-pre-gyp 报错，执行如下命令可以解决sudo npm install --unsafe-perm 执行下述命令生成本地网页文件并开启服务器，然后通过http://localhost:4000查看本地博客 12sudo hexo gsudo hexo s 或者 sudo hexo s -p 4000 4. 上传github在github中新建仓库，名称必须为 user.github.io，如：Liwen-Git.github.io 配置hexo的_config.yml文件 12cd blogsudo vim _config.yml 在文档的最后部分，将deploy配置如下 1234deploy: type: git repository: https://github.com/Liwen-Git/Liwen-Git.github.io.git branch: master 注意type、repository、branch后均有空格。通过如下命令在blog下生成静态文件并上传到服务器 1234sudo hexo g# 出错执行 sudo npm install hexo --savesudo hexo d# 出错执行 sudo npm install hexo-deployer-git --save 执行hexo d 时会提示输入GitHub账号用户名和密码，执行成功之后通过 https://liwen-git.github.io/ 访问博客 5. 更换Next主题推荐使用hexo-theme-next主题在blog目录下执行： 1sudo git clone https://github.com/theme-next/hexo-theme-next.git themes/next 修改blog目录下_config.yml里的theme名称为：next其他的，如title: 李子园、language: zh-CN、都可以自己配置 执行如下命令（每次部署文章的步骤） 12sudo hexo g //生成缓存和静态文件sudo hexo d //重新部署到服务器 当本地博客部署到服务器后，网页端无变化时可以采用下述命令 1sudo hexo clean //清楚缓存文件(db.json)和已生成的静态文件(public) 6. 配置next主题修改next主题的配置文件_config.yml主题为：Gemini（打开注释） 修改next主题配置文件，在menu处，打开tags和categories的注释 创建tag页面1sudo hexo new page &quot;tags&quot; 然后再blog/sources中会多了一个tags文件夹，修改其中的index.md文件，type修改为tags 12345---title: tagsdate: 2019-07-08 23:15:25type: &quot;tags&quot;--- 创建categories页面1sudo hexo new page &quot;categories&quot; 然后再blog/sources中会多了一个categories文件夹，修改其中的index.md文件，type修改为categories 12345---title: categoriesdate: 2019-07-08 23:15:25type: &quot;categories&quot;--- 7. 安装搜索功能 Local Search在next的_config.yml文件中修改Local Search的enable: true在根目录下执行以下命令： 12sudo npm install hexo-generator-search --savesudo npm install hexo-generator-searchdb --save 在根目录的_config.yml文件中添加 12345search: path: search.xml field: post format: html limit: 10000 8. 新建文章命令： 1sudo hexo new post 文件名可以不是文章名 给文章添加属性 12345678910---title: Mac + Hexo + GitHub + Next 搭建博客date: 2019-07-08 12:12:57categories: - mactags:- hexo- next- 表单验证--- 站点首页不显示文章全文，文章摘要设置这里我们可以通过在文章使用&lt;!-- more --&gt;标志来精确控制文章的摘要预览]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F07%2F08%2Fphp-design-patterns%2F</url>
    <content type="text"><![CDATA[策略模式策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。 策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。 策略模式的三个角色： 抽象策略角色 具体策略角色 环境角色（对抽象策略角色的引用） 实现步骤： 定义抽象角色类（定义好各个实现的共同抽象方法） 定义具体策略类（具体实现父类的共同方法） 定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法） 就在编程领域外，有许多例子是关于策略模式的。例如： 如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。 策略模式的代码实例： 1234567891011121314151617181920212223242526&lt;?php // 抽象策略类 abstract class baseAgent &#123; abstract function PrintPage(); &#125; // 用于客户端是IE时调用的类（环境角色） class ieAgent extends baseAgent &#123; function PrintPage() &#123; return &apos;IE&apos;; &#125; &#125; // 用于客户端不是IE时调用的类（环境角色） class otherAgent extends baseAgent &#123; function PrintPage() &#123; return &apos;not IE&apos;; &#125; &#125; // 具体策略角色 class Browser &#123; public function call($object) &#123; return $object-&gt;PrintPage(); &#125; &#125; $bro = new Browser(); echo $bro-&gt;call(new ieAgent()); 工厂模式工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。 使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php // 简单工厂模式（静态工厂方法模式） // Interface people 人类 interface people &#123; public function say(); &#125; // Class man 继承people的男人类 class man implements people &#123; // 具体实现people的say方法 public function say() &#123; echo &apos;我是男人&lt;br&gt;&apos;; &#125; &#125; // Class women 继承people的女人类 class women implements people &#123; // 具体实现people的say方法 public function say() &#123; echo &apos;我是女人&lt;br&gt;&apos;; &#125; &#125; // Class SimpleFactory 工厂类 class SimpleFactory &#123; // 简单工厂里的静态方法-用于创建男人对象 static function createMan() &#123; return new man(); &#125; // 简单工厂里的静态方法-用于创建女人对象 static function createWomen() &#123; return new women(); &#125; &#125; // 具体调用 $man = SimpleFactoty::createMan(); $man-&gt;say(); $woman = SimpleFactoty::createWomen(); $woman-&gt;say(); 单例模式单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。 单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。 单例模式有以下3个特点： 只能有一个实例 必须自行创建这个实例 必须给其他对象提供这一实例 那么为什么要使用PHP单例模式？ PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。 12345678910111213141516171819202122232425class Single &#123; private $name;//声明一个私有的实例变量 private function __construct()&#123; //声明私有构造方法为了防止外部代码使用new来创建对象。 &#125; static public $instance;//声明一个静态变量（保存在类中唯一的一个实例） static public function getinstance()&#123; //声明一个getinstance()静态方法，用于检测是否有实例对象 if(!self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; public function setname($n)&#123; $this-&gt;name = $n; &#125; public function getname()&#123; return $this-&gt;name; &#125;&#125;$oa = Single::getinstance();$ob = Single::getinstance();$oa-&gt;setname(&apos;hello world&apos;);$ob-&gt;setname(&apos;good morning&apos;);echo $oa-&gt;getname();//good morningecho $ob-&gt;getname();//good morning 注册模式注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。 1234567891011121314&lt;?phpclass Register &#123; protected static $objects; //将对象注册到全局的树上 function set($alias, $object) &#123; self::$objects[$alias]=$object;//将对象放到树上 &#125; static function get($name) &#123; return self::$objects[$name];//获取某个注册到树上的对象 &#125; function _unset($alias) &#123; unset(self::$objects[$alias]);//移除某个注册到树上的对象 &#125;&#125; 适配器模式将各种截然不同的函数接口封装成统一的API。 PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。 12345678接口 IDatabase&lt;?php namespace IMooc; interface IDatabase &#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close(); &#125; 12345678910111213141516171819MySQL&lt;?php namespace IMooc\Database; use IMooc\IDatabase; class MySql implements IDatabase &#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysql_connect($host, $user, $passwd); mysql_select_db($dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; $res = mysql_query($sql, $this-&gt;conn); return $res; &#125; function close() &#123; mysql_close($this-&gt;conn); &#125; &#125; 1234567891011121314151617MySQLi&lt;?php namespace IMooc\Database; use IMooc\IDatabase; class MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname)&#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql)&#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close()&#123; mysqli_close($this-&gt;conn); &#125; &#125; 观察者模式 观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。 场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 观察者模式实现了低耦合，非侵入式的通知与更新机制。 定义一个事件触发抽象类： 12345678910111213EventGenerator.php&lt;?php abstract class EventGenerator&#123; private $observers = array(); function addObserver(Observer $observer)&#123; $this-&gt;observers[]=$observer; &#125; function notify()&#123; foreach ($this-&gt;observers as $observer)&#123; $observer-&gt;update(); &#125; &#125; &#125; 定义一个观察者接口 123456Observer.php&lt;?php //一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件 interface Observer &#123; function update(); // 这里就是在事件发生后要执行的逻辑 &#125; 实现 1234567891011121314151617181920212223class Event extends EventGenerator&#123; function triger()&#123; echo &quot;Event&lt;br&gt;&quot;; &#125;&#125;class Observer1 implements Observer&#123; function update()&#123; echo &quot;逻辑1 &lt;br/&gt;&quot;; &#125;&#125;class Observer2 implements Observer&#123; function update()&#123; echo &quot;逻辑2 &lt;br/&gt;&quot;; &#125;&#125;$event = new Event();$event-&gt;addObserver(new Observer1());$event-&gt;addObserver(new Observer2());$event-&gt;triger();$event-&gt;notify();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt格式 “占位符”]]></title>
    <url>%2F2019%2F07%2F08%2Fgo-fmt%2F</url>
    <content type="text"><![CDATA[golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。 123456# 定义示例类型和变量type Human struct &#123; Name string&#125;var people = Human&#123;Name: &quot;zhangsan&quot;&#125; 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式 Printf(“%v”, people) {zhangsan} %+v 打印结构体时，会添加字段名 Printf(“%+v”, people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(“#v”, people) main.Human{Name:”zhangsan”} %T 相应值的类型的Go语法表示 Printf(“%T”, people) main.Human %% 字面上的百分号，并非值的占位符 Printf(“%%”) % 布尔占位符 占位符 说明 举例 输出 %t true 或 false Printf(“%t”, true) true 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(“%b”, 5) 101 %c 相应Unicode码点所表示的字符 Printf(“%c”, 0x4E2D) 中 %d 十进制表示 Printf(“%d”, 0x12) 18 %o 八进制表示 Printf(“%d”, 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(“%q”, 0x4E2D) ‘中’ %x 十六进制表示，字母形式为小写 a-f Printf(“%x”, 13) d %X 十六进制表示，字母形式为大写 A-F Printf(“%x”, 13) D %U Unicode格式：U+1234，等同于 “U+%04X” Printf(“%U”, 0x4E2D) U+4E2D 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %e 科学计数法，例如 -1234.456e+78 Printf(“%e”, 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(“%e”, 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(“%f”, 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%g”, 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%G”, 10.20+2i) (10.2+2i) 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(“%s”, []byte(“Go语言”)) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(“%q”, “Go语言”) “Go语言” %x 十六进制，小写字母，每字节两个字符 Printf(“%x”, “golang”) 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(“%X”, “golang”) 676F6C616E67 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(“%p”, &amp;people) 0x4f57f0]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>占位符</tag>
      </tags>
  </entry>
</search>
