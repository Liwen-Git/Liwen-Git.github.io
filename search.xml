<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>govendor</title>
      <link href="/2019/09/18/govendor/"/>
      <url>/2019/09/18/govendor/</url>
      
        <content type="html"><![CDATA[<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><code>go get -u github.com/kardianos/govendor</code></p><a id="more"></a><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在项目根目录下执行以下命令进行vendor初始化：<br><code>govendor init</code></p><p>项目根目录下即会自动生成 vendor 目录和 vendor.json 文件</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><ul><li><p>将 已被引用 且在 $GOPATH 下的所有包复制到vendor目录<br><code>govendor add +external</code></p></li><li><p>仅从 $GOPATH 中复制指定包<br><code>govendor add gopkg.in/yaml.v2</code></p></li><li><p>列出代码中所有被引用到的包及其状态<br><code>govendor list</code></p></li><li><p>从远程仓库添加或更新某个包(不会在 $GOPATH 也存一份)<br><code>govendor fetch golang.org/x/net/context</code></p></li><li><p>安装指定版本的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</span><br><span class="line">govendor fetch golang.org/x/net/context@v1   # Get latest v1.*.* tag or branch.</span><br><span class="line">govendor fetch golang.org/x/net/context@=v1  # Get the tag or branch named &quot;v1&quot;.</span><br></pre></td></tr></table></figure></li><li><p>删除vendor中已有 但是代码中未使用的包<br><code>govendor remove +unused</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> govendor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>supervisor 维护 golang 进程</title>
      <link href="/2019/09/18/go-supervisor/"/>
      <url>/2019/09/18/go-supervisor/</url>
      
        <content type="html"><![CDATA[<h4 id="代码准备工作"><a href="#代码准备工作" class="headerlink" title="代码准备工作"></a>代码准备工作</h4><p>在代码目录执行<code>go build</code>或者<code>go install</code>来生成可执行文件</p><blockquote><p>注意：如果使用<code>go install</code>生成在bin目录下的可执行文件，需要注意代码中的日志目录问题</p></blockquote><a id="more"></a><h4 id="安装supervisor"><a href="#安装supervisor" class="headerlink" title="安装supervisor"></a>安装supervisor</h4><p>官网地址：<a href="http://supervisord.org/index.html" target="_blank" rel="noopener">http://supervisord.org/index.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python-setuptools</span><br><span class="line">sudo easy_install supervisor 或者 sudo pip install supervisor</span><br></pre></td></tr></table></figure><p>安装成功后，生成配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure><h4 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h4><p>新建一个文件夹专门放置.conf文件</p><p>在<code>/etc/</code>下新建<code>supervisor_conf_file</code>文件夹，并在该文件加下新建<code>gin_api.conf</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[program:gin_api]</span><br><span class="line">user=root</span><br><span class="line">command=/home/go/src/gin_api/gin_api #go可执行文件路劲</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=10</span><br><span class="line">stdout_logfile=/root/supervisor_log/gin_api.log #标准输出log，得去相应的目录下新建log</span><br><span class="line">stdout_logfile_maxbytes=1MB</span><br><span class="line">stdout_logfile_backups=10</span><br><span class="line">stdout_capture_maxbytes=1MB</span><br><span class="line">stderr_logfile=/root/supervisor_log/gin_api_err.log #错误输出log，得去相应的目录下新建log</span><br><span class="line">stderr_logfile_maxbytes=1MB</span><br><span class="line">stderr_logfile_backups=10</span><br><span class="line">stderr_capture_maxbytes=1MB</span><br><span class="line">stopsignal=INT</span><br><span class="line">[supervisord]</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">command：表示运行的命令，我这是填写的我demo安装包的原则路径。</span><br><span class="line">autostart：表示是否跟随supervisor一起启动。</span><br><span class="line">autorestart：如果该程序挂了，是否重新启动。</span><br><span class="line">stdout_logfile：终端标准输出重定向文件。</span><br><span class="line">stderr_logfile：终端错误输出重定向文件。</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>编辑 <code>/etc/supervisord.conf</code>，将文件最下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;[include]</span><br><span class="line">;files = relative/directory/*.ini</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files = /etc/supervisor_conf_file/*.conf</span><br></pre></td></tr></table></figure><h4 id="启动supervisord"><a href="#启动supervisord" class="headerlink" title="启动supervisord"></a>启动supervisord</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>若报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Another program is already listening on a port that one of our HTTP servers is configured to use.  Shut this program down first before starting supervisord.</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name supervisor.sock</span><br><span class="line">unlink /xxx/supervisor.sock</span><br></pre></td></tr></table></figure><p>之后再次执行启动命令。</p><p>执行命令查看gin_api服务是否启动成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo supervisorctl status</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gin_api                          RUNNING   pid 7648, uptime 0:09:57</span><br></pre></td></tr></table></figure><p>ps:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@accapp /home/go/src/gin_api]# supervisorctl </span><br><span class="line">gin_api                          RUNNING   pid 7648, uptime 0:02:39</span><br><span class="line">supervisor&gt; help</span><br><span class="line"></span><br><span class="line">default commands (type help &lt;topic&gt;):</span><br><span class="line">=====================================</span><br><span class="line">add    exit      open  reload  restart   start   tail   </span><br><span class="line">avail  fg        pid   remove  shutdown  status  update </span><br><span class="line">clear  maintail  quit  reread  signal    stop    version</span><br><span class="line"></span><br><span class="line">supervisor&gt; exit</span><br><span class="line">[root@accapp /home/go/src/gin_api]#</span><br></pre></td></tr></table></figure><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul><li><p>停止supervisor(子进程也会被停止)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl shutdown</span><br></pre></td></tr></table></figure></li><li><p>把 supervisor 相关的进程都杀掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(ps -ef|grep supervisor | awk &apos;&#123;print $2&#125;&apos;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="解决unix-tmp-supervisor-sock-no-such-file的问题"><a href="#解决unix-tmp-supervisor-sock-no-such-file的问题" class="headerlink" title="解决unix:///tmp/supervisor.sock no such file的问题"></a>解决unix:///tmp/supervisor.sock no such file的问题</h4><p>原因：tmp目录中的文件被Linux自动清除了</p><ol><li><p>新建目录和修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p  /var/supervisor_tmp/run</span><br><span class="line">sudo mkdir -p  /var/supervisor_tmp/log</span><br><span class="line"></span><br><span class="line">sudo chmod 777 /var/supervisor_tmp/run</span><br><span class="line">sudo chmod 777 /var/supervisor_tmp/log</span><br></pre></td></tr></table></figure></li><li><p>修改/etc/supervisor.conf配置文件<br>把所有的<code>/tmp</code>路径修改掉：<br><code>/tmp/supervisor.sock</code> 改成 <code>/var/supervisor_tmp/run/supervisor.sock</code><br><code>/tmp/supervisord.log</code> 改成 <code>/var/supervisor_tmp/log/supervisor.log</code><br><code>/tmp/supervisord.pid</code> 改成 <code>/var/supervisor_tmp/run/supervisor.pid</code></p></li><li><p>重启<br>杀掉supervisor进程和子进程，再启动supervisor</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> supervisor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>provide 和 inject</title>
      <link href="/2019/09/18/provide-and-inject/"/>
      <url>/2019/09/18/provide-and-inject/</url>
      
        <content type="html"><![CDATA[<p><strong>官网解释</strong>：<a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">provider/inject</a></p><p><strong>provider/inject</strong>：简单的来说就是在父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。</p><blockquote><p>需要注意的是这里不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据。</p></blockquote><a id="more"></a><p>示例：</p><ul><li><p>first：定义一个parent component, 在这里我们在父组件中provide for这个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;childOne&gt;&lt;/childOne&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import childOne from &apos;../components/test/ChildOne&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &quot;Parent&quot;,</span><br><span class="line">    provide() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            for: &quot;demo&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        childOne</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>second 定义一个子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;demo&#125;&#125;</span><br><span class="line">    &lt;childtwo&gt;&lt;/childtwo&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import childtwo from &apos;./ChildTwo&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;childOne&quot;,</span><br><span class="line">    inject: [&apos;for&apos;],</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        demo: this.for</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      childtwo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>third 定义另一个子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;demo&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    inject: [&apos;for&apos;],</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        demo: this.for</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>在2个子组件中我们使用jnject注入了provide提供的变量for，并将它提供给了data属性。</p><p>运行结果是 demo demo</p><blockquote><p>从上面这个例子可以看出，只要在父组件中调用了，那么在这个父组件生效的生命周期内，所有的子组件都可以调用inject来注入父组件中的值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive的作用</title>
      <link href="/2019/09/18/keep-alive/"/>
      <url>/2019/09/18/keep-alive/</url>
      
        <content type="html"><![CDATA[<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在vue项目中,难免会有列表页面或者搜索结果列表页面,点击某个结果之后,返回回来时,如果不对结果页面进行缓存,那么返回列表页面的时候会回到初始状态,但是我们想要的结果是返回时这个页面还是之前搜索的结果列表,这时候就需要用到vue的keep-alive技术了.</p><a id="more"></a><h5 id="keep-alive-简介"><a href="#keep-alive-简介" class="headerlink" title="keep-alive 简介"></a>keep-alive 简介</h5><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p><p>用法也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- 该组件将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p><strong>props</strong></p><ul><li>include - 字符串或正则表达，只有匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 组件 a</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;a&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;a&quot;&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- name 为 a 的组件将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude=&quot;a&quot;&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><h5 id="配合vue-router共同使用"><a href="#配合vue-router共同使用" class="headerlink" title="配合vue-router共同使用"></a>配合vue-router共同使用</h5><p>但实际项目中,常需要配合vue-router共同使用.</p><p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view&gt;</span><br><span class="line">        &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt;</span><br><span class="line">    &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>如果只想 router-view 里面某个组件被缓存，怎么办？</p><p>增加 <strong>router.meta</strong> 属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// routes 配置</span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    name: &apos;home&apos;,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: true // 需要被缓存</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &apos;/:id&apos;,</span><br><span class="line">    name: &apos;edit&apos;,</span><br><span class="line">    component: Edit,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: false // 不需要被缓存</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;</span><br><span class="line">        &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;</span><br><span class="line">    &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;</span><br><span class="line">    &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel篇</title>
      <link href="/2019/08/08/laravel-question/"/>
      <url>/2019/08/08/laravel-question/</url>
      
        <content type="html"><![CDATA[<h6 id="1-简述laravel的生命周期"><a href="#1-简述laravel的生命周期" class="headerlink" title="1. 简述laravel的生命周期"></a>1. 简述laravel的生命周期</h6><p><img src="http://liwengo.top/blog/2D6A568E-F7DD-4DAF-B460-A7C0BD15DA60.png" alt="2623c78f9e824fb89db4552be669404c"></p><a id="more"></a><ol><li>导入composer自动加载功能，加载框架类库</li><li>引入laravel应用程序实例App</li></ol><ul><li>启动容器</li><li>注册http处理器</li><li>注册console处理器</li><li>注册异常处理器</li></ul><ol start="3"><li>启动http处理器，接收request请求</li><li>以管道的设计模式，执行部分（全局）中间件</li><li>路由解析调度</li><li>实例化当前控制器</li><li>执行web中间件</li><li>执行控制器中间件</li><li>执行控制器操作</li><li>返回response</li><li>结束框架</li></ol><hr><blockquote><p>Laravel采用了单一的入口模式，应用的所有请求入口都是public/index.php文件。</p><ol><li>注册类文件自动加载器：laravel通过composer进行依赖管理，无需开发者手动导入各种类文件，而由自动加载器自行导入。</li><li>创建服务容器：从bootstrap/app.php文件中取得laravel应用实例$app（服务容器）</li><li>创建HTTP/Console内核：传入的请求会被发送给HTTP内核或者console内核进行处理</li><li>载入服务提供者至容器：在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的应用，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件</li><li>分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给路由进行分发。路由将分发请求给一个路由或控制器，同时运行路由指定的中间件</li></ol></blockquote><hr><h6 id="2-服务提供者是什么？"><a href="#2-服务提供者是什么？" class="headerlink" title="2. 服务提供者是什么？"></a>2. 服务提供者是什么？</h6><blockquote><p>服务提供者是所有laravel应用程序引导启动的中心，laravel的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。</p></blockquote><h6 id="3-IoC容器是什么？"><a href="#3-IoC容器是什么？" class="headerlink" title="3. IoC容器是什么？"></a>3. IoC容器是什么？</h6><blockquote><p>IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。</p><p>Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。</p></blockquote><h6 id="4-Facades-是什么？"><a href="#4-Facades-是什么？" class="headerlink" title="4. Facades 是什么？"></a>4. Facades 是什么？</h6><blockquote><p>Facades（一种设计模式，通常翻译为外观模式）提供了一个”static”（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。</p></blockquote><h6 id="5-Contract-是什么？"><a href="#5-Contract-是什么？" class="headerlink" title="5. Contract 是什么？"></a>5. Contract 是什么？</h6><blockquote><p>Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。</p></blockquote><h6 id="6-谈谈-Laravel-和-YII-框架的区别"><a href="#6-谈谈-Laravel-和-YII-框架的区别" class="headerlink" title="6. 谈谈 Laravel 和 YII 框架的区别"></a>6. 谈谈 Laravel 和 YII 框架的区别</h6><blockquote><ol><li>在 YII 框架中的路由是通过书写 Controller、Action 间接定义路由，而 Laravel 中是在 route 路由文件中直接定义路由入口</li><li>Laravel 提供 ORM 对象关系映射，使读写数据库的操作更加简单</li><li>Laravel 提供更多的 Artisan 命令和脚手架开发</li><li>Laravel 的 Composer 扩展包比 Yii 框架更多，开发更加高效</li></ol></blockquote><h6 id="7-谈谈-Laravel-和-TP5-框架的区别"><a href="#7-谈谈-Laravel-和-TP5-框架的区别" class="headerlink" title="7. 谈谈 Laravel 和 TP5 框架的区别"></a>7. 谈谈 Laravel 和 TP5 框架的区别</h6><blockquote><ol><li>提交数据的方式：laravel在提交表单的时候需要在表单中加入{csrc_field}来防止跨域攻击；TP不会。</li><li>路由：laravel必须先定义，再使用；TP在配置文件中开启路由。</li><li>中间件：laravel中间件，就是http请求到达之前经过的层，通过中间件我们可以验证用户是否登录等一些通用操作。</li><li>操作数据库的方式：都可以使用实例化（建立相对应的模型类）和DB::table来操作数据库。使用原生查询时不太一样，laravel使用Db::操作(‘原生sql’)，TP使用Db::query(‘原生sql’)。</li><li>Laravel升级十分简易，而TP大版本的升级要重构代码。</li><li>条件判断语句书写方式的差异： laravel框架里 if else判断语句和foreach语句 书写时必须以@if开头  以@endif结尾,如果没有则报语法错误,@foreach @endforeach同理；而TP框架则和PHP语法规则使用方式一致直接ifesle语句判断和foreach循环遍历。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx和php-fpm结合</title>
      <link href="/2019/08/08/nginx-and-php-fpm/"/>
      <url>/2019/08/08/nginx-and-php-fpm/</url>
      
        <content type="html"><![CDATA[<pre><code>Nginx不只有处理http请求的功能，还能做反向代理。Nginx通过反向代理功能将动态请求转向后端Php-fpm。</code></pre><blockquote><p>在 Linux 上，nginx 与 php-fpm 的通信有 tcp socket 和 unix socket 两种方式。</p></blockquote><ul><li>tcp socket 的优点是可以跨服务器，当 nginx 和 php-fpm 不在同一台机器上时，只能使用这种方式。</li><li>Unix socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信，这种方式需要在 nginx配置文件中填写 php-fpm 的 socket 文件位置。</li></ul><a id="more"></a><p>两种方式的数据传输过程如下图所示：<br><img src="http://liwengo.top/blog/157A0895-F0C5-4DF6-AC53-3DB3A8C02F89.png" alt="40ef8c1f5cb07d102bc9b37368a786e5"></p><p>二者的不同：</p><blockquote><p>由于 Unix socket 不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。所以其效率比 tcp socket 的方式要高，可减少不必要的 tcp 开销。不过，unix socket 高并发时不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。而 tcp 这样的面向连接的协议，可以更好的保证通信的正确性和完整性。</p></blockquote><p><strong>下面我们来配置一个全新的Nginx+Php-fpm</strong></p><ol><li><p>配置nginx.conf文件<br>进入nginx目录下，编辑nginx.conf文件。<br>如图，在nginx.conf最后一行，添加include文件<br><img src="http://liwengo.top/blog/B7B7E402-287A-48B6-BCBA-AABA649299EC.png" alt="d1e54053831e3288467bad22e8ebaeb5"></p></li><li><p>添加对应的server<br>进入上面的include的路径，添加一个server<br><img src="http://liwengo.top/blog/021D27C6-11AC-4B88-B4BA-1F2813999A00.png" alt="dc5882516f01acc2bca56dea6c685fa7"><br>unix socket 方式 修改fastcgi_pass如下<br><code>fastcgi_pass unix:/usr/run/php-fpm.sock</code></p></li></ol><p><strong>下面我们解释下配置项的含义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80; #监听80端口，接收http请求</span><br><span class="line">    server_name  www.example.com; #就是网站地址</span><br><span class="line">    root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径</span><br><span class="line">    #路由到网站根目录www.example.com时候的处理</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.php; #跳转到www.example.com/index.php</span><br><span class="line">        autoindex on;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    #当请求网站下php文件的时候，反向代理到php-fpm</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块</span><br><span class="line">        fastcgi_intercept_errors on;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口</span><br><span class="line">        # fasrcgi_pass /usr/run/php-fpm.sock   #unix socket 连接方式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面我们启用php的php-fpm来处理这个请求</strong><br>打开php-fpm.conf文件，我们看到如下配置：<br><img src="http://liwengo.top/blog/D15767C9-0B46-4DF9-97FD-F4D60A5F96B7.png" alt="ab60dcdb0f77e985dc233cd54e0b2fb8"><br>unix socket 方式 修改php-fpm.conf如下<br><code>listen = /usr/run/php-fpm.sock</code></p><blockquote><p>即：php-fpm模块监听127.0.0.1:9000端口 或者 php-fpm.sock文件，等待请求到来去处理。</p></blockquote><blockquote><p>注意：在使用 unix socket 方式连接时，由于 socket 文件本质上是一个文件，存在权限控制的问题，所以需要注意 nginx 进程的权限与 php-fpm 的权限问题，不然会提示无权限访问。（在各自的配置文件里设置用户）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> php-fpm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac + Hexo + GitHub + Next 搭建博客</title>
      <link href="/2019/07/09/mac-hexo/"/>
      <url>/2019/07/09/mac-hexo/</url>
      
        <content type="html"><![CDATA[<h5 id="1-安装node-js-和-git"><a href="#1-安装node-js-和-git" class="headerlink" title="1. 安装node.js 和 git"></a>1. 安装node.js 和 git</h5><p>mac上使用brew安装node 和 git<br>测试安装是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v   </span><br><span class="line"># 同时可以配置下npm镜像：npm config set registry https://registry.npm.taobao.org</span><br><span class="line"># 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info express</span><br><span class="line">git --versoin</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h5><p>安装时注意权限问题，加上sudo，其中-g表示全局安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>npm全局安装的包的存储路径是<code>/usr/local/lib/node_modules/</code></p><h5 id="3-博客初始化"><a href="#3-博客初始化" class="headerlink" title="3. 博客初始化"></a>3. 博客初始化</h5><p>创建博客的文件夹，并进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure><p>初始化博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 安装时 node-pre-gyp 报错，执行如下命令可以解决</span><br><span class="line">sudo npm install --unsafe-perm</span><br></pre></td></tr></table></figure><p>执行下述命令生成本地网页文件并开启服务器，然后通过<a href="http://localhost:4000查看本地博客" target="_blank" rel="noopener">http://localhost:4000查看本地博客</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g</span><br><span class="line">sudo hexo s  或者 sudo hexo s -p 4000</span><br></pre></td></tr></table></figure><h5 id="4-上传github"><a href="#4-上传github" class="headerlink" title="4. 上传github"></a>4. 上传github</h5><p>在github中新建仓库，名称必须为 <code>user.github.io</code>，如：<code>Liwen-Git.github.io</code></p><p>配置hexo的_config.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  blog</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure><p>在文档的最后部分，将deploy配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/Liwen-Git/Liwen-Git.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>注意type、repository、branch后均有空格。通过如下命令在blog下生成静态文件并上传到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g</span><br><span class="line"># 出错执行 sudo npm install hexo --save</span><br><span class="line">sudo hexo d</span><br><span class="line"># 出错执行 sudo npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>执行<code>hexo d</code> 时会提示输入GitHub账号用户名和密码，执行成功之后通过 <a href="https://liwen-git.github.io/" target="_blank" rel="noopener">https://liwen-git.github.io/</a> 访问博客</p><h5 id="5-更换Next主题"><a href="#5-更换Next主题" class="headerlink" title="5. 更换Next主题"></a>5. 更换Next主题</h5><p>推荐使用hexo-theme-next主题<br>在blog目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><p>修改blog目录下_config.yml里的theme名称为：next<br>其他的，如title: 李子园、language: zh-CN、都可以自己配置</p><p>执行如下命令（每次部署文章的步骤）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g  //生成缓存和静态文件</span><br><span class="line">sudo hexo d  //重新部署到服务器</span><br></pre></td></tr></table></figure><p>当本地博客部署到服务器后，网页端无变化时可以采用下述命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo clean  //清楚缓存文件(db.json)和已生成的静态文件(public)</span><br></pre></td></tr></table></figure><h5 id="6-配置next主题"><a href="#6-配置next主题" class="headerlink" title="6. 配置next主题"></a>6. 配置next主题</h5><p>修改next主题的配置文件_config.yml主题为：Gemini（打开注释）</p><p>修改next主题配置文件，在menu处，打开tags和categories的注释</p><ul><li>创建tag页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure></li></ul><p>然后再blog/sources中会多了一个tags文件夹，修改其中的index.md文件，type修改为tags</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-07-08 23:15:25</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>创建categories页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure></li></ul><p>然后再blog/sources中会多了一个categories文件夹，修改其中的index.md文件，type修改为categories</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-07-08 23:15:25</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h5 id="7-安装搜索功能-Local-Search"><a href="#7-安装搜索功能-Local-Search" class="headerlink" title="7. 安装搜索功能 Local Search"></a>7. 安装搜索功能 Local Search</h5><p>在next的_config.yml文件中修改Local Search的<code>enable: true</code><br>在根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-generator-search --save</span><br><span class="line">sudo npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>在根目录的_config.yml文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><h5 id="8-新建文章"><a href="#8-新建文章" class="headerlink" title="8. 新建文章"></a>8. 新建文章</h5><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo new post 文件名可以不是文章名</span><br></pre></td></tr></table></figure><p>给文章添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Mac + Hexo + GitHub + Next 搭建博客</span><br><span class="line">date: 2019-07-08 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- mac</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">- next</span><br><span class="line">- 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>站点首页不显示文章全文，文章摘要设置<br>这里我们可以通过在文章使用<code>&lt;!-- more --&gt;</code>标志来精确控制文章的摘要预览</p>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/07/08/php-design-patterns/"/>
      <url>/2019/07/08/php-design-patterns/</url>
      
        <content type="html"><![CDATA[<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。</p><p>策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。</p><p>策略模式的三个角色：</p><ol><li>抽象策略角色</li><li>具体策略角色</li><li>环境角色（对抽象策略角色的引用）</li></ol><p>实现步骤：</p><ol><li>定义抽象角色类（定义好各个实现的共同抽象方法）</li><li>定义具体策略类（具体实现父类的共同方法）</li><li>定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法）</li></ol><a id="more"></a><p>就在编程领域外，有许多例子是关于策略模式的。例如：</p><p>如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。</p><p>策略模式的代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 抽象策略类</span><br><span class="line">abstract class baseAgent &#123;</span><br><span class="line">            abstract function PrintPage();</span><br><span class="line">&#125;</span><br><span class="line">// 用于客户端是IE时调用的类（环境角色）</span><br><span class="line">class ieAgent extends baseAgent &#123;</span><br><span class="line">            function PrintPage() &#123;</span><br><span class="line">                return &apos;IE&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 用于客户端不是IE时调用的类（环境角色）</span><br><span class="line">class otherAgent extends baseAgent &#123;</span><br><span class="line">            function PrintPage() &#123;</span><br><span class="line">                return &apos;not IE&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 具体策略角色</span><br><span class="line">class Browser &#123;</span><br><span class="line">            public function call($object) &#123;</span><br><span class="line">                return $object-&gt;PrintPage();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$bro = new Browser();</span><br><span class="line">echo $bro-&gt;call(new ieAgent());</span><br></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。</p><p>使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    // 简单工厂模式（静态工厂方法模式）</span><br><span class="line">    // Interface people 人类</span><br><span class="line">    interface people &#123;</span><br><span class="line">        public function say();</span><br><span class="line">    &#125;</span><br><span class="line">    // Class man 继承people的男人类</span><br><span class="line">    class man implements people</span><br><span class="line">    &#123;</span><br><span class="line">        // 具体实现people的say方法</span><br><span class="line">        public function say()</span><br><span class="line">        &#123;</span><br><span class="line">            echo &apos;我是男人&lt;br&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Class women 继承people的女人类</span><br><span class="line">    class women implements people</span><br><span class="line">    &#123;</span><br><span class="line">        // 具体实现people的say方法</span><br><span class="line">        public function say()</span><br><span class="line">        &#123;</span><br><span class="line">            echo &apos;我是女人&lt;br&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Class SimpleFactory 工厂类</span><br><span class="line">    class SimpleFactory &#123;</span><br><span class="line">        // 简单工厂里的静态方法-用于创建男人对象</span><br><span class="line">        static function createMan()</span><br><span class="line">        &#123;</span><br><span class="line">            return new man();</span><br><span class="line">        &#125;</span><br><span class="line">        // 简单工厂里的静态方法-用于创建女人对象</span><br><span class="line">        static function createWomen()</span><br><span class="line">        &#123;</span><br><span class="line">            return new women();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 具体调用</span><br><span class="line">    $man = SimpleFactoty::createMan();</span><br><span class="line">    $man-&gt;say();</span><br><span class="line">    $woman = SimpleFactoty::createWomen();</span><br><span class="line">    $woman-&gt;say();</span><br></pre></td></tr></table></figure><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。</p><p>单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。</p><p>单例模式有以下3个特点：</p><ol><li>只能有一个实例</li><li>必须自行创建这个实例</li><li>必须给其他对象提供这一实例</li></ol><p>那么为什么要使用PHP单例模式？</p><p>PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Single &#123;</span><br><span class="line">    private $name;//声明一个私有的实例变量</span><br><span class="line">    private function __construct()&#123;</span><br><span class="line">    //声明私有构造方法为了防止外部代码使用new来创建对象。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static public $instance;//声明一个静态变量（保存在类中唯一的一个实例）</span><br><span class="line">    static public function getinstance()&#123;</span><br><span class="line">    //声明一个getinstance()静态方法，用于检测是否有实例对象</span><br><span class="line">        if(!self::$instance) &#123;</span><br><span class="line">            self::$instance = new self();</span><br><span class="line">        &#125; </span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function setname($n)&#123; $this-&gt;name = $n; &#125;</span><br><span class="line">    public function getname()&#123; return $this-&gt;name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$oa = Single::getinstance();</span><br><span class="line">$ob = Single::getinstance();</span><br><span class="line">$oa-&gt;setname(&apos;hello world&apos;);</span><br><span class="line">$ob-&gt;setname(&apos;good morning&apos;);</span><br><span class="line">echo $oa-&gt;getname();//good morning</span><br><span class="line">echo $ob-&gt;getname();//good morning</span><br></pre></td></tr></table></figure><h4 id="注册模式"><a href="#注册模式" class="headerlink" title="注册模式"></a>注册模式</h4><p>注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Register &#123;</span><br><span class="line">    protected static $objects;</span><br><span class="line">    //将对象注册到全局的树上</span><br><span class="line">    function set($alias, $object) &#123;</span><br><span class="line">        self::$objects[$alias]=$object;//将对象放到树上</span><br><span class="line">    &#125;</span><br><span class="line">    static function get($name) &#123;</span><br><span class="line">        return self::$objects[$name];//获取某个注册到树上的对象</span><br><span class="line">    &#125;</span><br><span class="line">    function _unset($alias) &#123;</span><br><span class="line">        unset(self::$objects[$alias]);//移除某个注册到树上的对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>将各种截然不同的函数接口封装成统一的API。</p><p>PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 </p><p>首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">接口 IDatabase</span><br><span class="line">&lt;?php</span><br><span class="line">    namespace IMooc;</span><br><span class="line">    interface IDatabase &#123;</span><br><span class="line">        function connect($host, $user, $passwd, $dbname);</span><br><span class="line">        function query($sql);</span><br><span class="line">        function close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MySQL</span><br><span class="line">&lt;?php</span><br><span class="line">    namespace IMooc\Database;</span><br><span class="line">    use IMooc\IDatabase;</span><br><span class="line">    class MySql implements IDatabase &#123;</span><br><span class="line">        protected $conn;</span><br><span class="line">        function connect($host, $user, $passwd, $dbname) &#123;</span><br><span class="line">            $conn = mysql_connect($host, $user, $passwd);</span><br><span class="line">            mysql_select_db($dbname);</span><br><span class="line">            $this-&gt;conn = $conn;</span><br><span class="line">        &#125;</span><br><span class="line">        function query($sql) &#123;</span><br><span class="line">            $res = mysql_query($sql, $this-&gt;conn);</span><br><span class="line">            return $res;</span><br><span class="line">        &#125;</span><br><span class="line">        function close() &#123;</span><br><span class="line">            mysql_close($this-&gt;conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MySQLi</span><br><span class="line">&lt;?php</span><br><span class="line">    namespace IMooc\Database;</span><br><span class="line">    use IMooc\IDatabase;</span><br><span class="line">    class MySQLi implements IDatabase&#123;</span><br><span class="line">        protected $conn;</span><br><span class="line">        function connect($host, $user, $passwd, $dbname)&#123;</span><br><span class="line">            $conn = mysqli_connect($host, $user, $passwd, $dbname);</span><br><span class="line">            $this-&gt;conn = $conn;</span><br><span class="line">        &#125;</span><br><span class="line">        function query($sql)&#123;</span><br><span class="line">            return mysqli_query($this-&gt;conn, $sql);</span><br><span class="line">        &#125;</span><br><span class="line">        function close()&#123;</span><br><span class="line">            mysqli_close($this-&gt;conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ol><li>观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。  </li><li>场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 </li><li>观察者模式实现了低耦合，非侵入式的通知与更新机制。 </li></ol><p>定义一个事件触发抽象类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EventGenerator.php</span><br><span class="line">&lt;?php</span><br><span class="line">    abstract class EventGenerator&#123;</span><br><span class="line">        private $observers = array();</span><br><span class="line">        function addObserver(Observer $observer)&#123;</span><br><span class="line">            $this-&gt;observers[]=$observer;</span><br><span class="line">        &#125;</span><br><span class="line">        function notify()&#123;</span><br><span class="line">            foreach ($this-&gt;observers as $observer)&#123;</span><br><span class="line">                $observer-&gt;update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>定义一个观察者接口 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observer.php</span><br><span class="line">&lt;?php</span><br><span class="line">//一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件</span><br><span class="line">interface Observer &#123;</span><br><span class="line">            function update(); // 这里就是在事件发生后要执行的逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Event extends EventGenerator&#123;</span><br><span class="line">    function triger()&#123;</span><br><span class="line">        echo &quot;Event&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Observer1 implements Observer&#123;</span><br><span class="line">    function update()&#123;</span><br><span class="line">        echo &quot;逻辑1 &lt;br/&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Observer2 implements Observer&#123;</span><br><span class="line">    function update()&#123;</span><br><span class="line">        echo &quot;逻辑2 &lt;br/&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$event = new Event();</span><br><span class="line">$event-&gt;addObserver(new Observer1());</span><br><span class="line">$event-&gt;addObserver(new Observer2());</span><br><span class="line">$event-&gt;triger();</span><br><span class="line">$event-&gt;notify();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fmt格式 “占位符”</title>
      <link href="/2019/07/08/go-fmt/"/>
      <url>/2019/07/08/go-fmt/</url>
      
        <content type="html"><![CDATA[<p>golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义示例类型和变量</span><br><span class="line">type Human struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people = Human&#123;Name: &quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>普通占位符</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%v</td><td>相应值的默认格式</td><td>Printf(“%v”, people)</td><td>{zhangsan}</td></tr><tr><td>%+v</td><td>打印结构体时，会添加字段名</td><td>Printf(“%+v”, people)</td><td>{Name:zhangsan}</td></tr><tr><td>%#v</td><td>相应值的Go语法表示</td><td>Printf(“#v”, people)</td><td>main.Human{Name:”zhangsan”}</td></tr><tr><td>%T</td><td>相应值的类型的Go语法表示</td><td>Printf(“%T”, people)</td><td>main.Human</td></tr><tr><td>%%</td><td>字面上的百分号，并非值的占位符</td><td>Printf(“%%”)</td><td>%</td></tr></tbody></table><a id="more"></a><ul><li>布尔占位符</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%t</td><td>true 或 false</td><td>Printf(“%t”, true)</td><td>true</td></tr></tbody></table><ul><li>整数占位符</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%b</td><td>二进制表示</td><td>Printf(“%b”, 5)</td><td>101</td></tr><tr><td>%c</td><td>相应Unicode码点所表示的字符</td><td>Printf(“%c”, 0x4E2D)</td><td>中</td></tr><tr><td>%d</td><td>十进制表示</td><td>Printf(“%d”, 0x12)</td><td>18</td></tr><tr><td>%o</td><td>八进制表示</td><td>Printf(“%d”, 10)</td><td>12</td></tr><tr><td>%q</td><td>单引号围绕的字符字面值，由Go语法安全地转义</td><td>Printf(“%q”, 0x4E2D)</td><td>‘中’</td></tr><tr><td>%x</td><td>十六进制表示，字母形式为小写 a-f</td><td>Printf(“%x”, 13)</td><td>d</td></tr><tr><td>%X</td><td>十六进制表示，字母形式为大写 A-F</td><td>Printf(“%x”, 13)</td><td>D</td></tr><tr><td>%U</td><td>Unicode格式：U+1234，等同于 “U+%04X”</td><td>Printf(“%U”, 0x4E2D)</td><td>U+4E2D</td></tr></tbody></table><ul><li>浮点数和复数的组成部分（实部和虚部）</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%e</td><td>科学计数法，例如 -1234.456e+78</td><td>Printf(“%e”, 10.2)</td><td>1.020000e+01</td></tr><tr><td>%E</td><td>科学计数法，例如 -1234.456E+78</td><td>Printf(“%e”, 10.2)</td><td>1.020000E+01</td></tr><tr><td>%f</td><td>有小数点而无指数，例如 123.456</td><td>Printf(“%f”, 10.2)</td><td>10.200000</td></tr><tr><td>%g</td><td>根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td><td>Printf(“%g”, 10.20)</td><td>10.2</td></tr><tr><td>%G</td><td>根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td><td>Printf(“%G”, 10.20+2i)</td><td>(10.2+2i)</td></tr></tbody></table><ul><li>字符串与字节切片</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%s</td><td>输出字符串表示（string类型或[]byte)</td><td>Printf(“%s”, []byte(“Go语言”))</td><td>Go语言</td></tr><tr><td>%q</td><td>双引号围绕的字符串，由Go语法安全地转义</td><td>Printf(“%q”, “Go语言”)</td><td>“Go语言”</td></tr><tr><td>%x</td><td>十六进制，小写字母，每字节两个字符</td><td>Printf(“%x”, “golang”)</td><td>676f6c616e67</td></tr><tr><td>%X</td><td>十六进制，大写字母，每字节两个字符</td><td>Printf(“%X”, “golang”)</td><td>676F6C616E67</td></tr></tbody></table><ul><li>指针</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%p</td><td>十六进制表示，前缀 0x</td><td>Printf(“%p”, &amp;people)</td><td>0x4f57f0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 占位符 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
