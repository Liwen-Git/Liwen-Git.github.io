<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>laravel 跨域</title>
      <link href="/2019/11/11/laravel-cross-domain/"/>
      <url>/2019/11/11/laravel-cross-domain/</url>
      
        <content type="html"><![CDATA[<h5 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h5><p>出于安全性的原因，浏览器会限制 Script 中的跨域请求。由于 XMLHttpRequest 遵循同源策略，所有使用 XMLHttpRequest 构造 HTTP 请求的应用只能访问自己的域名，如果需要构造跨域的请求，那么开发者需要配合浏览器做出一些允许跨域的配置。</p><a id="more"></a><p>W3C 应用工作组推荐了一种跨资源共享的机制，这种机制让 Web 应用服务器能支持跨站访问控制，从而使得安全的进行跨站数据传输成为可能，该机制通过几种方式来对原有模式进行了扩展：</p><ul><li>响应的头部应该追加 Access-Control-Allow-Orign，用来表明哪些请求源被允许访问资源内容</li><li>浏览器会对请求源和响应中的值进行匹配验证</li><li>对于跨域的请求，浏览器会预发送一个非简单方式的请求，来判断给定资源是否准备接受跨域资源访问</li><li>服务端应用通过检查请求头部的 Orign 来判定请求是否跨域。</li></ul><h5 id="跨源资源共享标准"><a href="#跨源资源共享标准" class="headerlink" title="跨源资源共享标准"></a>跨源资源共享标准</h5><p>跨源资源共享标准通过新增一系列 HTTP 头，让服务器能声明哪些来源可以通过浏览器访问该服务器上的资源。另外，对哪些会对服务器数据造成破坏性响应的 HTTP 请求方法（特别是 GET 以外的 HTTP 方法，或者搭配某些 MIME 类型的 POST 请求），标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求（preflight request），从而获取知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。服务器端也可以通知客户端，是不是需要随同请求一起发送信用信息（包括 Cookies 和 HTTP 认证相关数据）。</p><h5 id="响应头Response-Header"><a href="#响应头Response-Header" class="headerlink" title="响应头Response Header"></a>响应头Response Header</h5><ul><li>Access-Control-Allow-Origin : 指明哪些请求源被允许访问资源，值可以为 “*”，”null”，或者单个源地址。</li><li>Access-Control-Allow-Credentials : 指明当请求中省略 creadentials 标识时响应是否暴露。对于预请求来说，它表明实际的请求中可以包含用户凭证。</li><li>Access-Control-Expose-Headers : 指明哪些头信息可以安全的暴露给 CORS API 规范的 API。</li><li>Access-Control-Max-Age : 指明预请求可以在预请求缓存中存放多久。</li><li>Access-Control-Allow-Methods : 对于预请求来说，哪些请求方式可以用于实际的请求。</li><li>Access-Control-Allow-Headers : 对于预请求来说，指明了哪些头信息可以用于实际的请求中。</li><li>Origin : 指明预请求或者跨域请求的来源。</li><li>Access-Control-Request-Method : 对于预请求来说，指明哪些预请求中的请求方式可以被用在实际的请求中。</li><li>Access-Control-Request-Headers : 指明预请求中的哪些头信息可以用于实际的请求中。</li></ul><h5 id="请求头Request-Header"><a href="#请求头Request-Header" class="headerlink" title="请求头Request Header"></a>请求头Request Header</h5><ul><li>Origin : 表明发送请求或预请求的来源。</li><li>Access-Control-Request-Method : 在发送预请求时带该请求头，表明实际的请求将使用的请求方式。</li><li>Access-Control-Request-Headers : 在发送预请求时带有该请求头，表明实际的请求将携带的请求头。</li></ul><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php namespace App\Http\Middleware;</span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line">use Response;</span><br><span class="line">class EnableCrossRequestMiddleware &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Handle an incoming request.</span><br><span class="line">   *</span><br><span class="line">   * @param  \Illuminate\Http\Request  $request</span><br><span class="line">   * @param  \Closure  $next</span><br><span class="line">   * @return mixed</span><br><span class="line">   */</span><br><span class="line">  public function handle($request, Closure $next)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    $response = $next($request);</span><br><span class="line">        $response-&gt;header(&apos;Access-Control-Allow-Origin&apos;, config(&apos;app.allow&apos;));</span><br><span class="line">        $response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Origin, Content-Type, Cookie, Accept&apos;);</span><br><span class="line">        $response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;GET, POST, PATCH, PUT, OPTIONS&apos;);</span><br><span class="line">        $response-&gt;header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;);</span><br><span class="line">        return $response;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有以下需要注意的地方：</p><ul><li>对于跨域访问并需要伴随认证信息的请求(需要携带cookie的)，需要在 XMLHttpRequest(axios中) 实例中指定 withCredentials 为 true。</li><li>这个中间件你可以根据自己的需求进行构建，如果需要在请求中伴随认证信息（包含 cookie，session）那么你就需要指定 Access-Control-Allow-Credentials 为 true, 因为对于预请求来说如果你未指定该响应头，那么浏览器会直接忽略该响应。</li><li>在响应中指定 Access-Control-Allow-Credentials 为 true 时，Access-Control-Allow-Origin 不能指定为 *</li><li>后置中间件只有在正常响应时才会被追加响应头，而如果出现异常，这时响应是不会经过中间件的。</li><li>注册这个 middleware 到 kernel 中. 分别在 protected $middleware  数组中和 protected $routeMiddleware 数组中，添加我们刚才创建的那个文件class名 和 使用 <code>cors</code> 这个别名.</li><li>本地开发过程中，必须在protected $middleware中添加跨域的中间件才能实现本地跨域。</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP高并发支撑</title>
      <link href="/2019/11/11/php-high-concurrence/"/>
      <url>/2019/11/11/php-high-concurrence/</url>
      
        <content type="html"><![CDATA[<h5 id="简单的架构"><a href="#简单的架构" class="headerlink" title="简单的架构"></a>简单的架构</h5><p><img src="https://www.zlf520.com.cn/storage/blog/Nb878DTceh.png" alt></p><a id="more"></a><h5 id="系统集群化部署"><a href="#系统集群化部署" class="headerlink" title="系统集群化部署"></a>系统集群化部署</h5><p>添加负载均衡层，将请求均匀打到系统层。<br>系统层采用集群化部署多台机器，扛住初步的并发压力。<br><img src="https://www.zlf520.com.cn/storage/blog/Ogr65jgcLd.png" alt></p><h5 id="数据库分库分表-读写分离"><a href="#数据库分库分表-读写分离" class="headerlink" title="数据库分库分表 + 读写分离"></a>数据库分库分表 + 读写分离</h5><p>并发量继续增长时，我们就需要 focus 在数据库层面：分库分表、读写分离。<br><img src="https://www.zlf520.com.cn/storage/blog/16rEhN79QJ.png" alt></p><h5 id="缓存集群引入"><a href="#缓存集群引入" class="headerlink" title="缓存集群引入"></a>缓存集群引入</h5><p>不要盲目进行数据库扩容，数据库服务器成本昂贵，且本身就不是用来承载高并发的<br>针对写少读多的请求，引入缓存集群，用缓存集群抗住大量的读请求<br><img src="https://www.zlf520.com.cn/storage/blog/rBwJS5a4uO.png" alt></p><h5 id="引入消息中间件集群"><a href="#引入消息中间件集群" class="headerlink" title="引入消息中间件集群"></a>引入消息中间件集群</h5><p>消息中间件本身也跟缓存系统一样，可以用很少的资源支撑很高的并发请求，用他来支撑部分允许异步化的高并发写入是没问题的，比使用数据库直接支撑那部分高并发请求要减少很多的机器使用量。<br><img src="https://www.zlf520.com.cn/storage/blog/VCqcK8U5ME.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让Google搜索到搭建在Github Pages上的博客</title>
      <link href="/2019/10/11/google-search-console/"/>
      <url>/2019/10/11/google-search-console/</url>
      
        <content type="html"><![CDATA[<p>使用Hexo博客框架和GitHub结合搭建博客是一种很不错的选择，但是如何能让博客被Google到呢？</p><h4 id="查看是否被收录"><a href="#查看是否被收录" class="headerlink" title="查看是否被收录"></a>查看是否被收录</h4><p>首先查看是否已被Google收录，在Google中搜索：<br><code>site:https://liwen-git.github.io/</code><br>如果未查询到则继续往下看。</p><a id="more"></a><h4 id="搜索资源提交"><a href="#搜索资源提交" class="headerlink" title="搜索资源提交"></a>搜索资源提交</h4><p>进入<a href="https://search.google.com/search-console?resource_id=https%3A%2F%2Fliwen-git.github.io%2F" target="_blank" rel="noopener">Google Search Console</a><br>登录之后，提交自己的博客网址：<br><img src="https://www.zlf520.com.cn/storage/blog/NWsVlwHIhO34Y6ggf22Z7cobgwDQpkUZbmdaThaf.png" alt></p><p>选取HTML标记来进行验证，使用推荐方法会被<code>sudo hexo clean</code>命令清除：<br><img src="https://www.zlf520.com.cn/storage/blog/Ebh4ABIqHxX6gnEXFweD7lhgqVNsdkpBRgcSndhg.png" alt></p><p>将Search Console给的meta标签的信息添加到主题的目录下head.swig文件中，这里使用的是Next主题,其他主题也是类似的，在Hexo/themes/next/layout/_partials/head/head.swig文件中原有meta标签后面添加刚才复制的meta标签。</p><p>这时点击验证是无法通过的，需要将你的修改后的Hexo博客更新并部署到Github Pages上之后才可以验证，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g</span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure><p>验证后会提示成功，点击”继续“，先不要关闭这个页面，后面还要用。</p><h4 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h4><p>站点地图(Site Map)是用来注明网站结构的文件，我们希望搜索引擎的爬虫了解我们的网站结构，以便于高效爬取内容，快速建立索引。</p><h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><p>首先为Hexo安装hexo-generator-sitemap插件，在Hexo博客目录下运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h5 id="重新编译"><a href="#重新编译" class="headerlink" title="重新编译"></a>重新编译</h5><p>配置Hexo的_config.yml文件，添加如下字段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br></pre></td></tr></table></figure><p>然后重新生成博客文件，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo g</span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure><p>此时应该可以在public目录下看到sitemap.xml文件了。</p><h5 id="添加-测试站点地图"><a href="#添加-测试站点地图" class="headerlink" title="添加/测试站点地图"></a>添加/测试站点地图</h5><p>回到之前提交搜索资源的页面，在左边侧边栏找到“站点地图”,添加新的站点地图，将<a href="https://liwen-git.github.io/sitemap.xml提交并刷新，就可以看到博客的网站结构了。" target="_blank" rel="noopener">https://liwen-git.github.io/sitemap.xml提交并刷新，就可以看到博客的网站结构了。</a></p><p><img src="https://www.zlf520.com.cn/storage/blog/N6eBBHxr147jG7kQqIEwJLYXkY4INqpo0ErmrJ1n.png" alt></p><p>如果没有什么问题的话，到这里就结束了，但是现在用Google还不能立即查到博客的内容，要等到搜索引擎下一次更新检索时才会有显示。</p><h5 id="若站点地图无法获取"><a href="#若站点地图无法获取" class="headerlink" title="若站点地图无法获取"></a>若站点地图无法获取</h5><p>如果出现了上图的情况，可能是站点地图生成有问题，可以使用<a href="https://www.xml-sitemaps.com/" target="_blank" rel="noopener">XML-Sitemaps</a>重新生成站点地图，然后下载，替换blog/public中的sitemap.xml文件。<br><img src="https://www.zlf520.com.cn/storage/blog/xhGqFJdJm9KS8V2gNrihpXcH36mWEViJ3E8RGQL9.png" alt></p><h5 id="若站点地图报错：不允许此网址"><a href="#若站点地图报错：不允许此网址" class="headerlink" title="若站点地图报错：不允许此网址"></a>若站点地图报错：不允许此网址</h5><p>可能是站点地图sitemap.xml中的所有网址是以<code>yousite.com</code>开头的，所以站点地图报错</p><blockquote><p>解决：在<code>blog/_config.yml</code>中修改url为你自己的地址<br>之后重新编译上传，重新生成sitemap.xml，重新提交即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Homebrew切换镜像源</title>
      <link href="/2019/09/24/homebrew-mirrors/"/>
      <url>/2019/09/24/homebrew-mirrors/</url>
      
        <content type="html"><![CDATA[<h5 id="切换中科大镜像源："><a href="#切换中科大镜像源：" class="headerlink" title="切换中科大镜像源："></a>切换中科大镜像源：</h5><ol><li>替换brew.git<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Homebrew</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br></pre></td></tr></table></figure></li></ol><p>切换回官方源：</p><blockquote><p><a href="https://github.com/Homebrew/brew" target="_blank" rel="noopener">https://github.com/Homebrew/brew</a></p></blockquote><a id="more"></a><ol start="2"><li>替换homebrew-core.git<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line">brew update</span><br></pre></td></tr></table></figure></li></ol><p>切换官方源：</p><blockquote><p><a href="https://github.com/Homebrew/homebrew-core" target="_blank" rel="noopener">https://github.com/Homebrew/homebrew-core</a></p></blockquote><ol start="3"><li>替换Homebrew Bottles源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profile</span><br><span class="line"></span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ol><p>切换回官方：</p><blockquote><p>删除~/.bash_profile中的HOMEBREW_BOTTLE_DOMAIN源即可</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-ide-helper</title>
      <link href="/2019/09/24/laravel-ide-helper/"/>
      <url>/2019/09/24/laravel-ide-helper/</url>
      
        <content type="html"><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果只想在开发环境安装请加上 --dev</span><br><span class="line">composer require --dev barryvdh/laravel-ide-helper</span><br></pre></td></tr></table></figure><p>在 「config/app.php」的 「providers」数组中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class,</span><br></pre></td></tr></table></figure><blockquote><p>如果你的 Laravel 版本小于 5.5 的话，请注册服务提供者，否则请忽略</p></blockquote><a id="more"></a><p>如果你只在开发环境中安装「larave-ide-helper」，那么可以在「app/Providers/AppServiceProvider.php」的「register」方法中写入下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public function register()</span><br><span class="line">&#123;</span><br><span class="line">    if ($this-&gt;app-&gt;environment() !== &apos;production&apos;) &#123;</span><br><span class="line">        $this-&gt;app-&gt;register(\Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出配置文件,即：config/ide-helper.php（如果默认配置就满足需求了，也可以忽略这一步）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan vendor:publish --provider=&quot;Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider&quot; --tag=config</span><br></pre></td></tr></table></figure><p>好了，接下去可以愉快的使用了</p><h4 id="自动为-Laravel-的-Facades-生成注释"><a href="#自动为-Laravel-的-Facades-生成注释" class="headerlink" title="自动为 Laravel 的 Facades 生成注释"></a>自动为 Laravel 的 Facades 生成注释</h4><p>在命令行下运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan ide-helper:generate</span><br></pre></td></tr></table></figure><blockquote><p>注: 如果存在文件 「bootstrap/compiled.php」 需要先删除， 可以在生成文当前运行 php artisan clear-compiled。</p></blockquote><h4 id="自动为模型生成注释"><a href="#自动为模型生成注释" class="headerlink" title="自动为模型生成注释"></a>自动为模型生成注释</h4><ul><li><p>多个模型：直接 <code>php artisan ide-helper:models</code>，当然也可以 <code>php artisan ide-helper:models -W</code></p></li><li><p>单个模型：这个不能按照 github 上的 readme 来，坑爹。必须指明具体的类全名：<code>php artisan ide-helper:models &quot;App\Http\Models\User&quot;</code>。</p></li></ul><p>为所有模型生成注释 <code>php artisan ide-helper:models</code>, 这时会出现询问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you want to overwrite the existing model files? Choose no to write to _ide_helper_models.php instead? (Yes/No):  (yes/no) [no]:</span><br></pre></td></tr></table></figure><p>输入 yes 则会直接在模型文件中写入注释，否则会生成「_ide_helper_models.php」文件。建议选择 yes，这样在跟踪文件的时候不会跳转到「_ide_helper_models.php」文件，不过这么做最好对模型文件做个备份，至少在生成注释之前用 git 控制一下版本，以防万一。</p><blockquote><p>提示： 为模型生成字段信息必须在数据库中存在相应的数据表，不要生成 migration 还没运行 migrate 的时候就生成注释，这样是得不到字段信息的。</p></blockquote><h4 id="自动为链式操作注释"><a href="#自动为链式操作注释" class="headerlink" title="自动为链式操作注释"></a>自动为链式操作注释</h4><p>这是什么意思呢？举个例子，在 migration 文件中经常可以看见这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$table-&gt;string(&apos;email&apos;)-&gt;unique();</span><br></pre></td></tr></table></figure><p>这时候就算调用过了 <code>php artisan ide-helper:generate</code>，在调用像 -&gt;unique() 这样的链式操作的时候也无法实现代码提示，这时候需要将配置文件「如果导出的话」<code>&#39;include_fluent&#39; =&gt; false</code> 修改为 <code>&#39;include_fluent&#39; =&gt; true</code>，重新运行 <code>php artisan ide-helper:generate</code>。试试效果吧！</p><h4 id="生成-phpStorm-meta-php"><a href="#生成-phpStorm-meta-php" class="headerlink" title="生成 .phpStorm.meta.php"></a>生成 .phpStorm.meta.php</h4><p>可以生成一个PhpStorm meta 文件去支持工厂模式. 对于 Laravel, 这意味着我们可以让 PhpStorm 理解我们从 IoC 容器中解决了什么类型的对象。例如：事件将返回一个「Illuminate\Events\Dispatcher」对象，利用 meta 文件您可以调用 app(‘events’) 并且它将自动完成 Dispatcher 的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app(&apos;events&apos;)-&gt;fire();</span><br><span class="line">\App::make(&apos;events&apos;)-&gt;fire();</span><br><span class="line"></span><br><span class="line">/** @var \Illuminate\Foundation\Application $app */</span><br><span class="line">$app-&gt;make(&apos;events&apos;)-&gt;fire();</span><br><span class="line"></span><br><span class="line">// When the key is not found, it uses the argument as class name</span><br><span class="line">app(&apos;App\SomeClass&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>提示：您可能需要重启 Phpstorm 使 .phpStorm.meta.php 文件生效。</p></blockquote><h4 id="自动运行-generate"><a href="#自动运行-generate" class="headerlink" title="自动运行 generate"></a>自动运行 generate</h4><p>想在依赖包更新是自动更新注释，可以在 composer.json 文件中做如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">    &quot;post-update-cmd&quot;: [</span><br><span class="line">        &quot;Illuminate\\Foundation\\ComposerScripts::postUpdate&quot;,</span><br><span class="line">        &quot;php artisan ide-helper:generate&quot;,</span><br><span class="line">        &quot;php artisan ide-helper:meta&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示：如果只在 dev 环境下部署 ide helper 还是不要这么做了，防止在生产环境中报错导致不必要的麻烦。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TortoiseGit 和 Git 配置使用同一私钥</title>
      <link href="/2019/09/24/tortoisegit-key/"/>
      <url>/2019/09/24/tortoisegit-key/</url>
      
        <content type="html"><![CDATA[<h4 id="tortoisegit-和-git-私钥格式"><a href="#tortoisegit-和-git-私钥格式" class="headerlink" title="tortoisegit 和 git 私钥格式"></a>tortoisegit 和 git 私钥格式</h4><ol><li><p>tortoisegit 默认使用putty格式的私钥（id_rsa.ppk）：<br> <img src="https://www.zlf520.com.cn/storage/blog/putty.jpg" alt></p></li><li><p>git 默认使用openssh格式的私钥 (id_ras)：<br> <img src="https://www.zlf520.com.cn/storage/blog/openssh.jpg" alt></p><a id="more"></a>    </li></ol><h4 id="首先通过ssh-keygen命令生产通用的id-ras-pub公钥-和-id-rsa的git私钥"><a href="#首先通过ssh-keygen命令生产通用的id-ras-pub公钥-和-id-rsa的git私钥" class="headerlink" title="首先通过ssh-keygen命令生产通用的id_ras.pub公钥 和 id_rsa的git私钥"></a>首先通过ssh-keygen命令生产通用的id_ras.pub公钥 和 id_rsa的git私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>然后可以在用户主目录里找到.ssh目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><h4 id="使用puttyGen将git的openssh格式秘钥转化为putty格式"><a href="#使用puttyGen将git的openssh格式秘钥转化为putty格式" class="headerlink" title="使用puttyGen将git的openssh格式秘钥转化为putty格式"></a>使用puttyGen将git的openssh格式秘钥转化为putty格式</h4><ol><li>运行PuTTYGen，在Conversions菜单中点击Import key，选择ssh-keygen生成的私钥文件所在位置，比如id_rsa文件。</li><li>点击Save private key按钮，将其保存为.ppk文件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitLab-ce搭建</title>
      <link href="/2019/09/24/gitlab-ce/"/>
      <url>/2019/09/24/gitlab-ce/</url>
      
        <content type="html"><![CDATA[<h5 id="安装并配置必要的依赖关系"><a href="#安装并配置必要的依赖关系" class="headerlink" title="安装并配置必要的依赖关系"></a>安装并配置必要的依赖关系</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-python openssh-server cronie</span><br><span class="line"></span><br><span class="line">sudo lokkit -s http -s ssh</span><br></pre></td></tr></table></figure><p>安装Postfix以发送通知电子邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install postfix</span><br><span class="line">sudo service postfix start</span><br><span class="line">sudo chkconfig postfix on</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="添加gitLab仓库到yum源，并安装"><a href="#添加gitLab仓库到yum源，并安装" class="headerlink" title="添加gitLab仓库到yum源，并安装"></a>添加gitLab仓库到yum源，并安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash</span><br><span class="line"></span><br><span class="line">sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; yum -y install gitlab-ce</span><br></pre></td></tr></table></figure><p>EXTERNAL_URL是设置用什么域名访问你的gitlab，此时也可以直接yum install gitlab-ce。<br>安装完成后再修改配置文件/etc/gitlab/gitlab.rb</p><h5 id="运行配置命令"><a href="#运行配置命令" class="headerlink" title="运行配置命令"></a>运行配置命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>这样就可以访问你的gitLab了。</p><h5 id="修改nginx端口（使用gitLab内置nginx）"><a href="#修改nginx端口（使用gitLab内置nginx）" class="headerlink" title="修改nginx端口（使用gitLab内置nginx）"></a>修改nginx端口（使用gitLab内置nginx）</h5><ol><li><p>修改nginx端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">nginx[&apos;listen_port&apos;] = 82    #默认值即80端口 nginx[&apos;listen_port&apos;] = nil</span><br><span class="line"></span><br><span class="line">vim /var/opt/gitlab/nginx/conf/gitlab-http.conf</span><br><span class="line"></span><br><span class="line">listen *:82;    #默认值listen *:80;</span><br></pre></td></tr></table></figure></li><li><p>修改unicorn端口(可以不修改)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">unicorn[&apos;port&apos;] = 8082   #原值unicorn[&apos;port&apos;] = 8080</span><br><span class="line"></span><br><span class="line">vim /var/opt/gitlab/gitlab-rails/etc/unicorn.rb</span><br><span class="line"></span><br><span class="line">listen &quot;127.0.0.1:8082&quot;, :tcp_nopush =&gt; true  #原值listen &quot;127.0.0.1:8080&quot;, :tcp_nopush =&gt; true</span><br></pre></td></tr></table></figure></li><li><p>保存配置并重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line">sudo gitlab-ctl restart</span><br><span class="line">sudo gitlab-ctl status</span><br></pre></td></tr></table></figure></li></ol><p>访问 ip:82 成功。</p><h5 id="gitLab服务命令"><a href="#gitLab服务命令" class="headerlink" title="gitLab服务命令"></a>gitLab服务命令</h5><table><thead><tr><th>说明</th><th>常用命令</th></tr></thead><tbody><tr><td>重新加载配置， 每次修改/etc/gitlab/gitlab.rb文件之后执行</td><td>sudo gitlab-ctl reconfigure</td></tr><tr><td>启动</td><td>sudo gitlab-ctl start</td></tr><tr><td>停止</td><td>sudo gitlab-ctl stop</td></tr><tr><td>重启</td><td>sudo gitlab-ctl restart</td></tr><tr><td>查看状态</td><td>sudo gitlab-ctl status</td></tr><tr><td>查看所有日志</td><td>sudo gitlab-ctl tail</td></tr><tr><td>查看 nginx 访问日志</td><td>sudo gitlab-ctl tail nginx/gitlab_acces.log</td></tr><tr><td>查看 postgresql 日志</td><td>sudo gitlab-ctl tail postgresql</td></tr><tr><td>检查gitLab状态</td><td>gitlab-rake gitlab:check</td></tr><tr><td>检查环境和配置是否正确</td><td>gitlab-rake gitlab:env:info</td></tr><tr><td>清除缓存</td><td>gitlab-rake cache:clear</td></tr></tbody></table><h5 id="相关文件位置"><a href="#相关文件位置" class="headerlink" title="相关文件位置"></a>相关文件位置</h5><table><thead><tr><th>内容</th><th>位置</th></tr></thead><tbody><tr><td>日志</td><td>/var/log/gitlab</td></tr><tr><td>gitlab_url</td><td>/opt/gitlab/embedded/service/gitlab-shell/config.yml</td></tr><tr><td>nginx配置</td><td>/var/opt/gitlab/nginx/conf/gitlab-http.conf</td></tr><tr><td>gitlab主配置文件</td><td>/etc/gitlab/gitlab.rb</td></tr><tr><td>ssh路径url配置文件</td><td>/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</td></tr></tbody></table><h5 id="gitLab修改ssh默认端口"><a href="#gitLab修改ssh默认端口" class="headerlink" title="gitLab修改ssh默认端口"></a>gitLab修改ssh默认端口</h5><ul><li>vim /etc/gitlab/gitlab.rb<br>找到：gitlab_rails[‘gitlab_shell_ssh_port’] = 22</li><li>修改为：【你服务器ssh登录的端口】</li><li>重新编译：gitlab-ctl stop<br>gitlab-ctl reconfigure<br>gitlab-ctl start</li></ul><h5 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h5><blockquote><p>问题：访问报500错误<br>原因：运行gitlab-rake gitlab:check，发现gitlab-shell self-check failed；再运行sudo gitlab-ctl restart，发现redis出现timeout；<br>解决：找不到原因，暂时方法是 ps -ef | grep runsv 找到redis 的父级进程，kill -9 xxxx 全部杀掉后会自动拉起。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer autoload</title>
      <link href="/2019/09/19/composer-autoload/"/>
      <url>/2019/09/19/composer-autoload/</url>
      
        <content type="html"><![CDATA[<p>对于类库的自动加载，Composer 生成了一个 vendor/autoload.php 文件。引入这个文件，就能得到一个免费的自动加载支持。</p><blockquote><p>本文主要是介绍如何利用 Composer 自带的自动加载机制，加载本地自定义的包（即不是来自于 packagist）。</p></blockquote><a id="more"></a><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在 composer.json 文件中的 autoload 字段中添加自己的 autoloader。</p><h5 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">First/</span><br><span class="line">    |---examples/</span><br><span class="line">        |---get.php</span><br><span class="line">    |---src/</span><br><span class="line">        |---Curl.php</span><br><span class="line">    |---vendor/</span><br><span class="line">        |---composer/</span><br><span class="line">        |---autoload.php</span><br><span class="line">    |---composer.json</span><br><span class="line">    |---classmap</span><br><span class="line">        |---lib</span><br><span class="line">            |---src</span><br><span class="line">    |---ext</span><br><span class="line">        |---common</span><br><span class="line">        |   |---functions</span><br><span class="line">        |---system</span><br><span class="line">            |---functions</span><br></pre></td></tr></table></figure><h5 id="介绍PSR-4自动加载方式"><a href="#介绍PSR-4自动加载方式" class="headerlink" title="介绍PSR-4自动加载方式"></a>介绍PSR-4自动加载方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;First\\&quot;: &quot;src/&quot;,</span><br><span class="line">            &quot;Temp\\&quot;: &quot;lib/&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码采用 PSR-4 规范，该规范包含了 PHP 最新的自动加载标准，它要求必须使用 namespace （命名空间）的方式。</p><p>First\ 表示命名空间，必须以 \ 结尾，避免相似的命名空间导致冲突，若包含子命名空间，可以这样表示：First\Second\。</p><p>src/ 表示命名空间所在目录为与 Composer 的 vendor 目录同级的 src 目录，如上图框架结构所示。</p><p>如果需要在多个目录下搜索相同的命名前缀，可以用一个数组提供：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;First\\&quot;: [&quot;src/&quot;, &quot;lib/&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完 composer.json 的 autoload 字段后需要更新一下 Composer 的自动加载类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer dump-autoload</span><br></pre></td></tr></table></figure><p>对应 Curl.php 的命名空间如下表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace First;</span><br><span class="line"></span><br><span class="line">class Curl</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用 Curl.php 的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require &apos;../vendor/autoload.php&apos;;</span><br><span class="line"></span><br><span class="line">use First\Curl;</span><br><span class="line"></span><br><span class="line">$curl = new Curl();</span><br><span class="line">. . .</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><h5 id="classmap模式"><a href="#classmap模式" class="headerlink" title="classmap模式"></a>classmap模式</h5><p>懒加载，扫描目录下的所有类文件，支持递归扫描， 生成对应的类名=&gt;路径的映射，当载入需要的类时直接取出路径，速度最快<br><code>composer.json</code>的<code>autoload</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// classmap 扫描目录下的所有类文件 生成对应的类名=&gt;路径的映射</span><br><span class="line">&quot;classmap&quot;: [</span><br><span class="line">    &quot;classmap/lib/src/&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="files模式"><a href="#files模式" class="headerlink" title="files模式"></a>files模式</h5><p>自动载入的文件，主要用来载入一些没办法懒加载的公共函数<br><code>composer.json</code>的<code>autoload</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 扫描目录下的所有文件生成 hash =&gt; 路径的映射  运行时实时加载</span><br><span class="line">// 主要用来载入工具函数</span><br><span class="line">&quot;files&quot;: [</span><br><span class="line">    &quot;ext/common/functions.php&quot;,</span><br><span class="line">    &quot;ext/system/functions.php&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer镜像</title>
      <link href="/2019/09/19/composer-images/"/>
      <url>/2019/09/19/composer-images/</url>
      
        <content type="html"><![CDATA[<p>启用镜像服务的方式有两种：<br><strong>系统全局配置</strong> ：即将配置信息添加到composer的全局配置文件config.json中。<br><strong>单个项目配置</strong> ：将配置信息添加到某个项目的composer.json文件中</p><a id="more"></a><ul><li><p>修改composer 的全局配置文件<br>打开命令行（windows用户）或控制台（Linux、Mac用户）并执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- phpcomposer ---</span><br><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br><span class="line">--- aliyun 推荐 ---</span><br><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure></li><li><p>修改当前项目的composer.json配置文件：<br>进入项目根目录（也就是composer.json文件所在目录），执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure></li></ul><p>上述命令将会在当前项目中的composer.json文件的末尾自动添加镜像的配置信息（你自己也可以手动添加）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">        &quot;url&quot; : &quot;https://packagist.phpcomposer.com&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>查看composer镜像地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -gl</span><br></pre></td></tr></table></figure></li><li><p>取消配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g --unset repos.packagist</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer简介</title>
      <link href="/2019/09/19/composer/"/>
      <url>/2019/09/19/composer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。</p></blockquote><a id="more"></a><h5 id="简单解释"><a href="#简单解释" class="headerlink" title="简单解释"></a>简单解释</h5><ul><li><strong>composer install</strong> - 如有 composer.lock 文件，直接安装，否则从 composer.json 安装最新扩展包和依赖；</li><li><strong>composer update</strong> - 从 composer.json 安装最新扩展包和依赖；</li><li><strong>composer update vendor/package</strong> - 从 composer.json 或者对应包的配置，并更新到最新；</li><li><strong>composer require new/package</strong> - 添加安装 new/package , 可以指定版本，如： composer require new/package ~2.5。</li></ul><p>介绍几个日常生产流程</p><ol><li>新项目流程</li></ol><ul><li>运行 composer install ，安装扩展包并生成 composer.lock ；</li><li>提交 composer.lock 到代码版本控制器中，如：git;</li></ul><ol start="2"><li>项目协作者安装现有项目</li></ol><ul><li>克隆项目后，根目录下直接运行 composer install 从 composer.lock 中安装 指定版本 的扩展包以及其依赖；<blockquote><p>此流程适用于生产环境代码的部署。</p></blockquote></li></ul><ol start="3"><li>为项目添加新扩展包</li></ol><ul><li>使用 composer require vendor/package 添加扩展包；</li><li>提交更新后的 composer.json 和 composer.lock 到代码版本控制器中，如：git;</li></ul><h5 id="关于-composer-lock-文件"><a href="#关于-composer-lock-文件" class="headerlink" title="关于 composer.lock 文件"></a>关于 composer.lock 文件</h5><blockquote><p><strong>composer.lock</strong>  文件里保存着对每一个代码依赖的版本记录（见下图），提交到版本控制器中，并配合  <strong>composer install</strong>  使用，保证了团队所有协作者开发环境、线上生产环境中运行的代码版本的一致性。</p></blockquote><h5 id="关于扩展包的安装方法"><a href="#关于扩展包的安装方法" class="headerlink" title="关于扩展包的安装方法"></a>关于扩展包的安装方法</h5><p>那么，准备添加一个扩展包，install, update, require 三个命令都可以用来安装扩展包，选择哪一个才是正确的呢？<br>答案是：使用 <strong>composer require</strong> 命令</p><p>另外，在手动修改 composer.json 添加扩展包后， <strong>composer update new/package</strong> 进行指定扩展包更新的方式，也可以正确的安装，不过不建议使用这种方法，因为，一旦你忘记敲定后面的扩展包名，就会进入万劫不复的状态，别给自己留坑呀。</p><p>上面的概念不论对新手或者老手来说，都比较混淆，主要记住这个概念：</p><blockquote><p>原有项目新添加扩展的，都使用 <strong>composer require new/package</strong> 这种方式来安装。</p></blockquote><p>更新指定扩展到指定版本可以指定版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require &quot;foo/bar:1.0.0&quot;</span><br></pre></td></tr></table></figure><h5 id="composer其他"><a href="#composer其他" class="headerlink" title="composer其他"></a>composer其他</h5><ul><li>composer 自身升级：<strong>composer self-update</strong></li><li>composer 回滚：<strong>composer self-update –rollback</strong></li><li>composer中require 和 require-dev的区别：前者用于声明项目发布版本的依赖包，后者用于声明项目开发或测试中依赖的包。</li></ul><h5 id="composer版本号-前置-和-符号的区别"><a href="#composer版本号-前置-和-符号的区别" class="headerlink" title="composer版本号 前置~和^符号的区别"></a>composer版本号 前置~和^符号的区别</h5><p><code>~</code>和<code>^</code>的意思很接近，在<code>x.y</code>的情况下是一样的都是代表<code>x.y &lt;= 版本号 &lt; (x+1).0</code>，但是在版本号是<code>x.y.z</code>的情况下有区别，举个例子吧：</p><ul><li>~1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 1.3.0</li><li>^1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 2.0.0</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>govendor</title>
      <link href="/2019/09/18/govendor/"/>
      <url>/2019/09/18/govendor/</url>
      
        <content type="html"><![CDATA[<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><code>go get -u github.com/kardianos/govendor</code></p><a id="more"></a><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在项目根目录下执行以下命令进行vendor初始化：<br><code>govendor init</code></p><p>项目根目录下即会自动生成 vendor 目录和 vendor.json 文件</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><ul><li><p>将 已被引用 且在 $GOPATH 下的所有包复制到vendor目录<br><code>govendor add +external</code></p></li><li><p>仅从 $GOPATH 中复制指定包<br><code>govendor add gopkg.in/yaml.v2</code></p></li><li><p>列出代码中所有被引用到的包及其状态<br><code>govendor list</code></p></li><li><p>从远程仓库添加或更新某个包(不会在 $GOPATH 也存一份)<br><code>govendor fetch golang.org/x/net/context</code></p></li><li><p>安装指定版本的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</span><br><span class="line">govendor fetch golang.org/x/net/context@v1   # Get latest v1.*.* tag or branch.</span><br><span class="line">govendor fetch golang.org/x/net/context@=v1  # Get the tag or branch named &quot;v1&quot;.</span><br></pre></td></tr></table></figure></li><li><p>删除vendor中已有 但是代码中未使用的包<br><code>govendor remove +unused</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> govendor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>supervisor 维护 golang 进程</title>
      <link href="/2019/09/18/go-supervisor/"/>
      <url>/2019/09/18/go-supervisor/</url>
      
        <content type="html"><![CDATA[<h4 id="代码准备工作"><a href="#代码准备工作" class="headerlink" title="代码准备工作"></a>代码准备工作</h4><p>在代码目录执行<code>go build</code>或者<code>go install</code>来生成可执行文件</p><blockquote><p>注意：如果使用<code>go install</code>生成在bin目录下的可执行文件，需要注意代码中的日志目录问题</p></blockquote><a id="more"></a><h4 id="安装supervisor"><a href="#安装supervisor" class="headerlink" title="安装supervisor"></a>安装supervisor</h4><p>官网地址：<a href="http://supervisord.org/index.html" target="_blank" rel="noopener">http://supervisord.org/index.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python-setuptools</span><br><span class="line">sudo easy_install supervisor 或者 sudo pip install supervisor</span><br></pre></td></tr></table></figure><p>安装成功后，生成配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure><h4 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h4><p>新建一个文件夹专门放置.conf文件</p><p>在<code>/etc/</code>下新建<code>supervisor_conf_file</code>文件夹，并在该文件加下新建<code>gin_api.conf</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[program:gin_api]</span><br><span class="line">user=root</span><br><span class="line">command=/home/go/src/gin_api/gin_api #go可执行文件路劲</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=10</span><br><span class="line">stdout_logfile=/root/supervisor_log/gin_api.log #标准输出log，得去相应的目录下新建log</span><br><span class="line">stdout_logfile_maxbytes=1MB</span><br><span class="line">stdout_logfile_backups=10</span><br><span class="line">stdout_capture_maxbytes=1MB</span><br><span class="line">stderr_logfile=/root/supervisor_log/gin_api_err.log #错误输出log，得去相应的目录下新建log</span><br><span class="line">stderr_logfile_maxbytes=1MB</span><br><span class="line">stderr_logfile_backups=10</span><br><span class="line">stderr_capture_maxbytes=1MB</span><br><span class="line">stopsignal=INT</span><br><span class="line">[supervisord]</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">command：表示运行的命令，我这是填写的我demo安装包的原则路径。</span><br><span class="line">autostart：表示是否跟随supervisor一起启动。</span><br><span class="line">autorestart：如果该程序挂了，是否重新启动。</span><br><span class="line">stdout_logfile：终端标准输出重定向文件。</span><br><span class="line">stderr_logfile：终端错误输出重定向文件。</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>编辑 <code>/etc/supervisord.conf</code>，将文件最下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;[include]</span><br><span class="line">;files = relative/directory/*.ini</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files = /etc/supervisor_conf_file/*.conf</span><br></pre></td></tr></table></figure><h4 id="启动supervisord"><a href="#启动supervisord" class="headerlink" title="启动supervisord"></a>启动supervisord</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>若报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Another program is already listening on a port that one of our HTTP servers is configured to use.  Shut this program down first before starting supervisord.</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name supervisor.sock</span><br><span class="line">unlink /xxx/supervisor.sock</span><br></pre></td></tr></table></figure><p>之后再次执行启动命令。</p><p>执行命令查看gin_api服务是否启动成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo supervisorctl status</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gin_api                          RUNNING   pid 7648, uptime 0:09:57</span><br></pre></td></tr></table></figure><p>ps:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@accapp /home/go/src/gin_api]# supervisorctl </span><br><span class="line">gin_api                          RUNNING   pid 7648, uptime 0:02:39</span><br><span class="line">supervisor&gt; help</span><br><span class="line"></span><br><span class="line">default commands (type help &lt;topic&gt;):</span><br><span class="line">=====================================</span><br><span class="line">add    exit      open  reload  restart   start   tail   </span><br><span class="line">avail  fg        pid   remove  shutdown  status  update </span><br><span class="line">clear  maintail  quit  reread  signal    stop    version</span><br><span class="line"></span><br><span class="line">supervisor&gt; exit</span><br><span class="line">[root@accapp /home/go/src/gin_api]#</span><br></pre></td></tr></table></figure><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul><li><p>停止supervisor(子进程也会被停止)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl shutdown</span><br></pre></td></tr></table></figure></li><li><p>把 supervisor 相关的进程都杀掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(ps -ef|grep supervisor | awk &apos;&#123;print $2&#125;&apos;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="解决unix-tmp-supervisor-sock-no-such-file的问题"><a href="#解决unix-tmp-supervisor-sock-no-such-file的问题" class="headerlink" title="解决unix:///tmp/supervisor.sock no such file的问题"></a>解决unix:///tmp/supervisor.sock no such file的问题</h4><p>原因：tmp目录中的文件被Linux自动清除了</p><ol><li><p>新建目录和修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p  /var/supervisor_tmp/run</span><br><span class="line">sudo mkdir -p  /var/supervisor_tmp/log</span><br><span class="line"></span><br><span class="line">sudo chmod 777 /var/supervisor_tmp/run</span><br><span class="line">sudo chmod 777 /var/supervisor_tmp/log</span><br></pre></td></tr></table></figure></li><li><p>修改/etc/supervisor.conf配置文件<br>把所有的<code>/tmp</code>路径修改掉：<br><code>/tmp/supervisor.sock</code> 改成 <code>/var/supervisor_tmp/run/supervisor.sock</code><br><code>/tmp/supervisord.log</code> 改成 <code>/var/supervisor_tmp/log/supervisor.log</code><br><code>/tmp/supervisord.pid</code> 改成 <code>/var/supervisor_tmp/run/supervisor.pid</code></p></li><li><p>重启<br>杀掉supervisor进程和子进程，再启动supervisor</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> supervisor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>provide 和 inject</title>
      <link href="/2019/09/18/provide-and-inject/"/>
      <url>/2019/09/18/provide-and-inject/</url>
      
        <content type="html"><![CDATA[<p><strong>官网解释</strong>：<a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">provider/inject</a></p><p><strong>provider/inject</strong>：简单的来说就是在父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。</p><blockquote><p>需要注意的是这里不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据。</p></blockquote><a id="more"></a><p>示例：</p><ul><li><p>first：定义一个parent component, 在这里我们在父组件中provide for这个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;childOne&gt;&lt;/childOne&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import childOne from &apos;../components/test/ChildOne&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &quot;Parent&quot;,</span><br><span class="line">    provide() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            for: &quot;demo&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        childOne</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>second 定义一个子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;demo&#125;&#125;</span><br><span class="line">    &lt;childtwo&gt;&lt;/childtwo&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import childtwo from &apos;./ChildTwo&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;childOne&quot;,</span><br><span class="line">    inject: [&apos;for&apos;],</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        demo: this.for</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      childtwo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>third 定义另一个子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;demo&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    inject: [&apos;for&apos;],</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        demo: this.for</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>在2个子组件中我们使用jnject注入了provide提供的变量for，并将它提供给了data属性。</p><p>运行结果是 demo demo</p><blockquote><p>从上面这个例子可以看出，只要在父组件中调用了，那么在这个父组件生效的生命周期内，所有的子组件都可以调用inject来注入父组件中的值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive的作用</title>
      <link href="/2019/09/18/keep-alive/"/>
      <url>/2019/09/18/keep-alive/</url>
      
        <content type="html"><![CDATA[<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在vue项目中,难免会有列表页面或者搜索结果列表页面,点击某个结果之后,返回回来时,如果不对结果页面进行缓存,那么返回列表页面的时候会回到初始状态,但是我们想要的结果是返回时这个页面还是之前搜索的结果列表,这时候就需要用到vue的keep-alive技术了.<br>本人遇到的问题是element切换tab的时候，页面不会缓存，所以需要使用keep-alive。</p><a id="more"></a><h5 id="keep-alive-简介"><a href="#keep-alive-简介" class="headerlink" title="keep-alive 简介"></a>keep-alive 简介</h5><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p><p>用法也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- 该组件将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p><strong>props</strong></p><ul><li>include - 字符串或正则表达，只有匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 组件 a</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;a&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;a&quot;&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- name 为 a 的组件将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude=&quot;a&quot;&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><h5 id="配合vue-router共同使用"><a href="#配合vue-router共同使用" class="headerlink" title="配合vue-router共同使用"></a>配合vue-router共同使用</h5><p>但实际项目中,常需要配合vue-router共同使用.</p><p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view&gt;</span><br><span class="line">        &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt;</span><br><span class="line">    &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>如果只想 router-view 里面某个组件被缓存，怎么办？</p><p>增加 <strong>router.meta</strong> 属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// routes 配置</span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    name: &apos;home&apos;,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: true // 需要被缓存</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &apos;/:id&apos;,</span><br><span class="line">    name: &apos;edit&apos;,</span><br><span class="line">    component: Edit,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: false // 不需要被缓存</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;</span><br><span class="line">        &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;</span><br><span class="line">    &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;</span><br><span class="line">    &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel篇</title>
      <link href="/2019/08/08/laravel-question/"/>
      <url>/2019/08/08/laravel-question/</url>
      
        <content type="html"><![CDATA[<h6 id="1-简述laravel的生命周期"><a href="#1-简述laravel的生命周期" class="headerlink" title="1. 简述laravel的生命周期"></a>1. 简述laravel的生命周期</h6><p><img src="https://www.zlf520.com.cn/storage/blog/2D6A568E-F7DD-4DAF-B460-A7C0BD15DA60.png" alt="2623c78f9e824fb89db4552be669404c"></p><a id="more"></a><ol><li>导入composer自动加载功能，加载框架类库</li><li>引入laravel应用程序实例App</li></ol><ul><li>启动容器</li><li>注册http处理器</li><li>注册console处理器</li><li>注册异常处理器</li></ul><ol start="3"><li>启动http处理器，接收request请求</li><li>以管道的设计模式，执行部分（全局）中间件</li><li>路由解析调度</li><li>实例化当前控制器</li><li>执行web中间件</li><li>执行控制器中间件</li><li>执行控制器操作</li><li>返回response</li><li>结束框架</li></ol><hr><blockquote><p>Laravel采用了单一的入口模式，应用的所有请求入口都是public/index.php文件。</p><ol><li>注册类文件自动加载器：laravel通过composer进行依赖管理，无需开发者手动导入各种类文件，而由自动加载器自行导入。</li><li>创建服务容器：从bootstrap/app.php文件中取得laravel应用实例$app（服务容器）</li><li>创建HTTP/Console内核：传入的请求会被发送给HTTP内核或者console内核进行处理</li><li>载入服务提供者至容器：在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的应用，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件</li><li>分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给路由进行分发。路由将分发请求给一个路由或控制器，同时运行路由指定的中间件</li></ol></blockquote><hr><h6 id="2-服务提供者是什么？"><a href="#2-服务提供者是什么？" class="headerlink" title="2. 服务提供者是什么？"></a>2. 服务提供者是什么？</h6><blockquote><p>服务提供者是所有laravel应用程序引导启动的中心，laravel的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。</p></blockquote><h6 id="3-IoC容器是什么？"><a href="#3-IoC容器是什么？" class="headerlink" title="3. IoC容器是什么？"></a>3. IoC容器是什么？</h6><blockquote><p>IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。</p><p>Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。</p></blockquote><h6 id="4-Facades-是什么？"><a href="#4-Facades-是什么？" class="headerlink" title="4. Facades 是什么？"></a>4. Facades 是什么？</h6><blockquote><p>Facades（一种设计模式，通常翻译为外观模式）提供了一个”static”（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。</p></blockquote><h6 id="5-Contract-是什么？"><a href="#5-Contract-是什么？" class="headerlink" title="5. Contract 是什么？"></a>5. Contract 是什么？</h6><blockquote><p>Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。</p></blockquote><h6 id="6-谈谈-Laravel-和-YII-框架的区别"><a href="#6-谈谈-Laravel-和-YII-框架的区别" class="headerlink" title="6. 谈谈 Laravel 和 YII 框架的区别"></a>6. 谈谈 Laravel 和 YII 框架的区别</h6><blockquote><ol><li>在 YII 框架中的路由是通过书写 Controller、Action 间接定义路由，而 Laravel 中是在 route 路由文件中直接定义路由入口</li><li>Laravel 提供 ORM 对象关系映射，使读写数据库的操作更加简单</li><li>Laravel 提供更多的 Artisan 命令和脚手架开发</li><li>Laravel 的 Composer 扩展包比 Yii 框架更多，开发更加高效</li></ol></blockquote><h6 id="7-谈谈-Laravel-和-TP5-框架的区别"><a href="#7-谈谈-Laravel-和-TP5-框架的区别" class="headerlink" title="7. 谈谈 Laravel 和 TP5 框架的区别"></a>7. 谈谈 Laravel 和 TP5 框架的区别</h6><blockquote><ol><li>提交数据的方式：laravel在提交表单的时候需要在表单中加入{csrc_field}来防止跨域攻击；TP不会。</li><li>路由：laravel必须先定义，再使用；TP在配置文件中开启路由。</li><li>中间件：laravel中间件，就是http请求到达之前经过的层，通过中间件我们可以验证用户是否登录等一些通用操作。</li><li>操作数据库的方式：都可以使用实例化（建立相对应的模型类）和DB::table来操作数据库。使用原生查询时不太一样，laravel使用Db::操作(‘原生sql’)，TP使用Db::query(‘原生sql’)。</li><li>Laravel升级十分简易，而TP大版本的升级要重构代码。</li><li>条件判断语句书写方式的差异： laravel框架里 if else判断语句和foreach语句 书写时必须以@if开头  以@endif结尾,如果没有则报语法错误,@foreach @endforeach同理；而TP框架则和PHP语法规则使用方式一致直接ifesle语句判断和foreach循环遍历。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx和php-fpm结合</title>
      <link href="/2019/08/08/nginx-and-php-fpm/"/>
      <url>/2019/08/08/nginx-and-php-fpm/</url>
      
        <content type="html"><![CDATA[<pre><code>Nginx不只有处理http请求的功能，还能做反向代理。Nginx通过反向代理功能将动态请求转向后端Php-fpm。</code></pre><blockquote><p>在 Linux 上，nginx 与 php-fpm 的通信有 tcp socket 和 unix socket 两种方式。</p></blockquote><ul><li>tcp socket 的优点是可以跨服务器，当 nginx 和 php-fpm 不在同一台机器上时，只能使用这种方式。</li><li>Unix socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信，这种方式需要在 nginx配置文件中填写 php-fpm 的 socket 文件位置。</li></ul><a id="more"></a><p>两种方式的数据传输过程如下图所示：<br><img src="http://www.zlf520.com.cn/storage/blog/157A0895-F0C5-4DF6-AC53-3DB3A8C02F89.png" alt="40ef8c1f5cb07d102bc9b37368a786e5"></p><p>二者的不同：</p><blockquote><p>由于 Unix socket 不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。所以其效率比 tcp socket 的方式要高，可减少不必要的 tcp 开销。不过，unix socket 高并发时不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。而 tcp 这样的面向连接的协议，可以更好的保证通信的正确性和完整性。</p></blockquote><p><strong>下面我们来配置一个全新的Nginx+Php-fpm</strong></p><ol><li><p>配置nginx.conf文件<br>进入nginx目录下，编辑nginx.conf文件。<br>如图，在nginx.conf最后一行，添加include文件<br><img src="https://www.zlf520.com.cn/storage/blog/B7B7E402-287A-48B6-BCBA-AABA649299EC.png" alt="d1e54053831e3288467bad22e8ebaeb5"></p></li><li><p>添加对应的server<br>进入上面的include的路径，添加一个server<br><img src="https://www.zlf520.com.cn/storage/blog/021D27C6-11AC-4B88-B4BA-1F2813999A00.png" alt="dc5882516f01acc2bca56dea6c685fa7"><br>unix socket 方式 修改fastcgi_pass如下<br><code>fastcgi_pass unix:/usr/run/php-fpm.sock</code></p></li></ol><p><strong>下面我们解释下配置项的含义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80; #监听80端口，接收http请求</span><br><span class="line">    server_name  www.example.com; #就是网站地址</span><br><span class="line">    root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径</span><br><span class="line">    #路由到网站根目录www.example.com时候的处理</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.php; #跳转到www.example.com/index.php</span><br><span class="line">        autoindex on;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    #当请求网站下php文件的时候，反向代理到php-fpm</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块</span><br><span class="line">        fastcgi_intercept_errors on;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口</span><br><span class="line">        # fasrcgi_pass /usr/run/php-fpm.sock   #unix socket 连接方式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面我们启用php的php-fpm来处理这个请求</strong><br>打开php-fpm.conf文件，我们看到如下配置：<br><img src="https://www.zlf520.com.cn/storage/blog/D15767C9-0B46-4DF9-97FD-F4D60A5F96B7.png" alt="ab60dcdb0f77e985dc233cd54e0b2fb8"><br>unix socket 方式 修改php-fpm.conf如下<br><code>listen = /usr/run/php-fpm.sock</code></p><blockquote><p>即：php-fpm模块监听127.0.0.1:9000端口 或者 php-fpm.sock文件，等待请求到来去处理。</p></blockquote><blockquote><p>注意：在使用 unix socket 方式连接时，由于 socket 文件本质上是一个文件，存在权限控制的问题，所以需要注意 nginx 进程的权限与 php-fpm 的权限问题，不然会提示无权限访问。（在各自的配置文件里设置用户）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> php-fpm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac + Hexo + GitHub + Next 搭建博客</title>
      <link href="/2019/07/09/mac-hexo/"/>
      <url>/2019/07/09/mac-hexo/</url>
      
        <content type="html"><![CDATA[<h5 id="1-安装node-js-和-git"><a href="#1-安装node-js-和-git" class="headerlink" title="1. 安装node.js 和 git"></a>1. 安装node.js 和 git</h5><p>mac上使用brew安装node 和 git<br>测试安装是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v   </span><br><span class="line"># 同时可以配置下npm镜像：npm config set registry https://registry.npm.taobao.org</span><br><span class="line"># 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info express</span><br><span class="line">git --versoin</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h5><p>安装时注意权限问题，加上sudo，其中-g表示全局安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>npm全局安装的包的存储路径是<code>/usr/local/lib/node_modules/</code></p><h5 id="3-博客初始化"><a href="#3-博客初始化" class="headerlink" title="3. 博客初始化"></a>3. 博客初始化</h5><p>创建博客的文件夹，并进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure><p>初始化博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 安装时 node-pre-gyp 报错，执行如下命令可以解决</span><br><span class="line">sudo npm install --unsafe-perm</span><br></pre></td></tr></table></figure><p>执行下述命令生成本地网页文件并开启服务器，然后通过<a href="http://localhost:4000查看本地博客" target="_blank" rel="noopener">http://localhost:4000查看本地博客</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g</span><br><span class="line">sudo hexo s  或者 sudo hexo s -p 4000</span><br></pre></td></tr></table></figure><h5 id="4-上传github"><a href="#4-上传github" class="headerlink" title="4. 上传github"></a>4. 上传github</h5><p>在github中新建仓库，名称必须为 <code>user.github.io</code>，如：<code>Liwen-Git.github.io</code></p><p>配置hexo的_config.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  blog</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure><p>在文档的最后部分，将deploy配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/Liwen-Git/Liwen-Git.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>注意type、repository、branch后均有空格。通过如下命令在blog下生成静态文件并上传到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g</span><br><span class="line"># 出错执行 sudo npm install hexo --save</span><br><span class="line">sudo hexo d</span><br><span class="line"># 出错执行 sudo npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>执行<code>hexo d</code> 时会提示输入GitHub账号用户名和密码，执行成功之后通过 <a href="https://liwen-git.github.io/" target="_blank" rel="noopener">https://liwen-git.github.io/</a> 访问博客</p><h5 id="5-更换Next主题"><a href="#5-更换Next主题" class="headerlink" title="5. 更换Next主题"></a>5. 更换Next主题</h5><p>推荐使用hexo-theme-next主题<br>在blog目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><p>修改blog目录下_config.yml里的theme名称为：next<br>其他的，如title: 李子园、language: zh-CN、都可以自己配置</p><p>执行如下命令（每次部署文章的步骤）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g  //生成缓存和静态文件</span><br><span class="line">sudo hexo d  //重新部署到服务器</span><br></pre></td></tr></table></figure><p>当本地博客部署到服务器后，网页端无变化时可以采用下述命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo clean  //清楚缓存文件(db.json)和已生成的静态文件(public)</span><br></pre></td></tr></table></figure><h5 id="6-配置next主题"><a href="#6-配置next主题" class="headerlink" title="6. 配置next主题"></a>6. 配置next主题</h5><p>修改next主题的配置文件_config.yml主题为：Gemini（打开注释）</p><p>修改next主题配置文件，在menu处，打开tags和categories的注释</p><ul><li>创建tag页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure></li></ul><p>然后再blog/sources中会多了一个tags文件夹，修改其中的index.md文件，type修改为tags</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-07-08 23:15:25</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>创建categories页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure></li></ul><p>然后再blog/sources中会多了一个categories文件夹，修改其中的index.md文件，type修改为categories</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-07-08 23:15:25</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h5 id="7-安装搜索功能-Local-Search"><a href="#7-安装搜索功能-Local-Search" class="headerlink" title="7. 安装搜索功能 Local Search"></a>7. 安装搜索功能 Local Search</h5><p>在next的_config.yml文件中修改Local Search的<code>enable: true</code><br>在根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-generator-search --save</span><br><span class="line">sudo npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>在根目录的_config.yml文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><h5 id="8-新建文章"><a href="#8-新建文章" class="headerlink" title="8. 新建文章"></a>8. 新建文章</h5><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo new post 文件名可以不是文章名</span><br></pre></td></tr></table></figure><p>给文章添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Mac + Hexo + GitHub + Next 搭建博客</span><br><span class="line">date: 2019-07-08 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- mac</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">- next</span><br><span class="line">- 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>站点首页不显示文章全文，文章摘要设置<br>这里我们可以通过在文章使用<code>&lt;!-- more --&gt;</code>标志来精确控制文章的摘要预览</p>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/07/08/php-design-patterns/"/>
      <url>/2019/07/08/php-design-patterns/</url>
      
        <content type="html"><![CDATA[<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。</p><p>策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。</p><p>策略模式的三个角色：</p><ol><li>抽象策略角色</li><li>具体策略角色</li><li>环境角色（对抽象策略角色的引用）</li></ol><p>实现步骤：</p><ol><li>定义抽象角色类（定义好各个实现的共同抽象方法）</li><li>定义具体策略类（具体实现父类的共同方法）</li><li>定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法）</li></ol><a id="more"></a><p>就在编程领域外，有许多例子是关于策略模式的。例如：</p><p>如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。</p><p>策略模式的代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 抽象策略类</span><br><span class="line">abstract class baseAgent &#123;</span><br><span class="line">            abstract function PrintPage();</span><br><span class="line">&#125;</span><br><span class="line">// 用于客户端是IE时调用的类（环境角色）</span><br><span class="line">class ieAgent extends baseAgent &#123;</span><br><span class="line">            function PrintPage() &#123;</span><br><span class="line">                return &apos;IE&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 用于客户端不是IE时调用的类（环境角色）</span><br><span class="line">class otherAgent extends baseAgent &#123;</span><br><span class="line">            function PrintPage() &#123;</span><br><span class="line">                return &apos;not IE&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 具体策略角色</span><br><span class="line">class Browser &#123;</span><br><span class="line">            public function call($object) &#123;</span><br><span class="line">                return $object-&gt;PrintPage();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$bro = new Browser();</span><br><span class="line">echo $bro-&gt;call(new ieAgent());</span><br></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。</p><p>使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    // 简单工厂模式（静态工厂方法模式）</span><br><span class="line">    // Interface people 人类</span><br><span class="line">    interface people &#123;</span><br><span class="line">        public function say();</span><br><span class="line">    &#125;</span><br><span class="line">    // Class man 继承people的男人类</span><br><span class="line">    class man implements people</span><br><span class="line">    &#123;</span><br><span class="line">        // 具体实现people的say方法</span><br><span class="line">        public function say()</span><br><span class="line">        &#123;</span><br><span class="line">            echo &apos;我是男人&lt;br&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Class women 继承people的女人类</span><br><span class="line">    class women implements people</span><br><span class="line">    &#123;</span><br><span class="line">        // 具体实现people的say方法</span><br><span class="line">        public function say()</span><br><span class="line">        &#123;</span><br><span class="line">            echo &apos;我是女人&lt;br&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Class SimpleFactory 工厂类</span><br><span class="line">    class SimpleFactory &#123;</span><br><span class="line">        // 简单工厂里的静态方法-用于创建男人对象</span><br><span class="line">        static function createMan()</span><br><span class="line">        &#123;</span><br><span class="line">            return new man();</span><br><span class="line">        &#125;</span><br><span class="line">        // 简单工厂里的静态方法-用于创建女人对象</span><br><span class="line">        static function createWomen()</span><br><span class="line">        &#123;</span><br><span class="line">            return new women();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 具体调用</span><br><span class="line">    $man = SimpleFactoty::createMan();</span><br><span class="line">    $man-&gt;say();</span><br><span class="line">    $woman = SimpleFactoty::createWomen();</span><br><span class="line">    $woman-&gt;say();</span><br></pre></td></tr></table></figure><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。</p><p>单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。</p><p>单例模式有以下3个特点：</p><ol><li>只能有一个实例</li><li>必须自行创建这个实例</li><li>必须给其他对象提供这一实例</li></ol><p>那么为什么要使用PHP单例模式？</p><p>PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Single &#123;</span><br><span class="line">    private $name;//声明一个私有的实例变量</span><br><span class="line">    private function __construct()&#123;</span><br><span class="line">    //声明私有构造方法为了防止外部代码使用new来创建对象。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static public $instance;//声明一个静态变量（保存在类中唯一的一个实例）</span><br><span class="line">    static public function getinstance()&#123;</span><br><span class="line">    //声明一个getinstance()静态方法，用于检测是否有实例对象</span><br><span class="line">        if(!self::$instance) &#123;</span><br><span class="line">            self::$instance = new self();</span><br><span class="line">        &#125; </span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function setname($n)&#123; $this-&gt;name = $n; &#125;</span><br><span class="line">    public function getname()&#123; return $this-&gt;name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$oa = Single::getinstance();</span><br><span class="line">$ob = Single::getinstance();</span><br><span class="line">$oa-&gt;setname(&apos;hello world&apos;);</span><br><span class="line">$ob-&gt;setname(&apos;good morning&apos;);</span><br><span class="line">echo $oa-&gt;getname();//good morning</span><br><span class="line">echo $ob-&gt;getname();//good morning</span><br></pre></td></tr></table></figure><h4 id="注册模式"><a href="#注册模式" class="headerlink" title="注册模式"></a>注册模式</h4><p>注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Register &#123;</span><br><span class="line">    protected static $objects;</span><br><span class="line">    //将对象注册到全局的树上</span><br><span class="line">    function set($alias, $object) &#123;</span><br><span class="line">        self::$objects[$alias]=$object;//将对象放到树上</span><br><span class="line">    &#125;</span><br><span class="line">    static function get($name) &#123;</span><br><span class="line">        return self::$objects[$name];//获取某个注册到树上的对象</span><br><span class="line">    &#125;</span><br><span class="line">    function _unset($alias) &#123;</span><br><span class="line">        unset(self::$objects[$alias]);//移除某个注册到树上的对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>将各种截然不同的函数接口封装成统一的API。</p><p>PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 </p><p>首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">接口 IDatabase</span><br><span class="line">&lt;?php</span><br><span class="line">    namespace IMooc;</span><br><span class="line">    interface IDatabase &#123;</span><br><span class="line">        function connect($host, $user, $passwd, $dbname);</span><br><span class="line">        function query($sql);</span><br><span class="line">        function close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MySQL</span><br><span class="line">&lt;?php</span><br><span class="line">    namespace IMooc\Database;</span><br><span class="line">    use IMooc\IDatabase;</span><br><span class="line">    class MySql implements IDatabase &#123;</span><br><span class="line">        protected $conn;</span><br><span class="line">        function connect($host, $user, $passwd, $dbname) &#123;</span><br><span class="line">            $conn = mysql_connect($host, $user, $passwd);</span><br><span class="line">            mysql_select_db($dbname);</span><br><span class="line">            $this-&gt;conn = $conn;</span><br><span class="line">        &#125;</span><br><span class="line">        function query($sql) &#123;</span><br><span class="line">            $res = mysql_query($sql, $this-&gt;conn);</span><br><span class="line">            return $res;</span><br><span class="line">        &#125;</span><br><span class="line">        function close() &#123;</span><br><span class="line">            mysql_close($this-&gt;conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MySQLi</span><br><span class="line">&lt;?php</span><br><span class="line">    namespace IMooc\Database;</span><br><span class="line">    use IMooc\IDatabase;</span><br><span class="line">    class MySQLi implements IDatabase&#123;</span><br><span class="line">        protected $conn;</span><br><span class="line">        function connect($host, $user, $passwd, $dbname)&#123;</span><br><span class="line">            $conn = mysqli_connect($host, $user, $passwd, $dbname);</span><br><span class="line">            $this-&gt;conn = $conn;</span><br><span class="line">        &#125;</span><br><span class="line">        function query($sql)&#123;</span><br><span class="line">            return mysqli_query($this-&gt;conn, $sql);</span><br><span class="line">        &#125;</span><br><span class="line">        function close()&#123;</span><br><span class="line">            mysqli_close($this-&gt;conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ol><li>观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。  </li><li>场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 </li><li>观察者模式实现了低耦合，非侵入式的通知与更新机制。 </li></ol><p>定义一个事件触发抽象类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EventGenerator.php</span><br><span class="line">&lt;?php</span><br><span class="line">    abstract class EventGenerator&#123;</span><br><span class="line">        private $observers = array();</span><br><span class="line">        function addObserver(Observer $observer)&#123;</span><br><span class="line">            $this-&gt;observers[]=$observer;</span><br><span class="line">        &#125;</span><br><span class="line">        function notify()&#123;</span><br><span class="line">            foreach ($this-&gt;observers as $observer)&#123;</span><br><span class="line">                $observer-&gt;update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>定义一个观察者接口 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observer.php</span><br><span class="line">&lt;?php</span><br><span class="line">//一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件</span><br><span class="line">interface Observer &#123;</span><br><span class="line">            function update(); // 这里就是在事件发生后要执行的逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Event extends EventGenerator&#123;</span><br><span class="line">    function triger()&#123;</span><br><span class="line">        echo &quot;Event&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Observer1 implements Observer&#123;</span><br><span class="line">    function update()&#123;</span><br><span class="line">        echo &quot;逻辑1 &lt;br/&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Observer2 implements Observer&#123;</span><br><span class="line">    function update()&#123;</span><br><span class="line">        echo &quot;逻辑2 &lt;br/&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$event = new Event();</span><br><span class="line">$event-&gt;addObserver(new Observer1());</span><br><span class="line">$event-&gt;addObserver(new Observer2());</span><br><span class="line">$event-&gt;triger();</span><br><span class="line">$event-&gt;notify();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fmt格式 “占位符”</title>
      <link href="/2019/07/08/go-fmt/"/>
      <url>/2019/07/08/go-fmt/</url>
      
        <content type="html"><![CDATA[<p>golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义示例类型和变量</span><br><span class="line">type Human struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people = Human&#123;Name: &quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>普通占位符</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%v</td><td>相应值的默认格式</td><td>Printf(“%v”, people)</td><td>{zhangsan}</td></tr><tr><td>%+v</td><td>打印结构体时，会添加字段名</td><td>Printf(“%+v”, people)</td><td>{Name:zhangsan}</td></tr><tr><td>%#v</td><td>相应值的Go语法表示</td><td>Printf(“#v”, people)</td><td>main.Human{Name:”zhangsan”}</td></tr><tr><td>%T</td><td>相应值的类型的Go语法表示</td><td>Printf(“%T”, people)</td><td>main.Human</td></tr><tr><td>%%</td><td>字面上的百分号，并非值的占位符</td><td>Printf(“%%”)</td><td>%</td></tr></tbody></table><a id="more"></a><ul><li>布尔占位符</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%t</td><td>true 或 false</td><td>Printf(“%t”, true)</td><td>true</td></tr></tbody></table><ul><li>整数占位符</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%b</td><td>二进制表示</td><td>Printf(“%b”, 5)</td><td>101</td></tr><tr><td>%c</td><td>相应Unicode码点所表示的字符</td><td>Printf(“%c”, 0x4E2D)</td><td>中</td></tr><tr><td>%d</td><td>十进制表示</td><td>Printf(“%d”, 0x12)</td><td>18</td></tr><tr><td>%o</td><td>八进制表示</td><td>Printf(“%d”, 10)</td><td>12</td></tr><tr><td>%q</td><td>单引号围绕的字符字面值，由Go语法安全地转义</td><td>Printf(“%q”, 0x4E2D)</td><td>‘中’</td></tr><tr><td>%x</td><td>十六进制表示，字母形式为小写 a-f</td><td>Printf(“%x”, 13)</td><td>d</td></tr><tr><td>%X</td><td>十六进制表示，字母形式为大写 A-F</td><td>Printf(“%x”, 13)</td><td>D</td></tr><tr><td>%U</td><td>Unicode格式：U+1234，等同于 “U+%04X”</td><td>Printf(“%U”, 0x4E2D)</td><td>U+4E2D</td></tr></tbody></table><ul><li>浮点数和复数的组成部分（实部和虚部）</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%e</td><td>科学计数法，例如 -1234.456e+78</td><td>Printf(“%e”, 10.2)</td><td>1.020000e+01</td></tr><tr><td>%E</td><td>科学计数法，例如 -1234.456E+78</td><td>Printf(“%e”, 10.2)</td><td>1.020000E+01</td></tr><tr><td>%f</td><td>有小数点而无指数，例如 123.456</td><td>Printf(“%f”, 10.2)</td><td>10.200000</td></tr><tr><td>%g</td><td>根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td><td>Printf(“%g”, 10.20)</td><td>10.2</td></tr><tr><td>%G</td><td>根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td><td>Printf(“%G”, 10.20+2i)</td><td>(10.2+2i)</td></tr></tbody></table><ul><li>字符串与字节切片</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%s</td><td>输出字符串表示（string类型或[]byte)</td><td>Printf(“%s”, []byte(“Go语言”))</td><td>Go语言</td></tr><tr><td>%q</td><td>双引号围绕的字符串，由Go语法安全地转义</td><td>Printf(“%q”, “Go语言”)</td><td>“Go语言”</td></tr><tr><td>%x</td><td>十六进制，小写字母，每字节两个字符</td><td>Printf(“%x”, “golang”)</td><td>676f6c616e67</td></tr><tr><td>%X</td><td>十六进制，大写字母，每字节两个字符</td><td>Printf(“%X”, “golang”)</td><td>676F6C616E67</td></tr></tbody></table><ul><li>指针</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%p</td><td>十六进制表示，前缀 0x</td><td>Printf(“%p”, &amp;people)</td><td>0x4f57f0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 占位符 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
