<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>npm  --save-dev &amp; --save 的区别</title>
      <link href="/2020/07/07/npm-save-dev/"/>
      <url>/2020/07/07/npm-save-dev/</url>
      
        <content type="html"><![CDATA[<p><code>npm install</code> 在安装 npm 包时，有两种命令参数可以把它们的信息写入 package.json 文件，<br>一个是<code>npm install--save</code>，<br>另一个是 <code>npm install –save-dev</code>，<br>他们表面上的区别是：</p><ul><li><code>--save</code> 会把依赖包名称添加到 package.json 文件 dependencies 键下，</li><li><code>--save-dev</code> 则添加到 package.json 文件 devDependencies 键下，</li></ul><a id="more"></a><p>譬如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;vue&quot;: &quot;^2.2.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;devDependencies&quot;: &#123;</span><br><span class="line">        &quot;babel-core&quot;: &quot;^6.0.0&quot;,</span><br><span class="line">        &quot;babel-loader&quot;: &quot;^6.0.0&quot;,</span><br><span class="line">        &quot;babel-preset-latest&quot;: &quot;^6.0.0&quot;,</span><br><span class="line">        &quot;cross-env&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">        &quot;css-loader&quot;: &quot;^0.25.0&quot;,</span><br><span class="line">        &quot;file-loader&quot;: &quot;^0.9.0&quot;,</span><br><span class="line">        &quot;vue-loader&quot;: &quot;^11.1.4&quot;,</span><br><span class="line">        &quot;vue-template-compiler&quot;: &quot;^2.2.1&quot;,</span><br><span class="line">        &quot;webpack&quot;: &quot;^2.2.0&quot;,</span><br><span class="line">        &quot;webpack-dev-server&quot;: &quot;^2.2.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这只是它们的表面区别。<br>它们真正的区别是:<br>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖。即:</p><ul><li>devDependencies 下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包<code>gulp-uglify</code> 时，我们采用的是 <code>npm install –save-dev gulp-uglify</code>命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。</li><li>dependencies 下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</li></ul><p>另外需要补充的是：<br>正常使用<code>npm install</code>时，会下载<code>dependencies</code>和<code>devDependencies</code>中的模块，当使用<code>npm install –production</code>或者注明<code>NODE_ENV</code>变量值为<code>production</code>时，只会下载<code>dependencies</code>中的模块。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.use 和 Vue.prototype.$xx 的区别</title>
      <link href="/2020/07/07/vue-use-and-prototype/"/>
      <url>/2020/07/07/vue-use-and-prototype/</url>
      
        <content type="html"><![CDATA[<h4 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h4><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>首先引入api</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'./api/index'</span></span><br><span class="line">Vue.use(api);</span><br></pre></td></tr></table></figure><p>再看下api/index.js中的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'../utils/request'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    install(Vue, options) &#123;</span><br><span class="line">        Vue.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">url, params</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> request(&#123;</span><br><span class="line">                url: url,</span><br><span class="line">                method: <span class="string">'get'</span>,</span><br><span class="line">                params: params</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Vue.prototype.post = <span class="function"><span class="keyword">function</span>(<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> request(&#123;</span><br><span class="line">                url: url,</span><br><span class="line">                method: <span class="string">'post'</span>,</span><br><span class="line">                data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现其中有一个<code>install</code>函数，它是本文的主角，<code>Vue.use</code>就是要运行这个<code>install</code>函数。</p><a id="more"></a><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>Vue的插件是一个对象，就像<code>Element</code></li><li>插件对象必须有<code>install</code></li><li><code>install</code>字段是个函数</li><li>初始化插件对象需要<code>Vue.use()</code></li><li><code>Vue.use()</code>调用必须在<code>new Vue</code>之前</li><li>同一个插件多次使用<code>Vue.use()</code>也只会被运行一次</li></ol><h4 id="Vue-prototype-xx"><a href="#Vue-prototype-xx" class="headerlink" title="Vue.prototype.$xx"></a>Vue.prototype.$xx</h4><p>本质其实就是js中的函数原型的特性：函数原型上的属性/方法, 在函数实例化后, 可以在任意实例上读取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * moment 时间组件</span></span><br><span class="line"><span class="comment"> * 使用 this.$moment() 调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span></span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>);</span><br><span class="line">Vue.prototype.$moment = moment;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Router 模式及其部署</title>
      <link href="/2020/07/07/vue-router/"/>
      <url>/2020/07/07/vue-router/</url>
      
        <content type="html"><![CDATA[<p><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">Vue Router</a>是Vue.js官方的路由管理器，使用配置很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  router/index.js</span></span><br><span class="line"><span class="comment">// 此处省略一堆 import</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    base:<span class="string">'/'</span>,</span><br><span class="line">    mode:<span class="string">'history'</span>, <span class="comment">//default--&gt;hash</span></span><br><span class="line">    routes:[],</span><br><span class="line">    scrollBehavior:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="base"><a href="#base" class="headerlink" title="base"></a>base</h4><p>浏览器url的前缀，默认为<code>&#39;/&#39;</code>，如果设置为<code>&#39;/admin/&#39;</code>,则运行项目，浏览器url都是<code>&#39;/admin/...&#39;</code>,不会对静态文件的引用产生影响，一般写网站都会有域名，都可以把域名指向某个服务器目录，所以默认<code>&#39;/&#39;</code>即可。</p><p>比如打包后的文件在<code>111.22.33.44/admin</code>，是在<strong>项目部署的子级目录</strong>，这个时候路由的配置匹配浏览器路径的时候，会从这个<code>/admin</code>开始算，如果base还是默认的<code>/</code>，那么路由配置的routes的<code>path</code>就要全部加上<code>/admin/</code>前缀，并且<code>router-link</code>和<code>push</code>方法也要加上这个<code>/admin</code>，很麻烦，但是只要设置<code>base</code>为<code>&#39;/admin/&#39;</code>，路由内部配置以及所有相关的方法都可以忽视服务器ip下的目录名。<br>这种情况，同样也要<strong>配置<code>webpack</code>的<code>publicPath</code>也为<code>/admin/</code></strong>，这个下面细说。</p><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><ul><li><code>hash</code>: 使用URL的hash值来作为路由。支持所有浏览器。浏览器会有‘#’符号，参考锚点效果，缺点很丑，但是兼容性棒棒。</li><li><code>history</code>: 以来HTML5 History API 和服务器配置。参考官网中HTML5 History模式。去除‘#’符号，让url变好看，下面会讲服务端配置。</li><li><code>abstract</code>： 支持所有javascript运行模式。如果发现没有浏览器的API，路由会自动强制进入这个模式，例如<code>weex</code>。</li></ul><h4 id="history模式nginx配置"><a href="#history模式nginx配置" class="headerlink" title="history模式nginx配置"></a>history模式nginx配置</h4><p>hisroty模式下需要配置的原因：<br>　　当你进入某个路由之后，<strong>再次刷新页面时（或者是浏览器直接输入某个路由路径时）</strong>，浏览器就会重新dns解析，tcp协议，这个时候会根据浏览器的url去服务器找对应资源，当然我们<code>vue-router</code>是为单页面服务的，对应的url在服务端是肯定没有静态资源的，就会出现404；<br>　　当配置了以下url重写语句，<strong>注意是重写，不是重定向</strong>，<strong>不改变url的情况重写浏览器内容</strong>，重写到<code>index.html</code>，因为这个<code>index.html</code>使我们项目的入口，<code>index.html</code>里面会读取当时打包好的<code>app.js</code>，就可以读取到路由配置，以实现我们浏览器的url对应的路由页面。</p><blockquote><p>hash模式不需要配置，因为浏览器会忽略 # 和 ？后面的参数</p></blockquote><ol><li><p><strong>打包文件在根目录时</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  test.com;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    root  /var/www/dist;  <span class="comment">## 前端文件路径</span></span><br><span class="line">    index  index.html;  <span class="comment">## hash模式只配置访问html就可以了</span></span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;  <span class="comment">## history模式下</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>打包文件在非根目录</strong>，即<strong>部署到子级目录</strong>时，还需要修改<code>webpack</code>的<code>publicPath</code>，生成一个子级目录下的绝对访问路劲，同时修改nginx相应的<code>.conf</code>文件：</p></li></ol><p>webpack：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publicPath: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'/admin/'</span> : <span class="string">'/'</span>,</span><br></pre></td></tr></table></figure><p>nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  test.com;</span><br><span class="line"></span><br><span class="line">  location /admin &#123;     <span class="comment">## 子级目录，打包的代码放在子级目录</span></span><br><span class="line">    <span class="built_in">alias</span>  /var/www/dist/admin;</span><br><span class="line">    index  index.html;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /admin/index.html; </span><br><span class="line">    expires 30d;  <span class="comment">##缓存30天，这个缓存是指你浏览器（客户端，非nginx）缓存，一般情况下，Ctrl+R强制刷新就会去掉缓存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>try_files指令：<br>语法：try_files file … uri 或 try_files file … = code<br>默认值：无<br>作用域：server location<br>其作用是按顺序检查文件是否存在，返回第一个找到的文件或文件夹(结尾加斜线表示为文件夹)，如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。<br>需要注意的是，只有最后一个参数可以引起一个内部重定向，之前的参数只设置内部URI的指向。最后一个参数是回退URI且必须存在，否则会出现内部500错误。命名的location也可以使用在最后一个参数中。<br>与rewrite指令不同，如果回退URI不是命名的location，那么$args不会自动保留，如果你想保留$args，则必须明确声明。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue事件总线（EventBus）</title>
      <link href="/2020/07/07/vue-event-bus/"/>
      <url>/2020/07/07/vue-event-bus/</url>
      
        <content type="html"><![CDATA[<p>如果两个页面没有任何引入和被引入关系，该如何通信？<br>如果咱们的应用程序不需要类似Vuex这样的库来处理组件之间的数据通信，就可以考虑Vue中的<strong>事件总线</strong>，即<strong>EventBus</strong>来通信。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>EventBus</strong> 又称为事件总线。在Vue中可以使用 EventBus 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的“灾难”，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。</p><a id="more"></a><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>首先需要创建事件总线并将其导出，以便其它模块可以使用或者监听它。我们可以通过两种方式来处理。</p><p>先来看第一种，新创建一个 <code>.js</code> 文件，比如 <code>event-bus.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p>实质上EventBus是一个不具备 DOM 的组件，它具有的仅仅只是它实例方法而已，因此它非常的轻便。</p><p>另外一种方式，可以直接在项目中的 <code>main.js</code> 初始化 <code>EventBus</code> :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p>注意，这种方式初始化的EventBus是一个全局的事件总线。稍后再来聊一聊全局的事件总线。</p><p>现在我们已经创建了 EventBus ，接下来你需要做到的就是在你的组件中加载它，并且调用同一个方法，就如你在父子组件中互相传递消息一样。</p><h5 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h5><p>假设你有两个Vue页面需要通信： A 和 B ，A页面 在按钮上面绑定了点击事件，发送一则消息，想去通知 B页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- A.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"sendMsg()"</span>&gt;-&lt;/button&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt; </span></span><br><span class="line"><span class="regexp">import &#123; EventBus &#125; from "../</span>event-bus.js<span class="string">";</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    sendMsg() &#123;</span></span><br><span class="line"><span class="string">      EventBus.$emit("</span>aMsg<span class="string">", '来自A页面的消息');</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们需要在 B页面 中接收这则消息。</p><h5 id="接收事件"><a href="#接收事件" class="headerlink" title="接收事件"></a>接收事件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- B.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt; </span><br><span class="line"><span class="keyword">import</span> &#123; </span><br><span class="line">  EventBus </span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"../event-bus.js"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    EventBus.$on(<span class="string">"aMsg"</span>, (msg) =&gt; &#123;</span><br><span class="line">      <span class="comment">// A发送来的消息</span></span><br><span class="line">      <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>所以，发送和接收消息，主要用到两个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">EventBus.$emit(channel: string, callback(payload1,…))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息</span></span><br><span class="line">EventBus.$on(channel: string, callback(payload1,…))</span><br></pre></td></tr></table></figure><p>前面提到过，如果使用不善，EventBus会是一种灾难，到底是什么样的“灾难”了？<br>大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。还要就是如果业务有反复操作的页面，EventBus在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理EventBus在项目中的关系。<br>通常会用到，在vue页面销毁时，同时移除EventBus事件监听。</p><h5 id="移除时间监听者"><a href="#移除时间监听者" class="headerlink" title="移除时间监听者"></a>移除时间监听者</h5><p>如果想移除事件的监听，可以像下面这样操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; </span><br><span class="line">  eventBus </span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./event-bus.js'</span></span><br><span class="line">EventBus.$off(<span class="string">'aMsg'</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>你也可以使用 <code>EventBus.$off(&#39;aMsg&#39;)</code> 来移除应用内所有对此某个事件的监听。或者直接调用 <code>EventBus.$off()</code> 来移除所有事件频道，不需要添加任何参数 。</p><p>上面的示例中我们也看到了，每次使用 EventBus 时都需要在各组件中引入 <code>event-bus.js</code> 。<br>事实上，我们还可以通过别的方式，让事情变得简单一些。那就是创建一个<strong>全局</strong>的 <code>EventBus</code> 。</p><h4 id="全局EventBus"><a href="#全局EventBus" class="headerlink" title="全局EventBus"></a>全局EventBus</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventBus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(Vue.prototype, &#123;</span><br><span class="line">  $bus: &#123;</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> EventBus</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个特定的总线中使用两个方法$on和$emit。一个用于创建发出的事件，它就是$emit；另一个用于订阅$on：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventBus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(<span class="string">'nameOfEvent'</span>, &#123; ... pass some event data ...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$bus.$on(<span class="string">'nameOfEvent'</span>,($event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们可以在某个Vue页面使用<code>this.$bus.$emit(&quot;sendMsg&quot;, &#39;我是web秀&#39;);</code>，另一个Vue页面使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$bus.$on(<span class="string">'sendMsg'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 我是web秀</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同时也可以使用<code>this.$bus.$off(&#39;sendMsg&#39;)</code>来移除事件监听。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解async/await</title>
      <link href="/2020/07/07/vue-async-await/"/>
      <url>/2020/07/07/vue-async-await/</url>
      
        <content type="html"><![CDATA[<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在<code>async/await</code>之前，我们有三种方式写异步代码：</p><ul><li><p>嵌套回调</p></li><li><p>以Promise为主的链式回调</p></li><li><p>使用Generators</p></li></ul><p>但是，这三种写起来都不够优雅，ES7做了优化改进，async/await应运而生。<br>async/await相比较Promise 对象，then 函数的嵌套，与 Generator 执行的繁琐（需要借助co才能自动执行，否则得手动调用next() ）。</p><p><code>async/await</code> 可以<u><strong>让你轻松写出同步风格的代码同时又拥有异步机制</strong></u>，更加简洁，逻辑更加清晰。</p><a id="more"></a><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><p><code>async/await</code>更加语义化，<code>async</code> 是“异步”的简写，<code>async function</code> 用于申明一个 function 是异步的； <code>await</code>，可以认为是<code>async wait</code>的简写， 用于等待一个异步方法执行完成；</p></li><li><p><code>async/await</code>是一个用同步思维解决异步问题的方案（等结果出来之后，代码才会继续往下执行）</p></li><li><p>可以通过多层 <code>async function</code> 的同步写法代替传统的<code>callback</code>嵌套。</p></li></ol><h4 id="async-function语法"><a href="#async-function语法" class="headerlink" title="async function语法"></a>async function语法</h4><ul><li><p>自动将常规函数转换成Promise，返回值也是一个<strong>Promise对象</strong>；</p></li><li><p>只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数；</p></li><li><p>异步函数内部可以使用await。</p></li></ul><h4 id="await语法"><a href="#await语法" class="headerlink" title="await语法"></a>await语法</h4><ul><li><p>await 放置在Promise调用之前，<strong>await 强制后面点代码等待</strong>，直到Promise对象resolve，<strong>得到resolve的值作为await表达式的运算结果</strong>；</p></li><li><p><strong>await只能在async函数内部使用</strong>，用在普通函数里就会报错。</p></li></ul><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><blockquote><p>async和await要搭配Promise使用, 它进一步极大的改进了Promise的写法。</p></blockquote><p>首先看一个简单场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设有4个异步方法要按顺序调用</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    ajaxA(<span class="string">"xxxx"</span>, ()=&gt; &#123; resolve(); &#125;)    </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        ajaxB(<span class="string">"xxxx"</span>, ()=&gt; &#123; resolve(); &#125;)    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        ajaxC(<span class="string">"xxxx"</span>, ()=&gt; &#123; resolve(); &#125;)    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ajaxD(<span class="string">"xxxx"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>语法上不够简洁, 我们可以稍微改造一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将请求改造成一个通用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(....); <span class="comment">//使用Promise执行请求,并返回Promise对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//于是我们就可以来发送请求了</span></span><br><span class="line">request(<span class="string">"http://xxxxxx"</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//处理data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们再来重新改造开头的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">request(<span class="string">"ajaxA"</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">//处理data</span></span><br><span class="line">   <span class="keyword">return</span> request(<span class="string">"ajaxB"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">//处理data</span></span><br><span class="line">   <span class="keyword">return</span> request(<span class="string">"ajaxC"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">//处理data</span></span><br><span class="line">   <span class="keyword">return</span> request(<span class="string">"ajaxD"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>比起之前有了不小的进步, 但是看上去依然不够简洁</p><p><u><strong>如果我能像使用同步代码那样, 使用Promise就好了</strong></u></p><p>于是, <code>async\await</code>出现了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> request(<span class="string">"ajaxA"</span>);</span><br><span class="line">    <span class="keyword">await</span> request(<span class="string">"ajaxB"</span>);</span><br><span class="line">    <span class="keyword">await</span> request(<span class="string">"ajaxC"</span>);</span><br><span class="line">    <span class="keyword">await</span> request(<span class="string">"ajaxD"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span>关键字使用的要求非常简单, 后面调用的函数要返回一个<span class="built_in">Promise</span>对象；</span><br><span class="line">load()这个函数已经不再是普通函数, 它出现了<span class="keyword">await</span>这样<span class="string">"阻塞式"</span>的操作；</span><br><span class="line">因此<span class="keyword">async</span>关键字在这是不能省略的。</span><br></pre></td></tr></table></figure><p>到这你已经学会了<code>async</code>和<code>await</code>基本使用方式。</p><p>下面来简单解释一下它的工作流程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wait这个单词是等待的意思</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> request(<span class="string">"ajaxA"</span>);  <span class="comment">//那么这里就是在等待ajaxA请求的完成</span></span><br><span class="line">    <span class="keyword">await</span> request(<span class="string">"ajaxB"</span>);</span><br><span class="line">    <span class="keyword">await</span> request(<span class="string">"ajaxC"</span>);</span><br><span class="line">    <span class="keyword">await</span> request(<span class="string">"ajaxD"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果后一个请求需要前一个请求的结果怎么办呢?</p><p>传统的写法是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">request(<span class="string">"ajaxA"</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">data1</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> request(<span class="string">"ajaxB"</span>, data1);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data2</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> request(<span class="string">"ajaxC"</span>, data2)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data3</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> request(<span class="string">"ajaxD"</span>, data3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而使用<code>async/await</code>是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data1 = <span class="keyword">await</span> request(<span class="string">"ajaxA"</span>);  </span><br><span class="line">    <span class="keyword">let</span> data2 = <span class="keyword">await</span> request(<span class="string">"ajaxB"</span>, data1);</span><br><span class="line">    <span class="keyword">let</span> data3 = <span class="keyword">await</span> request(<span class="string">"ajaxC"</span>, data2);</span><br><span class="line">    <span class="keyword">let</span> data4 = <span class="keyword">await</span> request(<span class="string">"ajaxD"</span>, data3);</span><br><span class="line">    <span class="comment">//await不仅等待Promise完成, 而且还拿到了resolve方法的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意当一个函数被async修饰以后, 它的返回值会被自动处理成Promise对象</p></blockquote><p>关于<strong>异常处理</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//请求失败后的处理, 可以使用try-catch来进行</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data1 = <span class="keyword">await</span> request(<span class="string">"ajaxA"</span>);  </span><br><span class="line">        <span class="keyword">let</span> data2 = <span class="keyword">await</span> request(<span class="string">"ajaxB"</span>, data1);</span><br><span class="line">        <span class="keyword">let</span> data3 = <span class="keyword">await</span> request(<span class="string">"ajaxC"</span>, data2);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nextTick使用</title>
      <link href="/2020/07/07/vue-nexttick/"/>
      <url>/2020/07/07/vue-nexttick/</url>
      
        <content type="html"><![CDATA[<p><code>Vue.nextTick( [callback, context] )</code>文档中的解释：</p><ul><li><p>参数：</p><ul><li><code>{Function} [callback]</code></li><li><code>{Object} [context]</code></li></ul></li><li><p>用法：<br>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">'Hello'</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">// 并不会得到'Hello'</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">  <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">//可以得到'Hello'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h4 id="异步说明"><a href="#异步说明" class="headerlink" title="异步说明"></a>异步说明</h4><blockquote><p>Vue 实现响应式并<strong>不是数据发生变化之后 DOM 立即变化</strong>，而是按一定的策略进行 DOM 的更新。<br>Vue是异步执行DOM更新的。</p></blockquote><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p>在Vue生命周期的<code>created()</code>钩子函数进行的DOM操作一定要放在<code>Vue.nextTick()</code>的回调函数中<br>在<code>created()</code>钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进<code>Vue.nextTick()</code>的回调函数中。<br>与之对应的就是<code>mounted()</code>钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。</p></li><li><p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进<code>Vue.nextTick()</code>的回调函数中。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Promise</title>
      <link href="/2020/07/07/vue-promise/"/>
      <url>/2020/07/07/vue-promise/</url>
      
        <content type="html"><![CDATA[<h4 id="异步定义"><a href="#异步定义" class="headerlink" title="异步定义"></a>异步定义</h4><blockquote><p>当一个操作开始执行后，主程序无需等待它的完成，可以继续向下执行。此时该操作可以跟主程序同时（并发）执行。这种操作我们就称之为异步操作。 通常当操作完成时，会执行一个我们事先设定好的回调函数来做后续的处理。</p></blockquote><p>我们常见的异步操作例如：</p><ul><li>添加定时器 setTimeout/setInterval</li><li>执行某个动画 animate</li><li>发起网络请求 request</li></ul><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果有很多异步操作需要顺序执行，就会产生所谓的“回调地狱”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajaxA(<span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">    ajaxB(<span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">        ajaxC(<span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">            ajaxD(<span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">                ......   </span><br><span class="line">            &#125;); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种代码不管是写起来还是读起来都比较烦人。</p><p>我们来看下经过Promise改造后的样子（伪代码）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(ajaxA)</span><br><span class="line">        .then(ajaxB)</span><br><span class="line">        .then(ajaxC)</span><br><span class="line">        .then(ajaxD);</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>示例感受下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">    ajax(<span class="string">"/pay/post"</span>, data =&gt; resolve() );</span><br><span class="line">&#125;).then(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">    ajax(<span class="string">"/order/fix"</span>, data =&gt; &#123;</span><br><span class="line">        <span class="comment">//处理数据   </span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码使用了<code>ES6</code>的箭头函数,虽然大大简化了代码的写法，但对于初级程序猿来讲极不友好；</p><p>我们把代码还原成<code>ES5</code>的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    ajax(<span class="string">"/pay/post"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ajax(<span class="string">"/order/fix"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol><li>Promise是怎么知道第一个函数什么时候结束的？ 然后再开始执行下一个？<blockquote><p>Promise并没有那么神奇，它并不能知道我们的函数什么时候结束，<br>在ajax请求结束执行回调的时候，<br>我们调用了一个<strong>resolve()函数</strong>，这句代码非常的关键.<br>这其实就是在通知Promise，当前这个函数结束啦，<br>你可以开始执行下一个。 这时Promise就会去执行then里面的函数了。</p></blockquote></li></ol><blockquote><p>如果我不调用<code>resolve()</code>这个方法，Promise就不知道这个函数有没有结束，那么then里面的函数就不会执行，也就是说我的第二个请求就永远不会发送了</p></blockquote><ol start="2"><li><p>Promise基本结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(函数<span class="number">1</span>).then(函数<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">我们把函数<span class="number">1</span>和函数<span class="number">2</span>都以参数形式传给了一个<span class="built_in">Promise</span>对象，</span><br><span class="line">所以接下来函数<span class="number">1</span>和<span class="number">2</span>都会由这个<span class="built_in">Promise</span>对象控制， </span><br><span class="line">简单的说，函数<span class="number">1</span>和函数<span class="number">2</span>都会由<span class="built_in">Promise</span>对象来执行。 </span><br><span class="line">所以在函数<span class="number">1</span>执行时，参数也当然是由<span class="built_in">Promise</span>对象传递进去的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//resolve是Promise对象在调用函数时传入的参数</span></span><br><span class="line">&#125;).then(函数<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>resolve函数作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">以参数传进来的resolve函数， 就好像一个对讲机，</span><br><span class="line">当我们的异步任务要结束时，通过对讲机 来通知<span class="built_in">Promise</span>对象。</span><br><span class="line">也就是调用resolve方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    ajax(<span class="string">"/pay/post"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当请求结束时，通过调用resolve方法，通知Promise对象，该任务已完成</span></span><br><span class="line">        resolve(); <span class="comment">//收到通知后，Promise会立刻开始函数2的执行</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(函数<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果我有ajaxA、ajaxB、ajaxC三个异步任务，想按照先A后B再C的顺序执行，像这样写行吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    ajax(<span class="string">"/AAA"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(); <span class="comment">//通知Promise该任务结束</span></span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    ajax(<span class="string">"/BBB"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve();<span class="comment">//通知Promise该任务结束</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ajax(<span class="string">"/CCC"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//.... &#125;)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>上面的这种写法是不对的。<br>Promise的中文含义是“承诺”，<br>则意味着，每一个Pormise对象，代表一次承诺<br>而每一次承诺，只能保证一个任务的顺序，也就是说<br><code>new Promise(A).then(B);</code> 这句话表示， 只能保证A和B的顺序</p><p>一旦A执行完，B开始后，这次承诺也就兑现了，Promise对象也就失效了<br>那如果还有C呢？ 我们就必须在函数B中，<br>重新创建新的Promise对象，来完成下一个承诺，具体的写法就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(函数<span class="number">1</span>(resolve)&#123;</span><br><span class="line">    ajaxA(<span class="string">"xxxx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve();<span class="comment">//通知Promise该任务结束</span></span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;).then(函数<span class="number">2</span>()&#123;</span><br><span class="line">    <span class="comment">//在函数2开始运行后，第一次创建的Promise对象完成使命，已经不能再继续工作。</span></span><br><span class="line">    <span class="comment">//此时，我们创建并返回了新的Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        ajaxB(<span class="string">"xxxx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve();<span class="comment">//通知新的Promise对象该任务结束</span></span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(函数<span class="number">3</span>()&#123; <span class="comment">//尽管这里使用了链式调用，但负责执行函数3的，已经是新的Promise对象了</span></span><br><span class="line">    <span class="comment">// 如果，我们还有ajaxD需要顺序调用</span></span><br><span class="line">    <span class="comment">// 那就必须在这里重新new Promise()对象了</span></span><br><span class="line">    ajaxC(<span class="string">"xxx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="5"><li>其他功能<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如： 如果我有 A,B,C 三个异步任务，ABC同时开始执行</span><br><span class="line">当A,B,C三个任务全部都结束时，执任务D，</span><br><span class="line">传统方法实现起来就比较复杂，<span class="built_in">Promise</span>就非常简单，就像这样：</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([<span class="keyword">new</span> <span class="built_in">Promise</span>(A), <span class="keyword">new</span> <span class="built_in">Promise</span>(B), <span class="keyword">new</span> <span class="built_in">Promise</span>(C)])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    D();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">如果我希望A,B,C 其中任意一个任务完成，</span><br><span class="line">就马上开始任务D，该怎么做？</span><br><span class="line"><span class="built_in">Promise</span>.race([<span class="keyword">new</span> <span class="built_in">Promise</span>(A), <span class="keyword">new</span> <span class="built_in">Promise</span>(B), <span class="keyword">new</span> <span class="built_in">Promise</span>(C)])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   D();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-api </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx和php-fpm用户权限说明</title>
      <link href="/2020/06/28/nginx-php-fpm-authority/"/>
      <url>/2020/06/28/nginx-php-fpm-authority/</url>
      
        <content type="html"><![CDATA[<h4 id="Nginx权限"><a href="#Nginx权限" class="headerlink" title="Nginx权限"></a>Nginx权限</h4><p>我们知道，Nginx本身不能解析PHP的语法，所以Nginx对于静态文件(如HTML等)会直接解析返回结果，但是对于PHP的文件，Nginx会转交给PHP的解释器php-fpm进行处理，此时则需要php-fpm用户对文件具有有读权限或者读写权限。处理完后再返回响应给客户端浏览器。</p><p>因此，我们代码目录下需要统一Nginx和php的服务所需权限。</p><p>最好的办法就是统一归类到一个新的用户组里面，通过给该用户组分配Nginx和php运行必要的权限，来实现对web应用的权限目录管理。</p><p>通常情况下，许多团队都会把这个用户组取名www，由www用户来统一管理代码目录权限。</p><p>我们可以看到Nginx的配置文件nginix.conf里面划分的运行权限就是配置到了www用户下，因此Nginx的子进程也是由www用户执行，可以通过<code>ps aux | grep nginx</code>来查看</p><a id="more"></a><h4 id="php-fpm权限"><a href="#php-fpm权限" class="headerlink" title="php-fpm权限"></a>php-fpm权限</h4><p>同样的，php的运行方式也是由主进程root运行，在子进程池(pool)里面配置由www用户执行，具体配置在php根目录下的etc\php-fpm.conf下，添加两行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user = www</span><br><span class="line">group = www</span><br></pre></td></tr></table></figure><p>即可，同样用<code>ps aux | grep php</code>可以查看进程使用的用户身份</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> 一般情况下，nginx运行用户、php-fpm运行用户和web的根目录的所有者和所属组，应该保持一致。</p><ul><li>上传目录  644</li><li>runtime目录  744</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS 和 CSRF</title>
      <link href="/2020/06/28/xss-and-csrf/"/>
      <url>/2020/06/28/xss-and-csrf/</url>
      
        <content type="html"><![CDATA[<h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>跨站脚本攻击（Cross Site Scripting）本来的缩写为CSS，为了与层叠样式表（Cascading Style Sheets，CSS）的缩写进行区分，将跨站脚本攻击缩写为XSS。因此XSS是跨站脚本的意思。</p><p>XSS跨站脚本攻击（Cross Site Scripting），的本质是攻击者在web页面插入恶意的script代码（这个代码可以是JS脚本、CSS样式或者其他意料之外的代码），当用户浏览该页面之时，嵌入其中的script代码会被执行，从而达到恶意攻击用户的目的。比如读取cookie，session，tokens，或者网站其他敏感的网站信息，对用户进行钓鱼欺诈等。比较经典的事故有：</p><blockquote><p>2011年6月28日，新浪微博被XSS攻击，大量用户自动转发微博、私信。自动关注用户，大量用户被莫名其妙地控制。因为可以使用JS代码代替用户单击按钮发送请求，所以损坏非常大。</p></blockquote><a id="more"></a><h4 id="XSS攻击的危害"><a href="#XSS攻击的危害" class="headerlink" title="XSS攻击的危害"></a>XSS攻击的危害</h4><ul><li><p>通过 document.cookie 盗取 cookie中的信息</p></li><li><p>使用 js或 css破坏页面正常的结构与样式</p></li><li><p>流量劫持（通过访问某段具有 window.location.href 定位到其他页面）</p></li><li><p>dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。并且通过携带过程的 cookie信息可以使服务端返回400开头的状态码，从而拒绝合理的请求服务。</p></li><li><p>利用 iframe、frame、XMLHttpRequest或上述 Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作，并且攻击者还可以利用 iframe，frame进一步的进行 CSRF 攻击。</p></li><li><p>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力。</p></li></ul><h4 id="XSS攻击的类型"><a href="#XSS攻击的类型" class="headerlink" title="XSS攻击的类型"></a>XSS攻击的类型</h4><h5 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h5><p>反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索，跳转等。由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。比如下面的URL：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://x.x.x.x:8080/dosomething?message="&lt;script src="http://www.hacktest.com:8002/xss/hacker.js"&gt;&lt;/script&gt;"</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">http://localhost/test.php?param=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>POST的内容也可以触发反射型XSS，只不过它的触发条件比较苛刻（构建表单提交页面，并引导用户点击），所以非常少见。</p><p><strong>攻击步骤：</strong></p><p>1.攻击者构造出特殊的URL，其中包含恶意代码.<br>2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器.<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。</p><p><strong>防御：</strong></p><ol><li><p>对输入检查<br>对请求参数进行检查，一旦发现可疑的特殊字符就拒绝请求。需要注意的是用户可以绕过浏览器的检查，直接通过Postman等工具进行请求，所以这个检查最好前后端都做。</p></li><li><p>对输出进行转义再显示<br>通过上面的介绍可以看出，反射型XSS攻击要进行攻击的话需要在前端页面进行显示。所以在输出数据之前对潜在的威胁的字符进行编码、转义也是防御XSS攻击十分有效的措施。</p></li></ol><h5 id="存储型XSS攻击"><a href="#存储型XSS攻击" class="headerlink" title="存储型XSS攻击"></a>存储型XSS攻击</h5><p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务器端时，没有做好过滤;服务端在按受到数据时，在存储之前，没有做过滤;前端从服务器端请求到数据，没有过滤输出。</p><p>比较常见的场景是，黑客写下一篇包含有恶意JavaScript代码的博客文章，文章发表后，所有访问该博客的用户，都会在他们的浏览器中执行这段恶意js代码。</p><p><strong>攻击步骤：</strong></p><p>1.攻击者将恶意代码提交到目标网站的数据库中。<br>2.用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，凋用目标网站接口执行攻击者指定的操作.</p><p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖，商品评论，用户私信等。</p><p><strong>防御：</strong><br>预防存储型XSS攻击也是从输入和输出两个方面来考虑。</p><ul><li>服务器接收到数据，在存储到数据库之前，进行转义和过滤危险字符;</li><li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤;</li></ul><p>不论是反射型攻击还是存储型，攻击者总需要找到两个要点，即“输入点”与”输出点”，也只有这两者都满足，XSS攻击才会生效。“输入点”用于向 web页面注入所需的攻击代码，而“输出点”就是攻击代码被执行的地方。</p><h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><p>DOM型XSS攻击，实际上就是前端javascript代码不够严谨，把不可信的内容插入到了页面，在使用.innerHTML、.outerHTML、.appendChild、document.write()等API时要特别小心，不要把不可信的数据作为HTML插入到页面上，尽量使用.innerText、.textContent、.setAttribut()等.</p><p><strong>攻击步骤：</strong></p><p>1.攻击者构造出特殊数据，其中包含恶意代码。<br>2.用户浏览器执行了恶意代码<br>3.恶意窃取用户数据并发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作.</p><p>DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端javascript自身的安全漏洞.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>XSS类型</th><th>存储型</th><th>反射型</th><th>DOM型</th></tr></thead><tbody><tr><td>触发过程</td><td>1.黑客构造XSS脚本 2.正常用户访问携带XSS脚本的页面</td><td>正常用户访问携带XSS脚本的URL</td><td>正常用户访问携带XSS脚本的URL</td></tr><tr><td>数据存储</td><td>数据库</td><td>URL</td><td>URL</td></tr><tr><td>谁来输出</td><td>后端web应用程序</td><td>后端web应用程序</td><td>前端js</td></tr><tr><td>输出位置</td><td>HTTP响应中</td><td>HTTP响应中</td><td>动态构造的DOM节点</td></tr></tbody></table><h4 id="一些其他的防范策略"><a href="#一些其他的防范策略" class="headerlink" title="一些其他的防范策略"></a>一些其他的防范策略</h4><ul><li><p>HTTP-only Cookie:禁止JavaScript读取某些敏感Cookie，攻击者完成XSS注入后也无法窃取此Cookie属性：防止脚本冒充用户提交危险操作</p></li><li><p>在服务端使用HTTP的Content-Security-Policy头部来指定策略，或者在前端设置meta标答。</p></li><li><p>应对XSS攻击的主要手段还是编码与过滤两种，编码用于将特殊的符号 “&lt;、&gt;、&amp;、’、””进行html转义，而过滤则是阻止特定的标记、属性、事件。如果你不愿意为了严格的安全而限制产品本身的灵活，那么我更建议采用“编码”的方案。</p></li></ul><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p><p>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><h4 id="CSRF-情景"><a href="#CSRF-情景" class="headerlink" title="CSRF 情景"></a>CSRF 情景</h4><p>示例：银行网站 A，它以 GET 请求来完成银行转账的操作，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</span><br></pre></td></tr></table></figure><p>危险网站 B，它里面有一段 HTML 的代码如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span><br></pre></td></tr></table></figure><p>首先，你登录了银行网站 A ，然后访问危险网站 B ，噢，这时你会发现你的银行账户少了 1000 块…</p><h4 id="CSRF-攻击防范"><a href="#CSRF-攻击防范" class="headerlink" title="CSRF 攻击防范"></a>CSRF 攻击防范</h4><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。</p><p>从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。</p><p>但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。</p><h5 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h5><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。</p><p>比如，如果用户要删除自己的帖子，那么先要登录 <a href="http://www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer" target="_blank" rel="noopener">www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer</a> 的值是 <a href="http://www.c.com；当请求是从" target="_blank" rel="noopener">http://www.c.com；当请求是从</a> <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a> 发起时，Referer 的值是 <a href="http://www.a.com" target="_blank" rel="noopener">http://www.a.com</a> 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 <a href="http://www.c.com" target="_blank" rel="noopener">www.c.com</a> 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。</p><h5 id="添加-token-验证"><a href="#添加-token-验证" class="headerlink" title="添加 token 验证"></a>添加 token 验证</h5><p>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 的root和alias的区别</title>
      <link href="/2020/06/28/nginx-root-alias/"/>
      <url>/2020/06/28/nginx-root-alias/</url>
      
        <content type="html"><![CDATA[<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>nginx指定文件路径有两种方式root和alias，指令的使用方法和作用域：</p><h5 id="root"><a href="#root" class="headerlink" title="root"></a>root</h5><p>语法：root path<br>默认值：root html<br>配置段：http、server、location、if</p><h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><p>语法：alias path<br>配置段：location</p><a id="more"></a><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</p><ul><li>root的处理结果是：root路径＋location路径</li><li>alias的处理结果是：使用alias路径替换location路径</li><li>alias是一个目录别名的定义；root则是最上层目录的定义。</li><li>还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的；而root则可有可无。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>root实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /t/ &#123;</span><br><span class="line">    root /www/root/html/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个请求的URI是<code>/t/a.html</code>时，web服务器将会返回服务器上的<code>/www/root/html/t/a.html</code>的文件。</p><p>alias实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /t/ &#123;</span><br><span class="line">    <span class="built_in">alias</span> /www/root/html/new_t/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个请求的URI是<code>/t/a.html</code>时，web服务器将会返回服务器上的<code>/www/root/html/new_t/a.html</code>的文件。<br>注意这里是<code>new_t</code>，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>使用alias时，目录名后面一定要加”/“。</li><li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li><li>alias只能位于location块中。（root可以不放在location中）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域总结</title>
      <link href="/2020/05/15/cross-origin-resource-summary/"/>
      <url>/2020/05/15/cross-origin-resource-summary/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><blockquote><p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank" rel="noopener">什么是Cross-origin_resource_sharing?</a> 跨域请求存在的原因：由于浏览器的同源策略，即属于不同域的页面之间不能相互访问各自的页面内容。</p></blockquote><a id="more"></a><h4 id="跨域场景"><a href="#跨域场景" class="headerlink" title="跨域场景"></a>跨域场景</h4><ol><li><p>域名不同</p><ul><li><a href="http://www.jiuyescm.com和www.jiuye.com即为不同的域名" target="_blank" rel="noopener">www.jiuyescm.com和www.jiuye.com即为不同的域名</a></li></ul></li><li><p>二级域名相同，子域名不同</p><ul><li>a.jiuyescm.com和b.jiuyescm.com为子域不同</li></ul></li><li><p>端口不同，协议不同</p><ul><li><a href="http://www.jiuyescm.com和https://www.jiuyescm.com" target="_blank" rel="noopener">http://www.jiuyescm.com和https://www.jiuyescm.com</a></li><li><a href="http://www.jiuyescm.com:8888和www.jiuyescm.com:8080" target="_blank" rel="noopener">www.jiuyescm.com:8888和www.jiuyescm.com:8080</a></li></ul></li></ol><h4 id="解决跨域的方式"><a href="#解决跨域的方式" class="headerlink" title="解决跨域的方式"></a>解决跨域的方式</h4><ol><li>jsonp<ul><li>安全性差，已经不推荐</li></ul></li><li>CORS（W3C标准，跨域资源共享 - Cross-origin resource sharing）<ul><li>服务端设置，安全性高，推荐使用</li></ul></li><li>websocke<ul><li>特殊场景时使用，不属于常规跨域操作</li></ul></li><li>代理服务（nginx）<ul><li>可作为服务端cors配置的一种方式，推荐使用</li></ul></li></ol><h4 id="如何处理跨域（CORS处理方式）"><a href="#如何处理跨域（CORS处理方式）" class="headerlink" title="如何处理跨域（CORS处理方式）"></a>如何处理跨域（CORS处理方式）</h4><h5 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h5><ol><li><p><code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>，并且<code>The response had HTTP status code 404</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://b.domain.com, Response to preflinght request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://a.domain.com&apos; is therefore not allowed access. The Response had HTTP status code 404.</span><br></pre></td></tr></table></figure><p> 问题原因：服务器端后台没有允许OPTIONS请求</p></li><li><p><code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>，并且<code>The response had HTTP status code 405</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://b.domain.com, Response to preflinght request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://a.domain.com&apos; is therefore not allowed access. The Response had HTTP status code 405.</span><br></pre></td></tr></table></figure><p> 问题原因：服务器端后台允许了OPTIONS请求，但是某些安全配置阻止了OPTIONS请求</p></li><li><p><code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>，并且<code>The response had HTTP status code 200</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://b.domain.com, Response to preflinght request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://a.domain.com&apos; is therefore not allowed access.</span><br></pre></td></tr></table></figure><p> 问题原因：服务器端后台允许了OPTIONS请求，并且OPTIONS请求没有被阻止，但是头部不匹配。</p></li><li><p><code>heade contains multiple values &#39;*,*&#39;</code>，并且<code>The response had HTTP status code 200</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequestcannot load http://b.domain.com. The &apos;Access-Control-Allow-Origin&apos; header contains multiple values&apos;*, *&apos;, but only one is allowed. Origin &apos;http://a.domain.com&apos; is therefore notallowed access.</span><br></pre></td></tr></table></figure><p> 问题原因：设置多次Access-Control-Allow-Origin=*，可能是配置的人对CORS实现原理和机制不了解导致。</p></li></ol><h5 id="OPTIONS请求"><a href="#OPTIONS请求" class="headerlink" title="OPTIONS请求?"></a>OPTIONS请求?</h5><p>有时你会发现明明请求的是POST、GET、PUT、DELETE，但是浏览器中看到的确实OPTION，，为什么会变成OPTION？</p><blockquote><p>原因：因为本次Ajax请求是“非简单请求”,所以请求前会发送一次预检请求(OPTIONS)，这个操作由浏览器自己进行。如果服务器端后台接口没有允许OPTIONS请求,将会导致无法找到对应接口地址，因此需要服务端提供相应的信息到response header中，继续往下看。</p></blockquote><h5 id="后端需要返回的Header"><a href="#后端需要返回的Header" class="headerlink" title="后端需要返回的Header"></a>后端需要返回的Header</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 服务端允许访问的域名</span><br><span class="line">Access-Control-Allow-Origin=https://idss-uat.jiuyescm.com</span><br><span class="line"># 服务端允许访问Http Method</span><br><span class="line">Access-Control-Allow-Methods=GET, POST, PUT, DELETE, PATCH, OPTIONS</span><br><span class="line"># 服务端接受跨域带过来的Cookie,当为true时,origin必须是明确的域名不能使用*</span><br><span class="line">Access-Control-Allow-Credentials=true</span><br><span class="line"># Access-Control-Allow-Headers 表明它允许跨域请求包含content-type头，我们这里不设置，有需要的可以设置</span><br><span class="line">#Access-Control-Allow-Headers=Content-Type,Accept</span><br><span class="line"># 跨域请求中预检请求(Http Method为Option)的有效期,20天,单位秒</span><br><span class="line">Access-Control-Max-Age=1728000</span><br></pre></td></tr></table></figure><blockquote><p>如果跨域需要携带cookie去请求，Access-Control-Allow-Credentials必须为true，但是需要注意当Access-Control-Allow-Credentials=true时，Access-Control-Allow-Origin就不能为” * “ ，必须是明确的域名，当然可以多个域名使用 “,” 分割</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁 悲观锁 共享锁 排他锁</title>
      <link href="/2020/05/15/mysql-database-lock/"/>
      <url>/2020/05/15/mysql-database-lock/</url>
      
        <content type="html"><![CDATA[<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>乐观锁是逻辑概念上的锁，不是数据库自带的，需要我们自己去实现。<br>乐观锁是指操作数据库（更新操作）时，想法很乐观，认为这次操作不会导致冲突，在操作数据库时，并不进行任何其他特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突。</p><a id="more"></a><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。<br>也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等。<br>如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；<br>如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。</p><p>例，下单操作包括3步骤：</p><ol><li><p>查询出商品信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select (status,version) from t_goods where id=#&#123;id&#125;;</span><br></pre></td></tr></table></figure></li><li><p>根据商品信息生成订单</p></li><li><p>修改商品status为2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_goods set status=2, version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>悲观锁就是在操作数据时，默认此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。<br>悲观锁的实现，依靠数据库提供的锁机制，使用的时候直接调用数据库的相关语句就可以了。</p><p>数据库上的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的；同时读和写，或者同时写才会产生冲突。</p><p>MyIsam引擎会为查询和更新等操作自动添加<strong>表级锁</strong>，因此它的情况比较简单。<br>InnoDB引擎情况比较复杂，它通常会定义两种锁：<strong>共享锁</strong>和<strong>排它锁</strong>。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>共享锁(Shared Lock，也叫S锁)表示对数据进行读操作，加锁后其他事务可以读，但不能写。多个事务可以同时为一个对象加共享锁。</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure><p>这是IS锁(意向共享锁)，即在符合条件的rows上都加了共享锁，这样的话，其他人可以读取这些记录，也可以继续添加IS锁，但是无法修改这些记录直到你这个加锁的过程执行完成【完成的情况有：事务的提交，事务的回滚，否则直接锁等待超时】。</p><p><code>SELECT ... LOCK IN SHARE MODE</code>的应用场景适合于<strong>两张表存在关系时的写操作</strong>，拿mysql官方文档的例子来说：一个表是child表，一个是parent表，假设child表的某一列child_id映射到parent表的c_child_id列，那么从业务角度讲，此时我直接insert一条<code>child_id=100</code>记录到child表是存在风险的，因为刚insert的时候可能在parent表里删除了这条<code>c_child_id=100</code>的记录，那么业务数据就存在不一致的风险。正确的方法是再插入时执行<code>select * from parent where c_child_id=100 lock in share mode</code>,锁定了parent表的这条记录，然后执行<code>insert into child(child_id) values (100)</code>就不会存在这种问题了。</p><h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><p>排他锁(Exclusive Lock，也叫X锁)也叫写锁。加锁后，其他事务不能读取，也不能写。<br>如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。</p><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>产生排他锁的sql： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>要记住锁机制一定要在事务中才能生效，事务也就要基于MySQL InnoDB 引擎。</li><li>访问量不大，不会造成压力时使用悲观锁，面对高并发的情况下，我们应该使用乐观锁。</li><li>读取频繁时使用乐观锁，写入频繁时则使用悲观锁。还有一点：乐观锁不能解决脏读的问题。    </li><li>共享锁适用于两张表存在业务关系时的一致性要求，排它锁适用于操作同一张表时的一致性要求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Myisam和InnoDB解析</title>
      <link href="/2020/04/27/database-myisam-innodb/"/>
      <url>/2020/04/27/database-myisam-innodb/</url>
      
        <content type="html"><![CDATA[<h4 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a>数据库文件</h4><p>两种不同引擎创建后生成的文件如下，说明这两个引擎数据和索引的组织方式是不一样的。<br><img src="https://www.zlf520.com.cn/storage/blog/440mjLePYKnMXIjiw0p8taa0M50GfndNs2drKZ2R.jpeg" alt></p><p>Innodb 创建表后生成的文件有：</p><ul><li>frm:创建表的语句</li><li>idb:表里面的数据+索引文件</li></ul><p>Myisam 创建表后生成的文件有</p><ul><li>frm:创建表的语句</li><li>MYD:表里面的数据文件（myisam data）</li><li>MYI:表里面的索引文件（myisam index）</li></ul><a id="more"></a><p>从生成的文件看来，这两个引擎底层数据和索引的组织方式并不一样，<br>MyISAM 引擎把数据和索引分开了，一人一个文件，这叫做非聚集索引方式；<br>Innodb 引擎把数据和索引放在同一个文件里了，这叫做聚集索引方式。</p><p>下面将从底层实现角度分析这两个引擎是怎么依靠 B+树这个数据结构来组织引擎实现的。</p><h4 id="MyISAM-引擎的底层实现（非聚集索引方式）"><a href="#MyISAM-引擎的底层实现（非聚集索引方式）" class="headerlink" title="MyISAM 引擎的底层实现（非聚集索引方式）"></a>MyISAM 引擎的底层实现（非聚集索引方式）</h4><p>MyISAM 用的是非聚集索引方式，即数据和索引落在不同的两个文件上。MyISAM 在建表时以主键作为 KEY 来建立主索引 B+树，树的叶子节点存的是对应数据的物理地址。我们拿到这个物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录了。</p><p><img src="https://www.zlf520.com.cn/storage/blog/7eyygQtINBTuUg8JTC240W28tlcrQMi6aFsIQUYP.jpeg" alt></p><p>当我们为某个字段添加索引时，我们同样会生成对应字段的索引树，该字段的索引树的叶子节点同样是记录了对应数据的物理地址，然后也是拿着这个物理地址去数据文件里定位到具体的数据记录。</p><h4 id="Innodb-引擎的底层实现（聚集索引方式）"><a href="#Innodb-引擎的底层实现（聚集索引方式）" class="headerlink" title="Innodb 引擎的底层实现（聚集索引方式）"></a>Innodb 引擎的底层实现（聚集索引方式）</h4><p>InnoDB 是聚集索引方式，因此数据和索引都存储在同一个文件里。首先 InnoDB 会根据主键 ID 作为 KEY 建立索引 B+树，如左下图所示，而 B+树的叶子节点存储的是主键 ID 对应的数据，比如在执行 <code>select * from user_info where id=15</code> 这个语句时，InnoDB 就会查询这颗主键 ID 索引 B+树，找到对应的 <code>user_name=&#39;Bob&#39;</code>。</p><p>这是建表的时候 InnoDB 就会自动建立好主键 ID 索引树，这也是为什么 Mysql 在建表时要求必须指定主键的原因。当我们为表里某个字段加索引时 InnoDB 会怎么建立索引树呢？比如我们要给 user_name 这个字段加索引，那么 InnoDB 就会建立 user_name 索引 B+树，节点里存的是 user_name 这个 KEY，叶子节点存储的数据的是主键 KEY。注意，叶子存储的是主键 KEY！拿到主键 KEY 后，InnoDB 才会去主键索引树里根据刚在 user_name 索引树找到的主键 KEY 查找到对应的数据。</p><p><img src="https://www.zlf520.com.cn/storage/blog/XT89nn3NtlygQqTVk84VTEhgtQn5NaGSjci9gTbW.jpeg" alt></p><p>问题来了，为什么 InnoDB 只在主键索引树的叶子节点存储了具体数据，但是其他索引树却不存具体数据呢，而要多此一举先找到主键，再在主键索引树找到对应的数据呢?</p><p>其实很简单，因为 InnoDB 需要节省存储空间。一个表里可能有很多个索引，InnoDB 都会给每个加了索引的字段生成索引树，如果每个字段的索引树都存储了具体数据，那么这个表的索引数据文件就变得非常巨大（数据极度冗余了）。从节约磁盘空间的角度来说，真的没有必要每个字段索引树都存具体数据，通过这种看似“多此一举”的步骤，在牺牲较少查询的性能下节省了巨大的磁盘空间，这是非常有值得的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在进行 InnoDB 和 MyISAM 特点对比时谈到，MyISAM 查询性能更好，从上面索引文件数据文件的设计来看也可以看出原因：MyISAM 直接找到物理地址后就可以直接定位到数据记录，但是 InnoDB 查询到叶子节点后，还需要再查询一次主键索引树，才可以定位到具体数据。等于 MyISAM 一步就查到了数据，但是 InnoDB 要两步，那当然 MyISAM 查询性能更高。</p><p>最后再总结一下什么时候需要给你的表里的字段加索引吧：</p><ol><li>较频繁的作为查询条件的字段应该创建索引；</li><li>唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件；</li><li>更新非常频繁的字段不适合创建索引。</li></ol><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><table><thead><tr><th>Myisam</th><th>InnoDB</th></tr></thead><tbody><tr><td>不支持事务</td><td>支持事务</td></tr><tr><td>支持表级锁</td><td>支持行级锁</td></tr><tr><td>适合执行大量select操作</td><td>适合执行大量insert或update操作</td></tr><tr><td>保存行数，count操作快</td><td>不保存行数，count操作要扫表</td></tr><tr><td>适合频繁查询和count操作</td><td>适合更新和查询都频繁的操作</td></tr></tbody></table><p>行级锁中的 共享锁 和 排他锁 ：</p><blockquote><p>共享锁：也叫 读锁 或 S锁，就是多个事物对于同一数据可以共享一把锁，都能访问到数据，但是只能读，不能修改。</p></blockquote><blockquote><p>排他锁：也叫 写锁 或 X锁，就是不能与其他锁共存，如果一个事务获取了一行数据的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。但是获取排他锁的事务是可以对数据进行读取和修改的。</p></blockquote><blockquote><p>普通select查询没有任何锁机制。</p><p>update、insert、delete操作会自动加上排他锁。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树、AVL树、B树 和 B+树</title>
      <link href="/2020/04/27/database-index-tree/"/>
      <url>/2020/04/27/database-index-tree/</url>
      
        <content type="html"><![CDATA[<p>我们知道，索引的作用是做数据的快速检索，而快速检索的实现本质是数据结构。通过不同数据结构的选择，实现各种数据的快速检索。<br>下面介绍几种MySQL索引底层数据结构选型：</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>特征：</p><ol><li>他是一棵BST树</li><li>节点是红色或黑色</li><li>根是黑色</li><li>所有叶子都是黑色</li><li>每个红色节点必须有两个黑色的子节点</li><li>从任一节点到每个叶子节点的所有简单路径都包含相同数目的黑色节点</li></ol><a id="more"></a><p>示例：<br><img src="https://www.zlf520.com.cn/storage/blog/txkSFN7i6SE4Ha01j09pHdiWsj0wbMLlod90o9IR.png" alt></p><p>红黑树插入情况总结：</p><ol><li>当前节点是根节点：把根节点改为黑色 </li><li>当前节点的父节点是黑节点：保持不变 </li><li>当前节点的父节点是红节点，并且当前节点的叔叔节点是红节点：把交节点和叔叔节点改为黑色把祖父节点改为红色，把祖父节点作为当前节点，向上判断 </li><li>当前节点的父节点是红节点，并且当前节点的叔叔节点不是红节点：四种情况</li></ol><ul><li>祖父节点一＞父节点一＞当前节点，是一直向右：做左旋操作，再把父节点改为黑色，之前的祖父节点改为红色</li><li>祖父节点一＞父节点一＞当前节点，是一直向左：做右旋操作，再把父节点改为黑色，之前的祖父节点改为红色</li><li>祖父节点一＞父节点一＞当前节点，是先向左再向右：先对当前节点做左旋操作，再对当前节点做右旋操作，然后把当前节点改为黑色，之前的祖父节点改为红色</li><li>祖父节点一＞父节点一＞当前节点，是先向右再向左：先对当前节点做右旋操作，再对当前节点做左旋操作，然后把当前节点改为黑色，之前的祖父节点改为红色</li></ul><p>总结：</p><ul><li>红黑树是一颗会自动调整树形态的树结构，比如当二叉树处于一个不平衡状态时，红黑树就会自动左旋右旋节点以及节点变色，调整树的形态，使其保持基本的平衡状态（时间复杂度为 $O(log n)$），也就保证了查找效率不会明显减低。</li><li>但是红黑树也存在一些问题，红黑树并没有完全解决二叉查找树，虽然这个“右倾”趋势远没有二叉查找树退化为线性链表那么夸张，但是数据库中的基本主键自增操作，主键一般都是数百万数千万的，如果红黑树存在这种问题，对于查找性能而言也是巨大的消耗，我们数据库不可能忍受这种无意义的等待的。</li></ul><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>AVL树是另一种更为严格的自平衡二叉树。因为 AVL 树是个绝对平衡的二叉树，因此他在调整二叉树的形态上消耗的性能会更多。<br>特征：</p><ol><li>它是一棵BST树</li><li>它每个节点的左右子树高度之差不超过1</li></ol><p><img src="https://www.zlf520.com.cn/storage/blog/o1KUb7nN5ngU5W1Zetth09fEcKrTcHGfhRNsKxkf.jpeg" alt></p><p>从树的形态看来，AVL 树不存在红黑树的“右倾”问题。也就是说，大量的顺序插入不会导致查询性能的降低，这从根本上解决了红黑树的问题。</p><p>总结：</p><ol><li>不错的查找性能$O(log n)$，不存在极端的低效查找的情况。</li><li>可以实现范围查找、数据排序。</li></ol><p>看起来 AVL 树作为数据查找的数据结构确实很不错，但是 AVL 树并不适合做 Mysql 数据库的索引数据结构，因为考虑一下这个问题：</p><ul><li><p>数据库查询数据的瓶颈在于磁盘 IO，如果使用的是 AVL 树，我们每一个树节点只存储了一个数据，我们一次磁盘 IO 只能取出来一个节点上的数据加载到内存里，那比如查询 <code>id=0007</code> 这个数据我们就要进行磁盘 IO 四次，这是多么消耗时间的。所以我们设计数据库索引时需要首先考虑怎么尽可能减少磁盘 IO 的次数。</p></li><li><p>磁盘 IO 有个有个特点，就是从磁盘读取 1B 数据和 1KB 数据所消耗的时间是基本一样的，我们就可以根据这个思路，我们可以在一个树节点上尽可能多地存储数据，一次磁盘 IO 就多加载点数据到内存，这就是 B 树，B+树的的设计原理了。</p></li></ul><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）。</p><p>B树的组成：</p><ol><li>关键字（可以理解为数据）</li><li>指向孩子节点的指针</li></ol><p>B 树的节点如下图所示，每个节点可以有不只一个数据，同时拥有<strong>数据数加一个子树</strong>，同时每个节点左子树的数据比当前节点都小、右子树的数据都比当前节点的数据大：<br><img src="https://www.zlf520.com.cn/storage/blog/LYdMmj3gfsWCNJBJ2E4R1264lOFjE214f3M16NMY.jpeg" alt></p><p>一棵B树必须满足以下条件：</p><ol><li>若根结点不是终端结点，则至少有2棵子树</li><li>除根节点以外的所有非叶结点至少有 <code>ceil(M/2)</code> 棵子树，至多有 <code>M</code> 个子树（关键字数为子树减1, M 阶 B 树表示该树每个节点最多有 <code>M</code> 个子树）</li><li>所有的叶子结点都位于同一层</li></ol><p>B树优点：</p><ol><li>优秀检索速度，时间复杂度：B 树的查找性能等于 $O(hlogn)$，其中 <code>h</code> 为树高，<code>n</code> 为每个节点关键词的个数；</li><li>B 树的每个节点可以表示的信息更多，因此整个树更加“矮胖”，这在从磁盘中查找数据（先读取到内存、后查找）的过程中，可以减少磁盘 IO 的次数，从而提升查找速度；</li><li>可以支持范围查找。</li></ol><p>使用场景：<br>文件系统和数据库系统中常用的B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：</p><ul><li>Windows：HPFS 文件系统</li><li>Mac：HFS，HFS+ 文件系统</li><li>Linux：ResiserFS，XFS，Ext3FS，JFS 文件系统</li><li>数据库：ORACLE，MYSQL，SQLSERVER 等中</li></ul><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B树的升级版B+树：它比B树的查询性能更高。</p><p>一棵 B+ 树需要满足以下条件：</p><ol><li>节点的子树数和关键字数相同（B 树是关键字数比子树数少一）</li><li>节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据</li><li>叶子节点包含了全部数据，同时符合左小右大的顺序</li></ol><p><img src="https://www.zlf520.com.cn/storage/blog/9OfvRKWRRFkZfFsgzTJPypxI5Gf6FLq0RJbpbGHd.png" alt></p><p>简单概括下 B+ 树的三个特点：</p><ol><li>关键字数和子树相同</li><li>非叶子节点仅用作索引，它的关键字和子节点有重复元素</li><li>叶子节点用指针连在一起</li></ol><p>B 树和 B+树 的不同点：</p><ol><li>B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节点存不了很多个数据，但是 B+树一个节点能存很多索引，B+树叶子节点存所有的数据。</li><li>B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找。</li></ol><p>分析：<br>通过 B 树和 B+树的对比我们看出，B+树节点存储的是索引，在单个节点存储容量有限的情况下，单节点也能存储大量索引，使得整个 B+树高度降低，减少了磁盘 IO。<br>其次，B+树的叶子节点是真正数据存储的地方，叶子节点用了链表连接起来，这个链表本身就是有序的，在数据范围查找时，更具备效率。<br>因此 Mysql 的索引用的就是 B+树，B+树在查找效率、范围查找中都有着非常不错的性能。</p><p>总结B+ 树的三个优点：</p><ol><li>层级更低，IO 次数更少</li><li>每次都需要查询到叶子节点，查询性能稳定</li><li>叶子节点形成有序链表，范围查询方便</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-矩阵</title>
      <link href="/2020/04/16/algorithm-matrix/"/>
      <url>/2020/04/16/algorithm-matrix/</url>
      
        <content type="html"><![CDATA[<h4 id="01矩阵-LeetCode-542"><a href="#01矩阵-LeetCode-542" class="headerlink" title="01矩阵 LeetCode-542"></a>01矩阵 <a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">LeetCode-542</a></h4><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,0,0],</span><br><span class="line"> [0,1,0],</span><br><span class="line"> [0,0,0]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[0,0,0],</span><br><span class="line"> [0,1,0],</span><br><span class="line"> [0,0,0]]</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,0,0],</span><br><span class="line"> [0,1,0],</span><br><span class="line"> [1,1,1]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[0,0,0],</span><br><span class="line"> [0,1,0],</span><br><span class="line"> [1,2,1]]</span><br></pre></td></tr></table></figure><a id="more"></a><p>注意:</p><ol><li>给定矩阵的元素个数不超过 10000。</li><li>给定矩阵中至少有一个元素是 0。</li><li>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</li></ol><p>解法：使用<strong>广度优先搜索</strong>，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[][] $matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer[][]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateMatrix</span><span class="params">($matrix)</span> </span>&#123;</span><br><span class="line">        $res = []; <span class="comment">//返回结果数组</span></span><br><span class="line">        $queue = <span class="keyword">new</span> SplQueue(); <span class="comment">// 初始化队列，用来存储每层上的点</span></span><br><span class="line">        <span class="keyword">foreach</span> ($matrix <span class="keyword">as</span> $i =&gt; $item) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> ($item <span class="keyword">as</span> $j =&gt; $v) &#123;</span><br><span class="line">                <span class="keyword">if</span> ($v === <span class="number">0</span>) &#123; <span class="comment">// 将题目转化为 0到其他点的距离</span></span><br><span class="line">                    $res[$i][$j] = <span class="number">0</span>; <span class="comment">// 0到自身的距离为0</span></span><br><span class="line">                    $queue-&gt;enqueue([$i, $j]); <span class="comment">// 将找到的0的坐标放在队列中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BFS经典模板</span></span><br><span class="line">        <span class="keyword">while</span> (!$queue-&gt;isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 取出某层上的点</span></span><br><span class="line">            <span class="keyword">list</span>($x, $y) = $queue-&gt;dequeue();</span><br><span class="line">            <span class="comment">// 加上四个方向的偏移量</span></span><br><span class="line">            <span class="keyword">foreach</span> ([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">0</span>]] <span class="keyword">as</span> <span class="keyword">list</span>($x_bias, $y_bias)) &#123;</span><br><span class="line">                $new_x = $x + $x_bias;</span><br><span class="line">                $new_y = $y + $y_bias;</span><br><span class="line">                <span class="comment">// 判断扩展点的有效性</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= $new_x &amp;&amp; $new_x &lt; count($matrix) &amp;&amp; <span class="number">0</span> &lt;= $new_y &amp;&amp; $new_y &lt; count($matrix[<span class="number">0</span>]) &amp;&amp; !<span class="keyword">isset</span>($res[$new_x][$new_y])) &#123;</span><br><span class="line">                    <span class="comment">// 将新点的坐标和距离写入结果数组</span></span><br><span class="line">                    $res[$new_x][$new_y] = $res[$x][$y] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 将新扩展点加入队列</span></span><br><span class="line">                    $queue-&gt;enqueue([$new_x, $new_y]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二位结果集数组，按照key排序</span></span><br><span class="line">        ksort($res);</span><br><span class="line">        <span class="keyword">foreach</span> ($res <span class="keyword">as</span> &amp;$item) &#123;</span><br><span class="line">            ksort($item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-链表</title>
      <link href="/2020/04/16/algorithm-link-list/"/>
      <url>/2020/04/16/algorithm-link-list/</url>
      
        <content type="html"><![CDATA[<h4 id="两数相加-LeetCode-2"><a href="#两数相加-LeetCode-2" class="headerlink" title="两数相加 LeetCode-2"></a>两数相加 <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">LeetCode-2</a></h4><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><a id="more"></a><p>code：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public $val = 0;</span></span><br><span class="line"><span class="comment"> *     public $next = null;</span></span><br><span class="line"><span class="comment"> *     function __construct($val) &#123; $this-&gt;val = $val; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ListNode $l1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ListNode $l2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTwoNumbers</span><span class="params">($l1, $l2)</span> </span>&#123;</span><br><span class="line">        $t = $l1;</span><br><span class="line">        $k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            $val = $t-&gt;val + $l2-&gt;val + $k;</span><br><span class="line">            $t-&gt;val = $val % <span class="number">10</span>;</span><br><span class="line">            $k = $val &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!$t-&gt;next &amp;&amp; !$l2-&gt;next &amp;&amp; $k) &#123;</span><br><span class="line">                $t-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>($t-&gt;next &amp;&amp; !$l2-&gt;next) &#123;</span><br><span class="line">                $l2-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>($l2-&gt;next &amp;&amp; !$t-&gt;next) &#123;</span><br><span class="line">                $t-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            $t = $t-&gt;next;</span><br><span class="line">            $l2 = $l2-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> ($t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两数相加II-LeetCode-445"><a href="#两数相加II-LeetCode-445" class="headerlink" title="两数相加II LeetCode-445"></a>两数相加II <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">LeetCode-445</a></h4><p>给你两个<strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> $val = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">public</span> $next = <span class="keyword">null</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>解法1：栈</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于逆序处理，用栈处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ListNode $l1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ListNode $l2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTwoNumbersII</span><span class="params">($l1, $l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($l1 === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> $l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($l2 === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> $l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化栈</span></span><br><span class="line">        $stack1 = <span class="keyword">new</span> SplStack();</span><br><span class="line">        $stack2 = <span class="keyword">new</span> SplStack();</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        <span class="keyword">while</span> ($l1 !== <span class="keyword">null</span>) &#123;</span><br><span class="line">            $stack1-&gt;push($l1-&gt;val);</span><br><span class="line">            $l1 = $l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ($l2 !== <span class="keyword">null</span>) &#123;</span><br><span class="line">            $stack2-&gt;push($l2-&gt;val);</span><br><span class="line">            $l2 = $l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $k = <span class="number">0</span>;</span><br><span class="line">        $head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!$stack1-&gt;isEmpty() || !$stack2-&gt;isEmpty() || $k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            $sum = $k;</span><br><span class="line">            $sum += $stack1-&gt;isEmpty() ? <span class="number">0</span> : $stack1-&gt;pop();</span><br><span class="line">            $sum += $stack2-&gt;isEmpty() ? <span class="number">0</span> : $stack2-&gt;pop();</span><br><span class="line">            $node = <span class="keyword">new</span> ListNode($sum % <span class="number">10</span>);</span><br><span class="line">            $node-&gt;next = $head;</span><br><span class="line">            $head = $node;</span><br><span class="line">            $k = floor($sum / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：翻转链表</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ListNode $l1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ListNode $l2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTwoNumbersII</span><span class="params">($l1, $l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 翻转链表</span></span><br><span class="line">        $list_rev = <span class="function"><span class="keyword">function</span> <span class="params">($listNode)</span> </span>&#123;</span><br><span class="line">            $prev = <span class="keyword">null</span>;</span><br><span class="line">            $cur = $listNode;</span><br><span class="line">            <span class="keyword">while</span> ($cur) &#123;</span><br><span class="line">                $next = $cur-&gt;next;</span><br><span class="line">                <span class="comment">// 新链表从后往前生成</span></span><br><span class="line">                $cur-&gt;next = $prev;</span><br><span class="line">                $prev = $cur;</span><br><span class="line">                </span><br><span class="line">                $cur = $next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> $prev;</span><br><span class="line">        &#125;;</span><br><span class="line">        $l1 = $list_rev($l1);</span><br><span class="line">        $l2 = $list_rev($l2);</span><br><span class="line">        $res = <span class="keyword">null</span>;</span><br><span class="line">        $add = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> ($l1 || $l2 || $add) &#123;</span><br><span class="line">            $sum = $add ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ($l1) &#123;</span><br><span class="line">                $sum += $l1-&gt;val;</span><br><span class="line">                $l1 = $l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ($l2) &#123;</span><br><span class="line">                $sum += $l2-&gt;val;</span><br><span class="line">                $l2 = $l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ($sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                $sum -= <span class="number">10</span>;</span><br><span class="line">                $add = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $add = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回链表也是从后往前生成</span></span><br><span class="line">            $node = <span class="keyword">new</span> ListNode($sum);</span><br><span class="line">            $node-&gt;next = $res;</span><br><span class="line">            $res = $node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 部署到GitHub时categories中的大小写问题</title>
      <link href="/2020/04/16/hexo-categories-case-error/"/>
      <url>/2020/04/16/hexo-categories-case-error/</url>
      
        <content type="html"><![CDATA[<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>使用Hexo添加新文章后，部署到GitHub上，有时候新增或者修改了tag或者categories，比如新增categories为Mac，然后再本地<code>.deploy_git/categories</code>中，Mac目录显示正常，本地预览正常，但是推送到GitHub后，categories目录中显示为mac，从而导致点击Mac分类时显示404。<br><img src="https://www.zlf520.com.cn/storage/blog/3i5Pkykg9ULXCy4UBLtvRXohUQnwerzlxqhjdQms.png" alt></p><a id="more"></a><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>这个问题是由于git命令默认的配置中忽略了文件名的大小写，因此即便文件夹的大小写发生了变更，git也会表现出置之不理。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure><p>修改git配置，进入<code>.deploy_git</code>，修改<code>.git/config</code>文件，将<code>ignorecase = true</code>修改为<code>ignorecase = false</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .deploy_git</span><br><span class="line">sudo vim .git/config</span><br></pre></td></tr></table></figure><p>接着删除<code>.deploy_git</code>文件夹中git仓库的所有文件，并push到GitHub，清空你的github.io项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo git rm -rf *</span><br><span class="line">sudo git commit -m &quot;clean all file&quot;</span><br><span class="line">sudo git push</span><br></pre></td></tr></table></figure><p>返回blog目录，重新编译并上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo g</span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure><p>重新刷新页面，大小写问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 插入数学公式</title>
      <link href="/2020/04/16/hexo-math/"/>
      <url>/2020/04/16/hexo-math/</url>
      
        <content type="html"><![CDATA[<h4 id="安装配置hexo-math"><a href="#安装配置hexo-math" class="headerlink" title="安装配置hexo-math"></a>安装配置hexo-math</h4><p>hexo 中已经对mathjax、katex 进行了集成，这里使用的是mathjax，需要先下载 <code>hexo-math</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>然后在站点目录下<code>_config.yml</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">  engine: &apos;mathjax&apos; # or &apos;katex&apos;</span><br><span class="line">  mathjax:</span><br></pre></td></tr></table></figure><a id="more"></a><p>然后在主题目录下<code>_config.yml</code> 中配置，我这里使用的 Next主题，默认就有配置，只需要将 <code>math</code> 下<code>enable</code> 改为<code>true</code> 即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  engine: mathjax</span><br><span class="line">  #engine: katex</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) needed to full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    cdn: //cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><p>其中 per_page 根据提示，表示默认不加载 mathjax/katex 脚本，如果设置为 false，则是每篇文章都会去加载 mathjax 脚本，这里我设置为 true，然后在需要加载的文章抬头添加 mathjax: true 即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo 插入数学公式</span><br><span class="line">date: 2020-04-14 16:35:11</span><br><span class="line">mathjax: true</span><br><span class="line">tags: </span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="简单语法"><a href="#简单语法" class="headerlink" title="简单语法"></a>简单语法</h4><h5 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h5><blockquote><p>行内的公式用<code>$公式内容$</code> 包裹起来，在公式中右键即可查看公式 $\TeX$ 代码</p></blockquote><p>显示在行内的公式：$g(x)=8 \times ln \ x$，另外一个公式：$f(x)=ax^2+bx+c$</p><h5 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h5><blockquote><p>多行公式用<code>$$公式内容$$</code>包裹起来，独占一行，同样右键可查看公式代码</p></blockquote><ol><li><p>矩阵<br>$$\left[ \begin{array}{lll}{1} &amp; {2} &amp; {3} \\ {4} &amp; {5} &amp; {6} \\ {7} &amp; {8} &amp; {9}\end{array}\right]$$</p></li><li><p>指数与平方根<br>$$\sqrt{x^{2a}+\sqrt{y}}$$</p></li><li><p>分数<br>$$\frac{x^{2}}{k + 1}$$</p></li><li><p>常用符号<br>$$+ - \times \div$$<br>$$\pm \cdot \times \div \cup \cap \star \leq \ll \geq \gg$$<br>$$\sim \simeq \approx$$</p></li></ol><blockquote><p>$\LaTeX$语法参考链接：<a href="https://panzhenglian.com/lshort-cn.pdf" target="_blank" rel="noopener">一份不太简短的 $\LaTeX$ 2ε 介绍</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置HTTPS</title>
      <link href="/2020/04/14/network-nginx-https/"/>
      <url>/2020/04/14/network-nginx-https/</url>
      
        <content type="html"><![CDATA[<p>由于自己是阿里云的域名，所以在阿里云的 SSL证书 中申请的ssl证书。</p><p>证书申请流程：<br><img src="https://www.zlf520.com.cn/storage/blog/xuT9W6AZXlRSTNBKGmB0GXVgLoF4geVTekUQRPAK.jpeg" alt="img"></p><a id="more"></a><p>下载的Nginx证书压缩文件解压后包含：</p><ul><li>.pem：证书文件。PEM文件的扩展名为CRT格式。</li><li>.key：证书的密钥文件。申请证书时如果未选择自动创建CRS，则下载的证书文件压缩包中不会包含.key文件，需要您将自己手动常见的私钥文件拷贝到cert目录下。</li></ul><p>在阿里云下载证书之后，复制到nginx中，配置nginx，主要代码块如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># For https</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl default_server;</span><br><span class="line">    listen [::]:443 ssl default_server ipv6only=on;</span><br><span class="line">    ssl_certificate /var/www/laradock/nginx/ssl/2908009.pem;</span><br><span class="line">    ssl_certificate_key /var/www/laradock/nginx/ssl/2908009.key;</span><br><span class="line"></span><br><span class="line">    server_name xxx.com www.xxx.com;</span><br><span class="line">    root /var/www/public;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"># http 跳转到 https</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.xxx.com;</span><br><span class="line">return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx服务。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS详解</title>
      <link href="/2020/04/14/network-https/"/>
      <url>/2020/04/14/network-https/</url>
      
        <content type="html"><![CDATA[<h5 id="1-什么是https"><a href="#1-什么是https" class="headerlink" title="1.什么是https"></a>1.什么是https</h5><p>HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。</p><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为 HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p><p><img src="https://www.zlf520.com.cn/storage/blog/I50EcG0tlyeNU8vxnK29134wcPHPLrB6oyN7gz2N.jpeg" alt="img"></p><a id="more"></a><h5 id="2-https和http的区别"><a href="#2-https和http的区别" class="headerlink" title="2.https和http的区别"></a>2.https和http的区别</h5><ul><li>https的服务器需要到CA申请证书，以证明自己服务器的用途。</li><li>http信息是明文传输，https信息是密文传输。</li><li>http与https的端口不同，一个是80端口，一个是443端口。</li></ul><h5 id="3-https通讯步骤"><a href="#3-https通讯步骤" class="headerlink" title="3.https通讯步骤"></a>3.https通讯步骤</h5><p>对称加密和非对称加密的结合</p><p><img src="https://www.zlf520.com.cn/storage/blog/juyh4wqgPGYPiskmty4Yi2D7jO2rbrOygRolIeAn.jpeg" alt="img"></p><ol><li><p>客户端请求服务器，发送握手消息</p></li><li><p>获取公钥：服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有：</p><p>（1）证书的发布机构CA</p><p>（2）证书的有效期</p><p>（3）公钥</p><p>（4）证书所有者</p><p>（5）签名</p><p>客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：</p><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</p><p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</p><p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p><p>（4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密</p><p>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p><p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充，此时浏览器会采用自身的随机数算法产生一个随机数作为对称秘钥</p><p>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p></li><li><p>浏览器通过公钥加密（加密算法和对称秘钥），传递给服务器</p></li><li><p>服务器收到信息后，用私钥解密，提取出对称加密算法和对称秘钥，并用此对称密钥采用对称加密算法加密一段握手消息发送给浏览器</p></li><li><p>浏览器收到消息后解密成功，则握手结束，后续的信息都通过此对称密钥加密传输。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> nginx </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-排序</title>
      <link href="/2020/04/14/algorithm-sort/"/>
      <url>/2020/04/14/algorithm-sort/</url>
      
        <content type="html"><![CDATA[<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>对数组按照从小到大进行排序，从前往后对相邻的两个数依次进行比较和调整，让较大的往后移动，每轮将最大的数移动到最后。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blbble_sort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $count = count($arr);</span><br><span class="line">    <span class="keyword">if</span>($count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; $count; $i++) &#123;</span><br><span class="line">        <span class="comment">// 循环控制每轮，将该轮最大的数字移动到最后</span></span><br><span class="line">        <span class="keyword">for</span>($j = <span class="number">0</span>; $j &lt; $count - $i; $j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>($arr[$j] &gt; $arr[$j + <span class="number">1</span>]) &#123;</span><br><span class="line">                $temp = $arr[$j];</span><br><span class="line">                $arr[$j] = $arr[$j + <span class="number">1</span>];</span><br><span class="line">                $arr[$j + <span class="number">1</span>] = $temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>在数组中，选出最小的一个数与第一个位置的数交换，然后再在剩下的数中找出最小的数与第二个位置的数进行交换，如此循环到倒数第二个数与最后一个数比较为止。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">selectSort</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    <span class="comment">// 双层循环，外层控制轮数，内层控制比较次数</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len<span class="number">-1</span>; $i++) &#123;</span><br><span class="line">        <span class="comment">// 先假设最小值的位置</span></span><br><span class="line">        $p = $i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ($j = $i + <span class="number">1</span>; $j &lt; $len; $j++) &#123;</span><br><span class="line">            <span class="comment">// $arr[$p]是当前已知的最小值</span></span><br><span class="line">            <span class="comment">// 比较，发现更小的，记录下最小值的位置；并且在下次比较的时候采用已知的最小值进行比较</span></span><br><span class="line">            <span class="keyword">if</span> ($arr[$p] &gt; $arr[$j]) &#123;</span><br><span class="line">                $p = $j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小值的位置为$p，如果发现最小值的位置和当前假设的位置$i不同，则位置互换即可</span></span><br><span class="line">        <span class="keyword">if</span> ($p != $i) &#123;</span><br><span class="line">            $tmp = $arr[$p];</span><br><span class="line">            $arr[$p] = $arr[$i];</span><br><span class="line">            $arr[$i] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>在需要排序的数组中，假设前面的数已经是排序好的，现在要把第n个数插入到前面的有序数组中，使得这n个数也是排序好的。如此反复循环，直到全部排好顺序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insertSort</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $len; $i++) &#123;</span><br><span class="line">        <span class="comment">// 要插入的元素</span></span><br><span class="line">        $tmp = $arr[$i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层是在外层之前的数组</span></span><br><span class="line">        <span class="keyword">for</span> ($j = $i - <span class="number">1</span>; $j &gt;= <span class="number">0</span>; $j--) &#123;</span><br><span class="line">            <span class="comment">// 发现插入的元素要小，交换位置，将后边的元素与前面的元素互换</span></span><br><span class="line">            <span class="keyword">if</span> ($tmp &lt; $arr[$j]) &#123;</span><br><span class="line">                $arr[$j + <span class="number">1</span>] = $arr[$j];</span><br><span class="line">                $arr[$j] = $tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果碰到不需要移动的元素，由于是已经排序好是数组，则前面的就不需要再次比较了,跳出内层循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>选择一个基准元素，通过一趟扫描，将数组分成两部分，一部分比基准元素小，一部分大于等于基准元素，此时基准元素在其排好序后的中间位置，然后再用同样的方法递归地排序划分的两部分。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick_sort</span><span class="params">(array $list)</span> </span>&#123;</span><br><span class="line">    $len = count($list);</span><br><span class="line">    <span class="keyword">if</span>($len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择第一个元素作为基准元素</span></span><br><span class="line">    $pivotValue = $list[<span class="number">0</span>];</span><br><span class="line">    $left = <span class="keyword">array</span>();</span><br><span class="line">    $right = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">// 遍历除了基准元素以外的所有元素，按照大小关系放入两个数组中</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $lenght; $i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($list[$i] &lt; $pivotValue) &#123;</span><br><span class="line">            $left[] = $list[$i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $right[] = $list[$i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再分别对左边和右边的数组进行相同的排序处理</span></span><br><span class="line">    $left = quick_sort($left);</span><br><span class="line">    $right = quick_sort($right);</span><br><span class="line">    <span class="keyword">return</span> array_merge($left, <span class="keyword">array</span>($pivotValue), $right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-搜索</title>
      <link href="/2020/04/14/algorithm-search/"/>
      <url>/2020/04/14/algorithm-search/</url>
      
        <content type="html"><![CDATA[<h5 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h5><p>如果数组中的项按顺序排列，就可以不必进行线性搜索，而可以使用<strong>二分搜索</strong>。<br>查找时，先从中间数据开始，检查中间的项是否比我们要寻找的项大或小，并决定保留哪一半，并继续重复前面的搜索，直到找到需要搜索的值。<br>搜索长度呈指数递减，所以，最坏和平均时间复杂度为$O(logn)$，空间复杂度为$O(1)$。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binSearch</span><span class="params">($arr, $search)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索数组的最大和最小下标</span></span><br><span class="line">    $height = count($arr) - <span class="number">1</span>;</span><br><span class="line">    $low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>($low &lt;= $height) &#123;</span><br><span class="line">        $mid = floor(($low + $height) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>($arr[$mid] == $search) &#123;</span><br><span class="line">            <span class="keyword">return</span> $mid;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($arr[$mid] &lt; $search) &#123;</span><br><span class="line">            $low = $mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span>($arr[$mid] &gt; $search) &#123;</span><br><span class="line">            $height = $mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'查找失败'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>递归版本：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearchRecursion</span><span class="params">(array $arr, int $needle, int $low, int $high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($high &lt; $low) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    $middle = (int)(($high + $low) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($arr[$middle] &lt; $needle) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion($arr, $needle, $middle + <span class="number">1</span>, $high);</span><br><span class="line">    &#125; <span class="keyword">elseif</span> ($arr[$middle] &gt; $needle) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion($arr, $needle, $low, $middle - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重复二分搜索"><a href="#重复二分搜索" class="headerlink" title="重复二分搜索"></a>重复二分搜索</h5><p>假设我们有一个含有重复数据的数组，如果我们想从数组中找到某个数的第一次出现的位置，就可以修改上面的二分搜索。<br>需要修改的地方是找到搜索值时，将下标赋值给<code>firstIndex</code>，并不返回，并重复查找，直到<code>$low &gt; $high</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">repetitiveBinarySearch</span><span class="params">($arr, $search)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $low = <span class="number">0</span>;</span><br><span class="line">    $high = count($arr);</span><br><span class="line">    $firstIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ($low &lt;= $high) &#123;</span><br><span class="line">        <span class="comment">// 右移一位，即是：除二取整</span></span><br><span class="line">        $middle = ($low + $high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($arr[$middle] === $search) &#123;</span><br><span class="line">            $firstIndex = $middle;</span><br><span class="line">            $high = $middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($arr[$middle] &gt; $search) &#123;</span><br><span class="line">            $high = $middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $low = $middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $firstIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插值搜索"><a href="#插值搜索" class="headerlink" title="插值搜索"></a>插值搜索</h5><p>如果一个数组是均匀分布的，并且我们正在寻找的数据可能接近数组的末尾，那么从中间搜索可能不是一个好选择。 在这种情况下，插值搜索可能非常有用。插值搜索是对二分搜索算法的改进，插值搜索可以基于搜索的值选择到达不同的位置。例如，如果我们正在搜索靠近数组开头的值，它将直接定位到到数组的第一部分而不是中间。使用公式计算位置，如下所示：</p><blockquote><p>$middle = low + [(key - arr[low]) * (high - low) / (arr[high] - arr[low])]$</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">interpolationSearch</span><span class="params">($arr, $search)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $low = <span class="number">0</span>;</span><br><span class="line">    $high = count($arr) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ($arr[$low] != $arr[$high] &amp;&amp; $search &gt;= $arr[$low] &amp;&amp; $search &lt;= $arr[$high]) &#123;</span><br><span class="line">        $middle = intval($low + ($search - $arr[$low]) * ($high - $low) / ($arr[$high] - $arr[$low]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($arr[$middle] &lt; $search) &#123;</span><br><span class="line">            $low = $middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($arr[$middle] &gt; $search) &#123;</span><br><span class="line">            $high = $middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> $middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($search == $arr[$low]) &#123;</span><br><span class="line">        <span class="keyword">return</span> $low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="指数搜索"><a href="#指数搜索" class="headerlink" title="指数搜索"></a>指数搜索</h5><p>在二分搜索中，我们在整个列表中搜索给定的数据。指数搜索通过决定搜索的下界和上界来改进二分搜索，这样我们就不会搜索整个列表。</p><ol><li>我们通过查找第一个指数k来确定边界大小，其中值2^k的值大于搜索项。 现在，$2^k$和$2^{(k-1)}$分别成为上限和下限。 </li><li>使用以上的边界来进行二分搜索。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exponentialSearch</span><span class="params">($arr, $search)</span> </span>&#123;</span><br><span class="line">    $length = count($arr);</span><br><span class="line">    <span class="keyword">if</span> ($length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    $bound = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ($bound &lt; $length &amp;&amp; $arr[$bound] &lt; $search) &#123;</span><br><span class="line">        $bound *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> binarySearchRecursion($arr, $search, $bound &gt;&gt; <span class="number">1</span>, min($bound, $length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二叉树</title>
      <link href="/2020/04/14/algorithm-binary-tree/"/>
      <url>/2020/04/14/algorithm-binary-tree/</url>
      
        <content type="html"><![CDATA[<h4 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h4><h5 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历 DFS"></a>深度优先遍历 DFS</h5><p>二叉树的<strong>深度优先遍历</strong>可以细分为：先序遍历、中序遍历、后续遍历。</p><ul><li>前序遍历：根节点 -&gt; 左子树 -&gt; 右子树</li><li>中序遍历：左子树 -&gt; 根节点 -&gt; 右子树</li><li>后续遍历：左子树 -&gt; 右子树 -&gt; 根节点<a id="more"></a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> $data;  <span class="comment">//数据域</span></span><br><span class="line">        <span class="keyword">public</span> $LeftHand = <span class="keyword">NULL</span>;  <span class="comment">//左指针</span></span><br><span class="line">        <span class="keyword">public</span> $RightHand = <span class="keyword">NULL</span> ; <span class="comment">//右指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">empty</span>($data)) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;data = $data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先序遍历（根，左，右）递归实现</span></span><br><span class="line">        <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">PreTraverseBTree</span><span class="params">($BTree)</span></span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">NULL</span> !== $BTree)&#123;</span><br><span class="line">                var_dump($BTree-&gt;data);<span class="comment">//根</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">NULL</span> !== $BTree-&gt;LeftHand)&#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;PreTraverseBTree($BTree-&gt;LeftHand); <span class="comment">//递归遍历左树</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">NULL</span> !== $BTree-&gt;RightHand)&#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;PreTraverseBTree($BTree-&gt;RightHand); <span class="comment">//递归遍历右树</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//中序遍历(左，根，右)递归实现</span></span><br><span class="line">        <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span>  <span class="title">InTraverseBTree</span><span class="params">($BTree)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">NULL</span> !== $BTree)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">NULL</span> !== $BTree-&gt;LeftHand)&#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;InTraverseBTree($BTree-&gt;LeftHand); <span class="comment">//递归遍历左树</span></span><br><span class="line">                &#125;</span><br><span class="line">                var_dump($BTree-&gt;data); <span class="comment">//根</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">NULL</span> !== $BTree-&gt;RightHand)&#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;InTraverseBTree($BTree-&gt;RightHand); <span class="comment">//递归遍历右树</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后序遍历(左，右，根)递归实现</span></span><br><span class="line">        <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span>  <span class="title">FexTarverseBTree</span><span class="params">($BTree)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">NULL</span> !== $BTree)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">NULL</span> !== $BTree-&gt;LeftHand)&#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;FexTarverseBTree($BTree-&gt;LeftHand); <span class="comment">//递归遍历左树</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">NULL</span> !== $BTree-&gt;RightHand)&#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;FexTarverseBTree($BTree-&gt;RightHand); <span class="comment">//递归遍历右树</span></span><br><span class="line">                &#125;</span><br><span class="line">                var_dump($BTree-&gt;data); <span class="comment">//根</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   header(<span class="string">"Content-Type:text/html;charset=utf-8"</span>);</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">'先的内存为'</span>.var_dump(memory_get_usage());</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">'&lt;hr/&gt;'</span>; </span><br><span class="line">   <span class="comment">//创建五个节点</span></span><br><span class="line">   $A  = <span class="keyword">new</span>  BTreeNode(<span class="string">'A'</span>);</span><br><span class="line">   $B  = <span class="keyword">new</span>  BTreeNode(<span class="string">'B'</span>);</span><br><span class="line">   $C  = <span class="keyword">new</span>  BTreeNode(<span class="string">'C'</span>);</span><br><span class="line">   $D  = <span class="keyword">new</span>  BTreeNode(<span class="string">'D'</span>);</span><br><span class="line">   $E  = <span class="keyword">new</span>  BTreeNode(<span class="string">'E'</span>);</span><br><span class="line">   <span class="comment">//连接形成一个二叉树</span></span><br><span class="line">   $A-&gt;LeftHand  = $B;</span><br><span class="line">   $A-&gt;RightHand = $C;</span><br><span class="line">   $C-&gt;LeftHand  = $D;</span><br><span class="line">   $D-&gt;RightHand = $E;  </span><br><span class="line">   <span class="comment">//先序遍历</span></span><br><span class="line">   <span class="keyword">echo</span> <span class="string">'先序遍历的结果'</span>.<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">   $A-&gt;PreTraverseBTree($A);</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">'&lt;br/&gt;中序遍历的结果'</span>.<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">   $A-&gt;InTraverseBTree($A); </span><br><span class="line">   <span class="keyword">echo</span>  <span class="string">'&lt;br/&gt;后序列遍历的结果'</span>.<span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">   $A-&gt;FexTarverseBTree($A); </span><br><span class="line">   <span class="keyword">echo</span> <span class="string">'&lt;hr/&gt;'</span>;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">'后的内存为'</span>.var_dump(memory_get_usage());</span><br></pre></td></tr></table></figure></li></ul><h5 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历 BFS"></a>广度优先遍历 BFS</h5><p>广度优先遍历：又叫层次遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层就进入下一层，直到没有结点可以访问为止。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本1：数组模拟队列，先入先出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span><span class="params">(TreeNode $root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $res = $arr = [];</span><br><span class="line">        <span class="keyword">if</span> ($root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> $res;</span><br><span class="line">        &#125;</span><br><span class="line">        array_push($arr, $root);</span><br><span class="line">        $level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ($count = count($arr)) &#123;</span><br><span class="line">            <span class="keyword">for</span> ($i = $count; $i &gt; <span class="number">0</span>; $i--) &#123;</span><br><span class="line">                $node = array_shift($arr); <span class="comment">// 先入先出</span></span><br><span class="line">                $res[$level][] = $node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> ($node-&gt;left != <span class="keyword">null</span>) array_push($arr, $node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ($node-&gt;right != <span class="keyword">null</span>) array_push($arr, $node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            $level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本2：使用PHP SplQueue</p><blockquote><p>SplQueue 类通过使用一个双向链表来提供队列的主要功能。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span><span class="params">(TreeNode $root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $res = [];</span><br><span class="line">        $arr = <span class="keyword">new</span> SplQueue();</span><br><span class="line">        <span class="keyword">if</span> ($root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> $res;</span><br><span class="line">        &#125;</span><br><span class="line">        $arr-&gt;enqueue($root);</span><br><span class="line">        $level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ($count = count($arr)) &#123;</span><br><span class="line">            <span class="keyword">for</span> ($i = $count; $i &gt; <span class="number">0</span>; $i--) &#123;</span><br><span class="line">                $node = $arr-&gt;dequeue(); <span class="comment">// 删除第一位</span></span><br><span class="line">                $res[$level][] = $node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> ($node-&gt;left != <span class="keyword">null</span>) $arr-&gt;enqueue($node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ($node-&gt;right != <span class="keyword">null</span>) $arr-&gt;enqueue($node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            $level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本3：递归</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span><span class="params">(TreeNode $root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $res = [];</span><br><span class="line">        <span class="keyword">$this</span>-&gt;level($root, <span class="number">0</span>, $res);</span><br><span class="line">        <span class="keyword">return</span> $res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">level</span><span class="params">($root, $level, &amp;$res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        $res[$level][] = $root-&gt;val;</span><br><span class="line">        $level++;</span><br><span class="line">        <span class="keyword">if</span> ($root-&gt;left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;level($root-&gt;left, $level, $res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($root-&gt;right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;level($root-&gt;right, $level, $res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否是二叉搜索树"><a href="#判断是否是二叉搜索树" class="headerlink" title="判断是否是二叉搜索树"></a>判断是否是二叉搜索树</h4><p>判断一颗树是否是二叉搜索树，一棵树是BST需要满足</p><ul><li>一个节点的值大于它左子树所有节点的值</li><li>一个节点的值小于它右子树所有节点的值</li><li>左右子树也必须是二叉搜索树</li></ul><p>所以只需要遍历每个节点，判断</p><ul><li>该节点值是否大于左子树的最大值</li><li>该节点值是否小于右子树的最小值</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     public $val;</span></span><br><span class="line"><span class="comment"> *     public $left;</span></span><br><span class="line"><span class="comment"> *     public $right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidBST</span><span class="params">(TreeNode $root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!$root)   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//大于左子树的最大值</span></span><br><span class="line">        $leftNode = $root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span>($leftNode)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>($root-&gt;val &lt;= $leftNode-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            $leftNode = $leftNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小于右子树的最小值</span></span><br><span class="line">        $rightNode = $root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>($rightNode)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>($root-&gt;val &gt;= $rightNode-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            $rightNode = $rightNode-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isValidBST($root-&gt;left) &amp;&amp; isValidBST($root-&gt;right))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度 和 空间复杂度</title>
      <link href="/2020/04/14/algorithm-time-space/"/>
      <url>/2020/04/14/algorithm-time-space/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>时间复杂度和空间复杂度是用来评价算法效率高低的两个标准。</p><ul><li>时间复杂度：就是执行算法需要消耗的时间长短，越快越好。</li><li>空间复杂度：就是执行当前算法需要消耗的存储空间大小，也是越小越好。</li></ul><a id="more"></a><h4 id="时间复杂度计算"><a href="#时间复杂度计算" class="headerlink" title="时间复杂度计算"></a>时间复杂度计算</h4><h5 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h5><p>我们一般用“大O符号表示法”来表示时间复杂度：$T(n) = O(f(n))$</p><ul><li>$n$是影响复杂度变化的因子</li><li>$f(n)$是复杂度具体的算法。</li></ul><h5 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h5><ul><li>常数阶 $O(1)$</li><li>线性阶 $O(n)$</li><li>对数阶 $O(logN)$</li><li>线性对数阶 $O(nlogN)$</li><li>平方阶 $O(n^2)$</li><li>立方阶 $O(n^3)$</li><li>K次方阶 $O(n^k)$</li><li>指数阶 $O(2^n)$</li></ul><h5 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶$O(1)$"></a>常数阶$O(1)$</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = <span class="number">2</span>;</span><br><span class="line">$c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>我们假定每执行一行代码所需要消耗的时间为1个时间单位，那么以上3行代码就消耗了3个时间单位。那是不是这段代码的时间复杂度表示为$O(n)$呢 ？<br>其实不是的，因为大$O$符号表示法并不是用于来真实代表算法的执行时间的，它是用来<strong>表示代码执行时间的增长变化趋势的</strong>。<br>上面的算法并没有随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用$O(1)$来表示它的时间复杂度。</p><h5 id="线性阶-O-n"><a href="#线性阶-O-n" class="headerlink" title="线性阶$O(n)$"></a>线性阶$O(n)$</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>($i = <span class="number">1</span>; $i &lt;= n; $i++) &#123;</span><br><span class="line">    $j = $i;</span><br><span class="line">    $j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看这段代码会执行多少次呢？<br>第1行会执行1次，第2行和第3行会分别执行$n$次，总的执行时间也就是$2n+1$次，那它的时间复杂度表示是 $O(2n + 1)$ 吗？ No !<br>还是那句话：“大$O$符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的”。<br>所以它的时间复杂度其实是$O(n)$。</p><h5 id="对数阶-O-logN"><a href="#对数阶-O-logN" class="headerlink" title="对数阶$O(logN)$"></a>对数阶$O(logN)$</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>($i &lt; n) &#123;</span><br><span class="line">    $i = $i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到每次循环的时候 i 都会乘2，那么总共循环的次数就是$log_{2}n$，因此这个代码的时间复杂度为$O(logn)$。<br>这儿有个问题，为什么明明应该是$O(log_{2}n)$,却要写成$O(logn)$呢？<br>其实这里的底数对于研究程序运行效率不重要，写代码时要考虑的是数据规模$n$对程序运行效率的影响，常数部分则忽略，同样的，如果不同时间复杂度的倍数关系为常数，那也可以近似认为两者为同一量级的时间复杂度。</p><h5 id="线性对数阶-O-nlogN"><a href="#线性对数阶-O-nlogN" class="headerlink" title="线性对数阶$O(nlogN)$"></a>线性对数阶$O(nlogN)$</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>($m = <span class="number">1</span>; $m &lt; $n; $m++) &#123;</span><br><span class="line">    $i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>($i &lt; $n) &#123;</span><br><span class="line">        $i = $i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性对数阶$O(nlogN)$其实非常容易理解，将时间复杂度为$O(logn)$的代码循环$N$遍的话，那么它的时间复杂度就是 $n * O(logN)$，也就是了$O(nlogN)$。</p><h5 id="平方阶-O-n-2"><a href="#平方阶-O-n-2" class="headerlink" title="平方阶$O(n^2)$"></a>平方阶$O(n^2)$</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>($x=<span class="number">1</span>; $i &lt;= $n; $x++)&#123;</span><br><span class="line">   <span class="keyword">for</span>($i = $<span class="number">1</span>; $i &lt;= $n; $i++) &#123;</span><br><span class="line">       $j = $i;</span><br><span class="line">       $j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 $O(n)$ 的代码再嵌套循环一遍，它的时间复杂度就是 $O(n^2)$ 了。</p><h5 id="立方阶-O-n-3-、K次方阶-O-n-k"><a href="#立方阶-O-n-3-、K次方阶-O-n-k" class="headerlink" title="立方阶$O(n^3)$、K次方阶$O(n^k)$"></a>立方阶$O(n^3)$、K次方阶$O(n^k)$</h5><p>参考上面的$O(n^2)$去理解就好了，$O(n^3)$相当于三层n循环，其它的类似。</p><h4 id="空间复杂度计算"><a href="#空间复杂度计算" class="headerlink" title="空间复杂度计算"></a>空间复杂度计算</h4><h5 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度$O(1)$"></a>空间复杂度$O(1)$</h5><p>如果算法执行所需要的临时空间不随着某个变量$n$的大小而变化，即此算法空间复杂度为一个常量，可表示为 $O(1)$。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$i = <span class="number">1</span>;</span><br><span class="line">$j = <span class="number">2</span>;</span><br><span class="line">++$i;</span><br><span class="line">$j++;</span><br><span class="line">$m = $i + $j;</span><br></pre></td></tr></table></figure><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 $S(n) = O(1)$。</p><h5 id="空间复杂度-O-n"><a href="#空间复杂度-O-n" class="headerlink" title="空间复杂度$O(n)$"></a>空间复杂度$O(n)$</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$m = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,.....,n);</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">1</span>; $i &lt;= $n; ++$i) &#123;</span><br><span class="line">   $j = $i;</span><br><span class="line">   $j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，第一行初始化一个数组出来，这个数据占用的大小为$n$，后面虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 $S(n) = O(n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压测工具—ab、webbench、siege</title>
      <link href="/2020/03/20/pressure-test-tools/"/>
      <url>/2020/03/20/pressure-test-tools/</url>
      
        <content type="html"><![CDATA[<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><h5 id="吞吐率（Requests-per-second）"><a href="#吞吐率（Requests-per-second）" class="headerlink" title="吞吐率（Requests per second）"></a>吞吐率（Requests per second）</h5><ul><li>概念：服务并发处理能力的量化描述，单位是 reqs/s，指的是<strong>某个并发用户数下单位时间内处理的请求数</strong>。某个并发用户数下单位时间内能处理的最大请求数，称之为<strong>最大吞吐率</strong>。</li><li>计算公式：总请求数 / 处理完成这些请求数所花费的时间，即：<br><code>Request per second = Complete requests / Time taken for tests</code></li></ul><h5 id="并发连接数（The-number-of-concurrent-connections）"><a href="#并发连接数（The-number-of-concurrent-connections）" class="headerlink" title="并发连接数（The number of concurrent connections）"></a>并发连接数（The number of concurrent connections）</h5><ul><li>概念：某个时刻服务器所接受的请求数目，简单的将，就是一个会话。</li></ul><h5 id="并发用户数（The-number-of-concurrent-users，Concurrency-Level）"><a href="#并发用户数（The-number-of-concurrent-users，Concurrency-Level）" class="headerlink" title="并发用户数（The number of concurrent users，Concurrency Level）"></a>并发用户数（The number of concurrent users，Concurrency Level）</h5><ul><li>概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。</li></ul><h5 id="用户平均请求等待时间（Time-per-request）"><a href="#用户平均请求等待时间（Time-per-request）" class="headerlink" title="用户平均请求等待时间（Time per request）"></a>用户平均请求等待时间（Time per request）</h5><ul><li>计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即：<br><code>Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</code></li></ul><h5 id="服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）"><a href="#服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）" class="headerlink" title="服务器平均请求等待时间（Time per request: across all concurrent requests）"></a>服务器平均请求等待时间（Time per request: across all concurrent requests）</h5><ul><li>计算公式：处理完成所有请求数所花费的时间 / 总请求数，即：<br><code>Time taken for / testsComplete requests</code><br>可以看到，它是吞吐率的倒数。<br>同时，它也=用户平均请求等待时间/并发用户数，即<br><code>Time per request / Concurrency Level</code></li></ul><a id="more"></a><h4 id="Apache-Bench"><a href="#Apache-Bench" class="headerlink" title="Apache Bench"></a>Apache Bench</h4><blockquote><p><a href="http://httpd.apache.org/docs/2.4/programs/ab.html" target="_blank" rel="noopener">ab</a>是Apache的超文本传输协议（HTTP）的性能测试工具，可以测试apache、IIs、tomcat、nginx 等服务器。但是 ab 没有 Jmeter、Loadrunner 那样有各种场景设计、各种图形报告和监控，只需一个命令即可，有输出描述，可以简单的进行一些压力测试。</p></blockquote><h5 id="查看Apache版本"><a href="#查看Apache版本" class="headerlink" title="查看Apache版本"></a>查看Apache版本</h5><p>Mac系统下自带 Apache，可以使用<code>apachectl -v</code>命令查看 Apache 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apachectl -v</span><br><span class="line">Server version: Apache/2.4.41 (Unix)</span><br><span class="line">Server built:   Dec 13 2019 19:06:00</span><br></pre></td></tr></table></figure><h5 id="查看ab版本"><a href="#查看ab版本" class="headerlink" title="查看ab版本"></a>查看ab版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ab -V</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br></pre></td></tr></table></figure><h5 id="查看当前系统的默认文件打开数"><a href="#查看当前系统的默认文件打开数" class="headerlink" title="查看当前系统的默认文件打开数"></a>查看当前系统的默认文件打开数</h5><p>在压测开始前，你需要确保你的<code>open files</code>足够大，否则会报<code>TOO MANY FILES OPEN</code>错误，可以通过<code>ulimit -a</code>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">max locked memory       (kbytes, -l) unlimited</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 256</span><br><span class="line">pipe size            (512 bytes, -p) 1</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 1392</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br></pre></td></tr></table></figure><p>设置打开文件数限制为 2560：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 2560</span><br></pre></td></tr></table></figure><blockquote><p>这只是临时修改，关闭终端会话后会复原。</p></blockquote><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><table><thead><tr><th>命令参数</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>请求次数</td></tr><tr><td>-c</td><td>并发数</td></tr><tr><td>-r</td><td>当接收到错误时，不要退出套接字（socket）</td></tr></tbody></table><h5 id="关于登陆的问题"><a href="#关于登陆的问题" class="headerlink" title="关于登陆的问题"></a>关于登陆的问题</h5><p>有时候进行压力测试需要用户登录，怎么办？<br>请参考以下步骤：</p><ol><li><p>先用账户和密码登录后，用开发者工具找到标识这个会话的 Cookie 值（Session ID）记下来</p></li><li><p>如果只用到一个 Cookie，那么只需键入命令：<br><code>ab －n 100 －C key＝value http://test.com/</code></p></li><li><p>如果需要多个 Cookie，就直接设 Header：<br><code>ab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” http://test.com/</code></p></li></ol><h4 id="webbench"><a href="#webbench" class="headerlink" title="webbench"></a>webbench</h4><p>webbench是一枚强大得可以的压力测试工具，它最多可以模拟3万个并发连接去测试网站的负载能力，个人感觉要比Apache自带的ab压力测试工具好，安装使用也特别方便。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">brew install ctags # 依赖安装</span><br><span class="line"></span><br><span class="line">wget http://blog.zyan.cc/soft/linux/webbench/webbench-1.5.tar.gz</span><br><span class="line">tar -zxvf webbench-1.5.tar.gz</span><br><span class="line">cd webbench-1.5</span><br><span class="line"></span><br><span class="line">mkdir -pv /usr/local/man/man1 # 必须</span><br><span class="line"></span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h5 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 10 秒内向 http://127.0.0.1:3001/admin 发送 500 次请求</span><br><span class="line">webbench -c 500 -t 10 http://127.0.0.1:3001/admin</span><br></pre></td></tr></table></figure><h4 id="siege"><a href="#siege" class="headerlink" title="siege"></a>siege</h4><p>siege是我解决ab该死的<code>apr_socket_recv: Connection reset by peer (54)</code>错误时发现的一个好工具，不得不说这工具真心好，用法和webbench一样，但是信息全面很多。</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install siege</span><br></pre></td></tr></table></figure><h5 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h5><table><thead><tr><th>压测参数</th><th>说明</th></tr></thead><tbody><tr><td>-C</td><td>在屏幕上打印显示出当前的配置,配置是包括在他的配置文件$HOME/.siegerc中,可以编辑里面的参数,这样每次siege 都会按照它运行</td></tr><tr><td>-v</td><td>运行时能看到详细的运行信息</td></tr><tr><td>-c</td><td>模拟有n个用户在同时访问,n不要设得太大,因为越大,siege消耗本地机器的资源越多</td></tr><tr><td>-r</td><td>重复运行测试n次,不能与-t同时存在</td></tr><tr><td>-t</td><td>持续运行siege ‘n’秒(如10S),分钟(10M),小时(10H)</td></tr><tr><td>-d</td><td>每个url之间的延迟,在0-n之间</td></tr><tr><td>-b</td><td>请求无需等待 delay=0</td></tr><tr><td>-i</td><td>随机访问urls.txt中的url列表项</td></tr><tr><td>-f</td><td>指定用特定的urls文件运行 ,默认为<code>urls.txt</code>,位于siege安装目录下的<code>etc/urls.txt</code></td></tr><tr><td>-R</td><td>指定用特定的siege 配置文件来运行,默认的为<code>$HOME/.siegerc</code></td></tr><tr><td>-l</td><td>运行结束,将统计数据保存到日志文件中<code>siege.log</code>,一般位于<code>/usr/local/var/siege.log</code>中,也可在.siegerc中自定义</td></tr></tbody></table><h5 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//并发10个,发生5次,共50个请求</span><br><span class="line">siege -c 10 -r 5 http://www.jd.com</span><br><span class="line"></span><br><span class="line">Transactions: 350 hits //总共测试次数</span><br><span class="line">Availability: 100.00 % //成功次数百分比</span><br><span class="line">Elapsed time: 4.27 secs //总共耗时多少秒</span><br><span class="line">Data transferred: 7.08 MB //总共数据传输</span><br><span class="line">Response time: 0.07 secs //等到响应耗时</span><br><span class="line">Transaction rate: 81.97 trans/sec //平均每秒处理请求数</span><br><span class="line">Throughput: 1.66 MB/sec //吞吐率</span><br><span class="line">Concurrency: 6.06 //最高并发</span><br><span class="line">Successful transactions: 350 //成功的请求数</span><br><span class="line">Failed transactions: 0 //失败的请求数</span><br><span class="line">Longest transaction: 0.24 //每次传输所花最长时间</span><br><span class="line">Shortest transaction: 0.01 //每次传输所花最短时间</span><br></pre></td></tr></table></figure><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 200个并发对http://www.google.com发送请求100次</span><br><span class="line">siege -c 200 -r 100 http://www.google.com</span><br><span class="line"></span><br><span class="line"># 在urls.txt中列出所有的网址</span><br><span class="line">siege -c 200 -r 100 -f urls.txt</span><br><span class="line"></span><br><span class="line"># 随机选取urls.txt中列出所有的网址</span><br><span class="line">siege -c 200 -r 100 -f urls.txt -i</span><br><span class="line"></span><br><span class="line"># delay=0，更准确的压力测试，而不是功能测试</span><br><span class="line">siege -c 200 -r 100 -f urls.txt -i -b</span><br><span class="line"></span><br><span class="line"># 指定http请求头 文档类型</span><br><span class="line">siege -H &quot;Content-Type:application/json&quot; -c 200 -r 100 -f urls.txt -i -b</span><br></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li>发送post请求时，url格式为<code>http://www.xxxx.com/ POST p1=v1&amp;p2=v2</code></li><li>如果url中含有空格和中文，要先进行url编码，否则siege发送的请求url不准确。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 80+版本，samesite cookie验证跨域问题</title>
      <link href="/2020/03/20/chrome-samesite-cookie/"/>
      <url>/2020/03/20/chrome-samesite-cookie/</url>
      
        <content type="html"><![CDATA[<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>网站登录时，本地前端代码请求线上后台不能正常登录，检查跨域不存在问题；<br>且网站线上登录正常，其他人本地登录也正常。</p><h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><ol><li><p>console中发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A cookie associated with a cross-site resource at http://192.168.5.23/ was set without the `SameSite` attribute. A future release of Chrome will only deliver cookies with cross-site requests if they are set with `SameSite=None` and `Secure`. You can review cookies in developer tools under Application&gt;Storage&gt;Cookies and see more details at https://www.chromestatus.com/feature/5088147346030592 and https://www.chromestatus.com/feature/5633521622188032.</span><br></pre></td></tr></table></figure></li><li><p>network请求中，Set-Cookie中发现黄色感叹号，提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this set-cookie didn&apos;t specify a &quot;SameSite&quot; attribute ......</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>Chrome 80 版本升级后，提升了<code>Cookie SameSite</code>的默认安全等级，强推<code>SameSite Cookie</code></p><table><thead><tr><th>chrome版本</th><th>默认值</th><th>cookie</th></tr></thead><tbody><tr><td>&lt;80</td><td>SameSite=None</td><td>请求带Cookie</td></tr><tr><td>&gt;=80</td><td>SameSite=Lax</td><td>请求限制带Cookie</td></tr></tbody></table><h4 id="什么是SameSite"><a href="#什么是SameSite" class="headerlink" title="什么是SameSite"></a>什么是SameSite</h4><p>SameSite 是 Chrome 51 版本为浏览器的 Cookie 新增的了一个属性， SameSite 阻止浏览器将此 Cookie 与跨站点请求一起发送。其主要目标是降低跨源信息泄漏的风险。同时也在一定程度上阻止了 CSRF（Cross-site request forgery 跨站请求伪造）。</p><p>Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险。</p><p>它可以设置三个值：</p><ul><li>Strict</li><li>Lax</li><li>None</li></ul><h5 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h5><p>Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: username=xxxxx; SameSite=Strict;</span><br></pre></td></tr></table></figure><h5 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h5><p>Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: username=xxxxx; SameSite=Lax;</span><br></pre></td></tr></table></figure><blockquote><p>设置了Strict或Lax以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p></blockquote><h5 id="None"><a href="#None" class="headerlink" title="None"></a>None</h5><p>网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。<br>下面的设置无效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: widget_session=xxxxx; SameSite=None</span><br></pre></td></tr></table></figure><p>下面的设置有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: widget_session=xxxxx; SameSite=None; Secure</span><br></pre></td></tr></table></figure><h4 id="本地调试解决办法"><a href="#本地调试解决办法" class="headerlink" title="本地调试解决办法"></a>本地调试解决办法</h4><p>将如下两项设置为Disabled，并重启浏览器：</p><ul><li><p><a href="chrome://flags/#same-site-by-default-cookies" target="_blank" rel="noopener">chrome://flags/#same-site-by-default-cookies</a></p></li><li><p><a href="chrome://flags/#cookies-without-same-site-must-be-secure" target="_blank" rel="noopener">chrome://flags/#cookies-without-same-site-must-be-secure</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vps 搭建ss</title>
      <link href="/2020/03/12/vps-shadowsocks/"/>
      <url>/2020/03/12/vps-shadowsocks/</url>
      
        <content type="html"><![CDATA[<h4 id="购买vps"><a href="#购买vps" class="headerlink" title="购买vps"></a>购买vps</h4><p>首先购买一台境外的vps服务器，<a href="https://www.bandwagonhost.net/" target="_blank" rel="noopener">搬瓦工</a>、<a href="https://www.vultr.com/" target="_blank" rel="noopener">vultr</a>等都还可以。</p><h4 id="搭建ss"><a href="#搭建ss" class="headerlink" title="搭建ss"></a>搭建ss</h4><p>ssh连接服务器之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><p>下载shadowsocks:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget –no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br></pre></td></tr></table></figure><a id="more"></a><p>获取shadowsocks.sh权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shadowsocks.sh</span><br></pre></td></tr></table></figure><p>执行安装shadowsocks：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p>之后按照提示输入 密码、端口号，选择加密方式<code>aes-256-cfb</code>，等待完成安装即可。</p><h4 id="使用Google-BBR加速上网"><a href="#使用Google-BBR加速上网" class="headerlink" title="使用Google BBR加速上网"></a>使用Google BBR加速上网</h4><p>下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br></pre></td></tr></table></figure><p>获取读写权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x bbr.sh</span><br></pre></td></tr></table></figure><p>安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure><p>接着按任意键，开始安装，坐等一会。安装完成一会之后它会提示我们是否重新启动vps，我们输入 <code>y</code> 确定重启服务器。</p><p>重新启动之后，输入 <code>lsmod | grep bbr</code> 如果看到 <code>tcp_bbr</code> 就说明 BBR 已经启动了。</p><blockquote><p>ps:貌似shadowsocks.sh已经安装了BBR，不用单独安装BBR了。</p></blockquote><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动：/etc/init.d/shadowsocks start</span><br><span class="line">停止：/etc/init.d/shadowsocks stop</span><br><span class="line">重启：/etc/init.d/shadowsocks restart</span><br><span class="line">状态：/etc/init.d/shadowsocks status</span><br><span class="line">配置文件路径：/etc/shadowsocks.json</span><br><span class="line">日志文件路径：/var/log/shadowsocks.log</span><br><span class="line">安装路径：/usr/local/shadowsocks/shadowsoks</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> GFW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT简介</title>
      <link href="/2020/03/12/mqtt-introduction/"/>
      <url>/2020/03/12/mqtt-introduction/</url>
      
        <content type="html"><![CDATA[<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一个基于客户端-服务器的消息发布/订阅传输协议。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>Mac：<code>brew install mosquitto</code></li><li>CentOS：<code>yum install mosquitto</code></li></ul><a id="more"></a><h4 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@c7-ehotel-liudf-201 ~]# mosquitto_sub -d -h 192.168.5.201 -p 1883 -u tcl -P tcl801 -t tv/marquee/0440001/103/520012518815</span><br><span class="line">Client mosqsub|30292-c7-ehotel sending CONNECT</span><br><span class="line">Client mosqsub|30292-c7-ehotel received CONNACK</span><br><span class="line">Client mosqsub|30292-c7-ehotel sending SUBSCRIBE (Mid: 1, Topic: tv/marquee/0440001/103/520012518815, QoS: 0)</span><br><span class="line">Client mosqsub|30292-c7-ehotel received SUBACK</span><br><span class="line">Subscribed (mid: 1): 0</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>-d: debug模式，输出详细的连接以及数据收发过程</li><li>-h: host</li><li>-p: port 端口</li><li>-u: user 用户名</li><li>-P: possword 密码</li><li>-t: topic 订阅主题</li></ul><p><code>sending SUBSCRIBE (Mid: 1, Topic: tv/marquee/0440001/103/520012518815, QoS: 0)</code>表示发送订阅请求:</p><ul><li>Mid是Message Id，从1开始计算，当一个连接发送多条消息时，Mid是递增的。</li><li>Topic 表示要订阅的主题时topic1。</li><li>QoS：0指定了QoS等级，默认是0。</li></ul><h4 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mosquitto_pub -d -h 192.168.5.201 -p 1883 -u tcl -P tcl801 -t tv/0440001/marquee -m &quot;Hello MQTT&quot;</span><br><span class="line">Client mosqpub|12796-SCNWCL012 sending CONNECT</span><br><span class="line">Client mosqpub|12796-SCNWCL012 received CONNACK (0)</span><br><span class="line">Client mosqpub|12796-SCNWCL012 sending PUBLISH (d0, q0, r0, m1, &apos;tv/0440001/marquee&apos;, ... (10 bytes))</span><br><span class="line">Client mosqpub|12796-SCNWCL012 sending DISCONNECT</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>-m 发送消息的内容</li><li>d0表示DUP为0，DUP是是否重复标记，如果是第一次发送消息，则设置为0。如果是重复投递，比如QoS设置为1，客户端发送消息超时后服务器还没有回复，客户端为确保消息能发出去，于是再发一次，这是DUP就设置为1，表明这个消息是重复发送的。</li><li>q0表示QoS为0。</li><li>r0表示RETAIN为0。RETAIN意思是是否要求Broker帮我保留这条消息，如果设置为1，则服务器会保留当前消息。当下一次有新的客户端连接并订阅topic1时，服务器自动发送这条保留的消息给客户端。</li><li>m1表示消息序号，默认从1开始。</li></ul><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><p>发布完消息后，再回到之前订阅的终端，会显示接收到的消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client mosqsub|30443-c7-ehotel received PUBLISH (d0, q0, r0, m0, &apos;tv/0440001/marquee&apos;, ... (10 bytes))</span><br><span class="line">Hello MQTT</span><br></pre></td></tr></table></figure><p>第一行显示收到PUBLISH数据包，第二行打印出接收到的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mqtt </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制反转 和 依赖注入</title>
      <link href="/2020/03/12/ioc-and-di/"/>
      <url>/2020/03/12/ioc-and-di/</url>
      
        <content type="html"><![CDATA[<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><strong>控制反转（IOC Inversion Of Control）</strong>：是一种思想，是一种是面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。<br>其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。我们一般称这个“第三方”为IOC容器</p><a id="more"></a><p><strong>依赖注入（DI Dependency Injection）</strong>：是控制反转最典型的实现方式。</p><h5 id="原理示例"><a href="#原理示例" class="headerlink" title="原理示例"></a>原理示例</h5><p>如果一个类A 的功能实现需要借助于类B，那么就称类B是类A的<strong>依赖</strong>，如果在类A的内部去实例化类B，那么两者之间会出现较高的<strong>耦合</strong>，一旦类B出现了问题，类A也需要进行改造，如果这样的情况较多，每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，<strong>程序会极难维护</strong>，并且很容易出现问题。要解决这个问题，就要把A类对B类的控制权抽离出来，交给一个第三方去做，把控制权反转给第三方，就称作<strong>控制反转（IOC Inversion Of Control）</strong>。<strong>控制反转是一种思想</strong>，是能够解决问题的一种可能的结果，而<strong>依赖注入（Dependency Injection）</strong>就是其最典型的实现方法。由第三方（我们称作<strong>IOC容器</strong>）来控制依赖，把他通过<strong>构造函数、属性或者工厂模式</strong>等方法，注入到类A内，这样就极大程度的对类A和类B进行了<strong>解耦</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v2ray + CDN + Nginx 拯救被墙IP</title>
      <link href="/2020/03/12/v2ray-cdn-nginx-GFW/"/>
      <url>/2020/03/12/v2ray-cdn-nginx-GFW/</url>
      
        <content type="html"><![CDATA[<p>由于GFW的原因，IP被封，所以只能另辟蹊径：</p><ul><li>v2ray是一个集成了各种科学上网协议的软件，包括socks（目前接触到的是本机到本机）、http、SS（目前接触到的是本机到远程）、vmess等，传输载体可以是tcp、mkcp、websocket等</li><li>使用websocket：因为cdn可以转发ws流量</li><li>使用https（tls）伪装网站，请求流量数据</li><li>使用cdn转发流量，同时作为连接vps的跳板，使vps复活和隐藏</li><li>使用nginx代理v2ray</li></ul><a id="more"></a><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul><li>一台vps (IP被墙，IP假设为：99.99.99.99)</li><li><a href="https://sg.godaddy.com/zh" target="_blank" rel="noopener">域名</a>：<a href="http://www.xyz.com" target="_blank" rel="noopener">www.xyz.com</a></li><li>免费cdn：<a href="https://www.cloudflare.com/zh-cn/" target="_blank" rel="noopener">cloudfare</a></li><li>相关知识：nginx配置，ssl配置，域名配置等</li></ul><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p>添加yum源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>相关服务命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设置开机启动</span><br><span class="line">systemctl enable nginx </span><br><span class="line"></span><br><span class="line">启动服务</span><br><span class="line">systemctl start nginx</span><br><span class="line"></span><br><span class="line">重启服务</span><br><span class="line">systemctl restart nginx</span><br><span class="line"></span><br><span class="line">重载服务</span><br><span class="line">systemctl reload nginx</span><br></pre></td></tr></table></figure><p>编辑配置文件：<br>相关配置文件位置<code>/etc/nginx/</code>下，替换server_name为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xyz.com www.xyz.com;</span><br></pre></td></tr></table></figure><p>然后启动nginx服务。</p><h4 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h4><p>申请免费https证书（Let’s Encrypt），先在域名注册商那里（GoDaddy）修改dns，添加两个a记录，解析到vps的ip 99.99.99.99，修改的原因是要向let‘s encrypt要发起挑战，证明你拥有这个域名。<br>下载certbot：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/certbot/certbot</span><br><span class="line">cd certbot</span><br></pre></td></tr></table></figure><p>生成免费证书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto certonly --webroot --agree-tos -v -t --email 邮箱地址 -w 网站根目录 -d 网站域名</span><br><span class="line">例如：</span><br><span class="line">./certbot-auto certonly --webroot --agree-tos -v -t --email liwen@163.com -w /usr/share/nginx/html -d www.xyz.com</span><br></pre></td></tr></table></figure><blockquote><p>注：生成过程中会自动生成 <code>/网站根目录/.well0known/acme-challenge</code>，然后脚本会挑战这个路径，所以需要保证这个地址能被访问，才能正常生成免费的证书。<br>为了保证能访问，需要开启nginx，同时，需要关闭dns（箭头不穿过小云朵）。</p></blockquote><p>生成的证书地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/letsencrypt/live/www.xyz.com/fullchain.pem</span><br><span class="line">......等等</span><br></pre></td></tr></table></figure><p>配置nginx证书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen 443</span><br><span class="line"></span><br><span class="line">ssl on;</span><br><span class="line">ssl_certificate /etc/letsencrypt/live/网站域名/fullchain.pem;</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/网站域名/privkey.pem;</span><br></pre></td></tr></table></figure><h4 id="cdn设置"><a href="#cdn设置" class="headerlink" title="cdn设置"></a>cdn设置</h4><p>设置完证书后，就可以设置cdn</p><p>注册cloudfare账号，选择一个免费站点</p><p>更换godaddy处的nameserver为cloudfare的nameserver，把解析工作转移给cloudfare</p><p>等待cloudfare网站变为active状态</p><h4 id="安装v2ray"><a href="#安装v2ray" class="headerlink" title="安装v2ray"></a>安装v2ray</h4><p>vps安装配置v2ray</p><p>安装v2ray：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 官方一键安装脚本</span><br><span class="line">bash &lt;(curl -l -s https://install.direct/go.sh)</span><br><span class="line">安装好后，会有v2ray运行的端口，和一个client的uuid port:26075 uuid:563a2749-ccfe-4754-959d-b8343faafeac （记住上述信息，并使用实际的更换）</span><br></pre></td></tr></table></figure><p>编辑配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/v2ray/config.json</span><br></pre></td></tr></table></figure><p>在inbound的最后（settings之后）追加如下配置，记住path路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;listen&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line"></span><br><span class="line">&quot;streamsettings&quot;: &#123;</span><br><span class="line">  &quot;network&quot;: &quot;ws&quot;,</span><br><span class="line">  &quot;wssettings&quot;: &#123;</span><br><span class="line">    &quot;path&quot;: &quot;/gotowork&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启v2ray：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart v2ray</span><br></pre></td></tr></table></figure><p>继续设置nginx：<br>继续设置nginx，反向代理到v2ray</p><p>编辑nginx配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 添加类似如下设置</span><br><span class="line">location /gotowork &#123; # 路径为上面的路径</span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_pass http://127.0.0.1:26075; # 端口要变成v2ray运行的端口</span><br><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header upgrade $http_upgrade;</span><br><span class="line">proxy_set_header connection &quot;upgrade&quot;;</span><br><span class="line">proxy_set_header host $http_host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><p>macos客户端选择v2rayx:<br><a href="https://github.com/cenmrev/v2rayx" target="_blank" rel="noopener">https://github.com/cenmrev/v2rayx</a><br>最终配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;routing&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;all_to_main&quot;,</span><br><span class="line">        &quot;domainStrategy&quot;: &quot;AsIs&quot;,</span><br><span class="line">        &quot;rules&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">                &quot;outboundTag&quot;: &quot;cdnv2ray&quot;,</span><br><span class="line">                &quot;port&quot;: &quot;0-65535&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;inbounds&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;listen&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">            &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">            &quot;settings&quot;: &#123;</span><br><span class="line">                &quot;ip&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">                &quot;auth&quot;: &quot;noauth&quot;,</span><br><span class="line">                &quot;udp&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;tag&quot;: &quot;socksinbound&quot;,</span><br><span class="line">            &quot;port&quot;: 1081</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;listen&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">            &quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">            &quot;settings&quot;: &#123;</span><br><span class="line">                &quot;timeout&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;tag&quot;: &quot;httpinbound&quot;,</span><br><span class="line">            &quot;port&quot;: 8001</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">        &quot;servers&quot;: [</span><br><span class="line">            &quot;8.8.8.8&quot;,</span><br><span class="line">            &quot;8.8.4.4&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;log&quot;: &#123;</span><br><span class="line">        &quot;error&quot;: &quot;/var/folders/95/q73tyvts04s_g3pddf07tfjw0000gn/T/cenmrev.v2rayx.log/error.log&quot;,</span><br><span class="line">        &quot;loglevel&quot;: &quot;warning&quot;,</span><br><span class="line">        &quot;access&quot;: &quot;/var/folders/95/q73tyvts04s_g3pddf07tfjw0000gn/T/cenmrev.v2rayx.log/access.log&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;outbounds&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;sendThrough&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;mux&quot;: &#123;</span><br><span class="line">                &quot;enabled&quot;: false,</span><br><span class="line">                &quot;concurrency&quot;: 8</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">            &quot;settings&quot;: &#123;</span><br><span class="line">                &quot;vnext&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;address&quot;: &quot;www.xyz.com&quot;, # 注意</span><br><span class="line">                        &quot;users&quot;: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;id&quot;: &quot;e4sdf75b-349b-43c6-hj98-9228f5fdfdsf3&quot;, # 注意</span><br><span class="line">                                &quot;alterId&quot;: 64,</span><br><span class="line">                                &quot;security&quot;: &quot;auto&quot;,</span><br><span class="line">                                &quot;level&quot;: 1</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        &quot;port&quot;: 443</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;tag&quot;: &quot;cdnv2ray&quot;,</span><br><span class="line">            &quot;streamSettings&quot;: &#123;</span><br><span class="line">                &quot;wsSettings&quot;: &#123;</span><br><span class="line">                    &quot;path&quot;: &quot;/gotowork&quot;, # 注意</span><br><span class="line">                    &quot;headers&quot;: &#123;&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;quicSettings&quot;: &#123;</span><br><span class="line">                    &quot;key&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;security&quot;: &quot;none&quot;,</span><br><span class="line">                    &quot;header&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;none&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;tlsSettings&quot;: &#123;</span><br><span class="line">                    &quot;allowInsecure&quot;: false,</span><br><span class="line">                    &quot;alpn&quot;: [</span><br><span class="line">                        &quot;http/1.1&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;serverName&quot;: &quot;www.xyz.com&quot;, # 注意</span><br><span class="line">                    &quot;allowInsecureCiphers&quot;: false</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;httpSettings&quot;: &#123;</span><br><span class="line">                    &quot;path&quot;: &quot;&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;kcpSettings&quot;: &#123;</span><br><span class="line">                    &quot;header&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;none&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;mtu&quot;: 1350,</span><br><span class="line">                    &quot;congestion&quot;: false,</span><br><span class="line">                    &quot;tti&quot;: 20,</span><br><span class="line">                    &quot;uplinkCapacity&quot;: 5,</span><br><span class="line">                    &quot;writeBufferSize&quot;: 1,</span><br><span class="line">                    &quot;readBufferSize&quot;: 1,</span><br><span class="line">                    &quot;downlinkCapacity&quot;: 20</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;tcpSettings&quot;: &#123;</span><br><span class="line">                    &quot;header&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;none&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;security&quot;: &quot;tls&quot;, # 注意</span><br><span class="line">                &quot;network&quot;: &quot;ws&quot; # 注意</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><p><a href="https://blog.sprov.xyz/2019/03/11/cdn-v2ray-safe-proxy/#i-9" target="_blank" rel="noopener">https://blog.sprov.xyz/2019/03/11/cdn-v2ray-safe-proxy/#i-9</a><br><a href="https://www.dazhuanlan.com/2019/10/04/5d962810eb6c8/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/10/04/5d962810eb6c8/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> v2ray </tag>
            
            <tag> GFW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞和非阻塞，同步和异步，并发和并行</title>
      <link href="/2020/03/12/io-concurrency-block/"/>
      <url>/2020/03/12/io-concurrency-block/</url>
      
        <content type="html"><![CDATA[<h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><p>阻塞和非阻塞，是针对用户进程（线程）的转态来说的。</p><ul><li><p>阻塞意味着用户进程（线程）被挂起，即让出CPU时间片，一直等待内核把数据准备好。</p></li><li><p>非阻塞意味着用户进程(线程)不会挂起，用户进程可以不断地主动去看数据是否准备好，仍可以占用CPU时间片执行其他工作。</p></li></ul><blockquote><p>阻塞IO和非阻塞IO，都是同步IO；都是用户进程（线程）从内核中把数据取走。</p></blockquote><a id="more"></a><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步和异步，是针对指令的执行顺序来说的。</p><ul><li><p>同步意味着发起调用后，没有得到结果之前，就不返回，自然也不能执行其他指令。</p></li><li><p>异步意味着调用发出后，调用方立刻返回，通过回调等措施拿到结果，这样调用方还可以执行其他指令。</p></li></ul><blockquote><p>同步和异步、阻塞和非阻塞，是针对不同主体而言的。</p></blockquote><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><p>并发和并行是两个非常容易混淆的概念。它们都可以表示两个或多个任务一起执行，但是偏重点有点不同。<br>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。<br>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。然而并行的偏重点在于”同时执行”。</p><ul><li><p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。<br><img src="https://www.zlf520.com.cn/storage/blog/ukFzT6ycunm9xzzhbJJRGj3u75kHDMvCMTldcLWX.png" alt></p></li><li><p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。<br><img src="https://www.zlf520.com.cn/storage/blog/FHbTbk8suVSWSOcyNkBDHPEJl4lvTgIOe5s0h1Oj.png" alt></p></li></ul><blockquote><p>严格意义上来说，并行的多个任务是真实的同时执行，而对于并发来说，这个过程只是交替的，一会运行任务一,一会儿又运行任务二，系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务是串行并发的，也会造成是多个任务并行执行的错觉。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker内部访问宿主机</title>
      <link href="/2020/03/12/docker-commit-out-host/"/>
      <url>/2020/03/12/docker-commit-out-host/</url>
      
        <content type="html"><![CDATA[<p>有时候需要在docker容器里访问宿主机提供的某些服务。如：容器里的应用需要访问宿主机的MySQL服务。</p><h5 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use your internal IP address or connect to the special DNS name host.docker.internal which will resolve to the internal IP address used by the host.</span><br></pre></td></tr></table></figure><ul><li><p>方法1：<br>宿主机执行<code>ifconfig</code>，找到docker0网卡对应的IP，可以使用这个IP来访问宿主机。</p></li><li><p>方法2：<br>docker 18.03加入了一个feature，在容器中可以通过 <code>host.docker.internal</code>来访问主机。</p></li></ul><a id="more"></a><h5 id="Docker-For-Mac没有docker0网桥的问题"><a href="#Docker-For-Mac没有docker0网桥的问题" class="headerlink" title="Docker For Mac没有docker0网桥的问题"></a>Docker For Mac没有docker0网桥的问题</h5><p>在使用 Docker 时，要注意平台之间实现的差异性，如 Docker For Mac 的实现和标准 Docker 规范有区别，Docker For Mac 的 <code>Docker Daemon</code> 是运行于<code>虚拟机 (xhyve)</code> 中的，而不是像 Linux 上那样作为进程运行于宿主机，因此 Docker For Mac 没有 docker0 网桥，不能实现 host 网络模式，host 模式会使 <code>Container</code> 复用 <code>Daemon</code> 的网络栈 (在 <code>xhyve 虚拟机</code>中)，而不是与 Host &gt;主机网络栈，这样虽然其它容器仍然可通过 xhyve 网络栈进行交互，但却不是用的 Host 上的端口 (在 Host 上无法访问)。<code>bridge 网络模式 -p 参数</code>不受此影响，它能正常打开 Host 上的端口并映射到 <code>Container</code> 的对应 <code>Port</code>。文档在这一点上并没有充分说&gt;明，容易踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CGI、FastCGI和PHP-FPM</title>
      <link href="/2020/01/19/php-base-knowledge/"/>
      <url>/2020/01/19/php-base-knowledge/</url>
      
        <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="静态请求"><a href="#静态请求" class="headerlink" title="静态请求"></a>静态请求</h4><p>在整个网站架构中，Web Server（如Apache）只是内容的分发者。举个栗子，如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。<br><img src="https://www.zlf520.com.cn/storage/blog/chwW3sRnxWkMLolFRJVNqEfBsa1W9SZe17HOX3kv.png" alt></p><a id="more"></a><h4 id="动态请求"><a href="#动态请求" class="headerlink" title="动态请求"></a>动态请求</h4><p>如果请求的是 index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。<br><img src="https://www.zlf520.com.cn/storage/blog/nS3h4saU5y2dOXZVlh6qWBBI7z6dQK9QYuRg2txB.png" alt></p><p>当Web Server收到 index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程。</p><p>接下来再引出这些概念，就好理解多了：</p><ul><li><p>CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。</p></li><li><p>FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。同样，SCGI 协议与 FastCGI 类似。</p></li><li><p>PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。 </p></li><li><p>PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。</p></li><li><p>Web Server：一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器，Web Application 一般指PHP、Java、Asp.net等应用程序。</p></li></ul><h3 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h3><h4 id="Module方式"><a href="#Module方式" class="headerlink" title="Module方式"></a>Module方式</h4><p>在了解 CGI 之前，我们先了解一下Web server 传递数据的另外一种方法：PHP Module加载方式。以 Apache 为例，在PHP Module方式中，是不是在 Apache 的配置文件 httpd.conf 中加上这样几句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 加入以下2句</span><br><span class="line">LoadModule php5_module D:/php/php5apache2_2.dll</span><br><span class="line">AddType application/x-httpd-php .php</span><br><span class="line"># 修改如下内容</span><br><span class="line">&lt;IfModule dir_module&gt;</span><br><span class="line">    DirectoryIndex index.php index.html</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>上面是 Windows 下安装php和apache环境后手动配置，在linux下源码安装大致是这样配置的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ./configure --with-mysql=/usr/local --with-apache=/usr/local/apache --enable-track-vars</span><br></pre></td></tr></table></figure><p>所以，这种方式，他们的共同本质都是用 LoadModule 来加载 php5_module，就是把php作为apache的一个子模块来运行。当通过web访问php文件时，apache就会调用php5_module来解析php代码。</p><p>那么php5_module是怎么来将数据传给php解析器来解析php代码的呢？答案是通过sapi。</p><p>我们再来看一张图，详细的说说apache 与 php 与 sapi的关系：<br><img src="https://www.zlf520.com.cn/storage/blog/Fu7efDqFl9SuOP355AHsVgvOzq5PsrWGJO6RKFRm.png" alt></p><p>从上面图中，我们看出了sapi就是这样的一个中间过程，SAPI提供了一个和外部通信的接口，有点类似于socket，使得PHP可以和其他应用进行交互数据（apache，nginx等）。php默认提供了很多种SAPI，常见的提供给apache和nginx的php5_module、CGI、FastCGI，给IIS的ISAPI，以及Shell的CLI。</p><p>所以，以上的apache调用php执行的过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apache -&gt; httpd -&gt; php5_module -&gt; sapi -&gt; php</span><br></pre></td></tr></table></figure><p>好了。apache与php通过php5_module的方式就搞清楚了吧！</p><p>这种模式将php模块安装到apache中，所以每一次apache结束请求，都会产生一条进程，这个进程就完整的包括php的各种运算计算等操作。<br>在上图中，我们很清晰的可以看到，apache每接收一个请求，都会产生一个进程来连接php通过sapi来完成请求，可想而知，如果一旦用户过多，并发数过多，服务器就会承受不住了。</p><p>而且，把mod_php编进apache时，出问题时很难定位是php的问题还是apache的问题。</p><h4 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h4><p>CGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php、perl、tcl等。</p><p>WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。仔细想想，你在PHP代码中使用的用户从哪里来的。</p><p>也就是说，CGI就是专门用来和 web 服务器打交道的。web服务器收到用户请求，就会把请求提交给cgi程序（如php-cgi），cgi程序根据请求提交的参数作应处理（解析php），然后输出标准的html语句，返回给web服服务器，WEB服务器再返回给客户端，这就是普通cgi的工作原理。</p><p>CGI的好处就是完全独立于任何服务器，仅仅是做为中间分子。提供接口给apache和php。他们通过cgi搭线来完成数据传递。这样做的好处了尽量减少2个的关联，使他们2变得更独立。</p><p>但是CGI有个蛋疼的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。</p><h4 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h4><p>从根本上来说，FastCGI是用来提高CGI程序性能的。类似于CGI，FastCGI也可以说是一种协议。</p><p>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行，并且接受来自其它网站服务器来的请求。</p><p>FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求，或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。<br><img src="https://www.zlf520.com.cn/storage/blog/1GtPlKMwAibZDRxN7bkXpAbAhjjRnYt7mBmlDCPt.png" alt><br>Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等)</p><p>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。</p><p>当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</p><p>FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。在CGI模式中，php-cgi在此便退出了。</p><h3 id="PHP-FPM介绍"><a href="#PHP-FPM介绍" class="headerlink" title="PHP-FPM介绍"></a>PHP-FPM介绍</h3><p>要了解PHP-FPM，就得先说说PHP-CGI。<br>PHP-CGI就是PHP实现的自带的FastCGI管理器。虽然是php官方出品，但是这丫的却一点也不给力，性能太差，而且也很麻烦不人性化，主要体现在：</p><ul><li><p>php-cgi变更php.ini配置后，需重启php-cgi才能让新的php-ini生效，不可以平滑重启。</p></li><li><p>直接杀死php-cgi进程，php就不能运行了。</p></li></ul><p>上面2个问题，一直让很多人病垢了很久，所以很多人一直还是在用 Module 方式。直到 2004年一个叫 Andrei Nigmatulin的屌丝发明了PHP-FPM ，这神器的出现就彻底打破了这种局面，这是一个PHP专用的 fastcgi 管理器，它很爽的克服了上面2个问题，而且，还表现在其他方面更表现强劲。</p><p>也就是说，PHP-FPM 是对于 FastCGI 协议的具体实现，他负责管理一个进程池，来处理来自Web服务器的请求。目前，PHP5.3版本之后，PHP-FPM是内置于PHP的。</p><p>因为PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度 php-cgi 进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。同样，PHP-FPM也是用于调度管理PHP解析器php-cgi的管理程序。</p><p>PHP-FPM通过生成新的子进程可以实现php.ini修改后的平滑重启。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php-fpm </tag>
            
            <tag> fast-cgi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL各存储引擎</title>
      <link href="/2020/01/19/mysql-engines/"/>
      <url>/2020/01/19/mysql-engines/</url>
      
        <content type="html"><![CDATA[<h5 id="查看MySQL支持的引擎："><a href="#查看MySQL支持的引擎：" class="headerlink" title="查看MySQL支持的引擎："></a>查看MySQL支持的引擎：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure><h5 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h5><ul><li>提供高速存储和检索，以及全文搜索能力</li><li>不支持事物。表级锁。不能再表损坏后恢复数据</li><li>适合查询频繁的情况</li></ul><a id="more"></a><h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h5><ul><li>具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。</li><li>基于聚簇索引建立，聚簇索引对主键查询有很高的性能。</li><li>支持事务和外键。行级锁。</li><li>适合在以下几种情况下使用：</li></ul><p>1.更新和查询都相当的频繁，多重并发<br>2.要求事务，或者可靠性要求比较高<br>3.外键约束，MySQL支持外键的存储引擎只有InnoDB</p><ul><li>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择</li></ul><h5 id="MEMORY（HEAP）引擎"><a href="#MEMORY（HEAP）引擎" class="headerlink" title="MEMORY（HEAP）引擎"></a>MEMORY（HEAP）引擎</h5><ul><li>数据保存在内存中，拥有极高的插入、更新和查询效率。但是不稳定，重启以后数据都会丢失。</li><li>不支持事务。支持表级锁，因此并发写入的性能较低。</li><li>支持长度不变的数据类型，不支持BLOB或TEXT长度可变的数据类型。</li><li>支持HASH索引和B-Tree索引，擎默认使用HASH索引。</li><li>在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制MEMORY表的大小。</li></ul><h5 id="ARCHIVE引擎"><a href="#ARCHIVE引擎" class="headerlink" title="ARCHIVE引擎"></a>ARCHIVE引擎</h5><ul><li>拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩。</li><li>支持最基本的插入和查询两种功能。在MySQL 5.5开始支持索引。</li><li>不支持事务。支持行级锁和专用的缓存区，所以可以实现高并发的插入。</li><li>适合存储大量日志、历史数据</li></ul><h5 id="BLACKHOLE引擎"><a href="#BLACKHOLE引擎" class="headerlink" title="BLACKHOLE引擎"></a>BLACKHOLE引擎</h5><ul><li>接受但不存储数据，但是如果MySQL启用了二进制日志，SQL语句被写入日志（并被复制到从服务器）。</li><li>用于做日志记录或同步归档的中继存储。但这种应用方式会碰到很多问题，因此并不推荐。</li><li>支持事务，而且支持mvcc的行级锁。</li></ul><h5 id="CSV引擎"><a href="#CSV引擎" class="headerlink" title="CSV引擎"></a>CSV引擎</h5><ul><li>每个表会生成一个.CSV文件，将CSV类型的文件当做表进行处理。</li><li>把数据以逗号分隔的格式存储在文本文件中，这种文件是一种普通文本文件，每个数据行占用一个文本行。</li><li>不支持索引，即使用该种类型的表没有主键列，也不允许表中的字段为null。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laradock 搭建 swoole + nginx 环境</title>
      <link href="/2020/01/19/laradock-swoole/"/>
      <url>/2020/01/19/laradock-swoole/</url>
      
        <content type="html"><![CDATA[<h4 id="安装docker和docker-compose"><a href="#安装docker和docker-compose" class="headerlink" title="安装docker和docker-compose"></a>安装docker和docker-compose</h4><p>相关安装步骤在此不再赘述，参考之前的笔记：<a href="https://liwengo.top/2019/12/24/docker-php-env/" target="_blank" rel="noopener">laradock搭建php环境</a>。</p><h4 id="安装配置laravel-s"><a href="#安装配置laravel-s" class="headerlink" title="安装配置laravel-s"></a>安装配置laravel-s</h4><p>简介：LaravelS是一个胶水项目，用于快速集成Swoole到Laravel或Lumen，然后赋予它们更好的性能、更多可能性。<br>项目地址：<a href="https://github.com/hhxsv5/laravel-s" target="_blank" rel="noopener">https://github.com/hhxsv5/laravel-s</a></p><p>相关安装要求请移步项目地址查看。</p><a id="more"></a><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ol><li><p>通过composer安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require &quot;hhxsv5/laravel-s:~3.6.0&quot; -vvv</span><br></pre></td></tr></table></figure></li><li><p>注册ServiceProvider<br>Laravel: 修改文件<code>config/app.php</code>，Laravel 5.5+支持包自动发现，你应该跳过这步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;providers&apos; =&gt; [</span><br><span class="line">    //...</span><br><span class="line">    Hhxsv5\LaravelS\Illuminate\LaravelSServiceProvider::class,</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li><li><p>发布配置和二进制文件</p><blockquote><p>每次升级LaravelS后，需重新publish。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php artisan laravels publish</span><br><span class="line"># 配置文件：config/laravels.php</span><br><span class="line"># 二进制文件：bin/laravels; bin/fswatch; bin/inotify</span><br></pre></td></tr></table></figure></li><li><p>修改配置<code>config/laravels.php</code>：监听的IP、端口等，请参<a href="https://github.com/hhxsv5/laravel-s/blob/master/Settings-CN.md" target="_blank" rel="noopener">考配置项</a>。</p></li></ol><h5 id="相关运行命令介绍"><a href="#相关运行命令介绍" class="headerlink" title="相关运行命令介绍"></a>相关运行命令介绍</h5><p>操作命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php bin/laravels &#123;start|stop|restart|reload|info|help&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>start</td><td>启动LaravelS，展示已启动的进程列表 `ps -ef</td></tr><tr><td>stop</td><td>停止LaravelS</td></tr><tr><td>restart</td><td>重启LaravelS，支持选项 `-d</td></tr><tr><td>reload</td><td>平滑重启所有Task/Worker/Timer进程(这些进程内包含了你的业务代码)，并触发自定义进程的<code>onReload</code>方法，不会重启Master/Manger进程；修改<code>config/laravels.php</code>后，你只能调用<code>restart</code>来实现重启</td></tr><tr><td>info</td><td>显示组件的版本信息</td></tr><tr><td>help</td><td>显示帮助信息</td></tr></tbody></table><h4 id="安装配置laradock"><a href="#安装配置laradock" class="headerlink" title="安装配置laradock"></a>安装配置laradock</h4><p>laradock采用多项目配置，让laradock和项目在同级目录，需要配置hosts。</p><h5 id="拉取laradock至代码同级目录"><a href="#拉取laradock至代码同级目录" class="headerlink" title="拉取laradock至代码同级目录"></a>拉取laradock至代码同级目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/laradock/laradock.git</span><br></pre></td></tr></table></figure><p>like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ laradock</span><br><span class="line">+ project-1</span><br><span class="line">+ project-2</span><br></pre></td></tr></table></figure><h5 id="复制env-example-为-env"><a href="#复制env-example-为-env" class="headerlink" title="复制env-example 为 .env"></a>复制env-example 为 .env</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp env-example .env</span><br></pre></td></tr></table></figure><h5 id="配置修改-env"><a href="#配置修改-env" class="headerlink" title="配置修改.env"></a>配置修改.env</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 修改docker源为aliyun</span><br><span class="line"># If you need to change the sources (i.e. to China), set CHANGE_SOURCE to true</span><br><span class="line">CHANGE_SOURCE=true</span><br><span class="line"></span><br><span class="line"># 修改composer源</span><br><span class="line">WORKSPACE_COMPOSER_REPO_PACKAGIST=https://packagist.phpcomposer.com</span><br><span class="line"># 修改node镜像地址</span><br><span class="line">WORKSPACE_NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</span><br><span class="line"></span><br><span class="line"># 修改npm源</span><br><span class="line">WORKSPACE_NPM_REGISTRY=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"># 不下载yarn，因为墙的原因，下载超时，yarn和npm一样。</span><br><span class="line">WORKSPACE_INSTALL_YARN=false</span><br><span class="line"></span><br><span class="line"># php-fpm 安装swoole</span><br><span class="line">WORKSPACE_INSTALL_SWOOLE=true</span><br><span class="line"></span><br><span class="line"># 修改时区</span><br><span class="line">WORKSPACE_TIMEZONE=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"># cli 安装swoole的PHP扩展</span><br><span class="line">PHP_FPM_INSTALL_SWOOLE=true</span><br><span class="line"></span><br><span class="line"># php-worker 安装swoole，supervisor守护进程在php-worker中，需要swoole</span><br><span class="line">PHP_WORKER_INSTALL_SWOOLE=true</span><br><span class="line"></span><br><span class="line"># 修改MySQL的版本为5.7，减少麻烦，并配置数据库相关配置，并同步配置到项目.env中</span><br><span class="line">MYSQL_VERSION=5.7</span><br><span class="line">MYSQL_DATABASE=xxxxx</span><br><span class="line">MYSQL_USER=laravels</span><br><span class="line">MYSQL_PASSWORD=xxxxx</span><br><span class="line">MYSQL_PORT=3306</span><br><span class="line">MYSQL_ROOT_PASSWORD=xxxxxx</span><br></pre></td></tr></table></figure><h5 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h5><p>参考：<a href="https://liwengo.top/2019/12/24/docker-php-env/" target="_blank" rel="noopener">laradock搭建php环境</a></p><h5 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h5><p>在<code>/xxx/www/laradock/nginx/sites</code>中新建<code>xxx.conf</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">upstream laravels &#123;</span><br><span class="line">    # Connect IP:Port</span><br><span class="line">    server php-worker:5200 weight=5 max_fails=3 fail_timeout=30s;</span><br><span class="line">    keepalive 16;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    </span><br><span class="line">    server_name laravels.com;</span><br><span class="line">    root /var/www/laravue/public;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line">    </span><br><span class="line">    # Nginx 处理静态资源，LaravelS 处理动态资源</span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri @laravels;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location @laravels &#123;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Connection &quot;&quot;;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Real-PORT $remote_port;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header Scheme $scheme;</span><br><span class="line">        proxy_set_header Server-Protocol $server_protocol;</span><br><span class="line">        proxy_set_header Server-Name $server_name;</span><br><span class="line">        proxy_set_header Server-Addr $server_addr;</span><br><span class="line">        proxy_set_header Server-Port $server_port;</span><br><span class="line">        proxy_pass http://laravels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps: <code>php-worker:5200</code> 是因为LaravelS的进程守护是在php-worker中，并监听5200端口。</p></blockquote><h5 id="配置php-worker"><a href="#配置php-worker" class="headerlink" title="配置php-worker"></a>配置php-worker</h5><p>在php-worker 中添加supervisor守护进程<br>路径：<code>/xxxxx/www/laradock/php-worker/supervisord.d/</code><br>新建laravel-s.conf，配置启动命令、用户、日志等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:laravel-s]</span><br><span class="line">command=php /var/www/laravue/bin/laravels start -i</span><br><span class="line">numprocs=1</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startretries=3</span><br><span class="line">user=root</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/var/www/laravue/storage/logs/supervisord-stdout.log</span><br></pre></td></tr></table></figure><blockquote><p>ps: 建议通过Supervisord监管主进程，前提是不能加<code>-d</code>选项并且设置<code>swoole.daemonize</code>为<code>false</code>。</p></blockquote><h5 id="项目-env配置"><a href="#项目-env配置" class="headerlink" title="项目.env配置"></a>项目.env配置</h5><p>在<code>.env</code>中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DB_CONNECTION=mysql </span><br><span class="line">DB_HOST=mysql # 注意</span><br><span class="line">DB_PORT=3306</span><br><span class="line">DB_DATABASE=xxx</span><br><span class="line">DB_USERNAME=laravels</span><br><span class="line">DB_PASSWORD=xxx</span><br><span class="line"></span><br><span class="line">REDIS_HOST=redis # 注意</span><br><span class="line">REDIS_PASSWORD=xxx</span><br><span class="line">REDIS_PORT=6379</span><br><span class="line"></span><br><span class="line">LARAVELS_LISTEN_IP=php-worker #LaravelS守护进程在php-worker中</span><br></pre></td></tr></table></figure><h5 id="构建并启动-Laradock-相关服务"><a href="#构建并启动-Laradock-相关服务" class="headerlink" title="构建并启动 Laradock 相关服务"></a>构建并启动 Laradock 相关服务</h5><p>在laradock目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d nginx mysql redis php-worker</span><br></pre></td></tr></table></figure><blockquote><p>ps：<code>php-fpm</code> 是 <code>nginx</code> 的 depends_on 依赖项，<code>workspace</code> 是 <code>php-fpm</code> 的依赖项，所以这两个容器会自动创建并启动，不需要写出来。<br>ps：启动后，可以通过<code>ps</code>查看进程运行情况，通过<code>docker logs</code>查看相关进程日志。</p></blockquote><h5 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h5><p>通过<code>docker-compose exec workspace bash</code>进入容器，配置项目，具体步骤见项目README.md。<br>一般如：<code>composer install</code>， <code>npm install</code> 等。</p><h5 id="配置hosts"><a href="#配置hosts" class="headerlink" title="配置hosts"></a>配置hosts</h5><p>在服务器中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 laravels.com</span><br></pre></td></tr></table></figure><p>本机中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx.xx.xx.xx laravels.com</span><br></pre></td></tr></table></figure><blockquote><p>ps：多项目必须配置hosts</p></blockquote><h5 id="ab压测"><a href="#ab压测" class="headerlink" title="ab压测"></a>ab压测</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 100 -c 100 http://laravels.com/ab_test</span><br></pre></td></tr></table></figure><p>自测为php-fpm的5到6倍。</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li>workspace 和 php-fpm 的区别<br>环境配置文件 .env 里包含相似的两块配置：workspace 和 php-fpm，它们对应两个不同的容器，一个是 FPM，一个是 CLI。不管是安装插件还是修改配置，都要分开修改。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> laradock </tag>
            
            <tag> swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 安装 php、nginx、MySQL8</title>
      <link href="/2020/01/06/docker-lnmp/"/>
      <url>/2020/01/06/docker-lnmp/</url>
      
        <content type="html"><![CDATA[<h5 id="1-安装php"><a href="#1-安装php" class="headerlink" title="1. 安装php"></a>1. 安装php</h5><p>拉取官方镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull php:7.2-fpm</span><br></pre></td></tr></table></figure><h5 id="2-安装nginx"><a href="#2-安装nginx" class="headerlink" title="2. 安装nginx"></a>2. 安装nginx</h5><p>拉取官方镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.17.1</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="3-部署nginx-php"><a href="#3-部署nginx-php" class="headerlink" title="3. 部署nginx+php"></a>3. 部署nginx+php</h5><p>启动php：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name myphp-fpm -v ~/nginx/www:/usr/share/nginx/html -d php:7.2-fpm</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>–name myphp-fpm : 将容器命名为 myphp-fpm。</li><li>-v ~/nginx/www:/usr/share/nginx/html : 将主机中项目的目录 www 挂载到容器的 /usr/share/nginx/html</li></ul><p>创建 ~/nginx/conf/conf.d 目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/nginx/conf/conf.d</span><br></pre></td></tr></table></figure><p>在该目录下添加 ~/nginx/conf/conf.d/xxxxx.conf 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  xxxxx.com.cn www.xxxxx.com.cn;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   php:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/html/$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件说明：</p><ul><li>php:9000: 表示 php-fpm 服务的 URL，下面我们会具体说明。</li><li>/usr/share/nginx/html/: 是 myphp-fpm 中 php 文件的存储路径，映射到本地的 ~/nginx/www 目录。</li></ul><p>启动nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name php-nginx -p 80:80 -d \ </span><br><span class="line">-v ~/nginx/www:/usr/share/nginx/html:ro \ </span><br><span class="line">-v ~/nginx/conf/conf.d:/etc/nginx/conf.d:ro \ </span><br><span class="line">--link myphp-fpm:php \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><ul><li>-p 80:80: 端口映射，把 nginx 中的 80 映射到本地的 80 端口。</li><li>~/nginx/www: 是本地 html 文件的存储目录，/usr/share/nginx/html 是容器内 html 文件的存储目录。</li><li>~/nginx/conf/conf.d: 是本地 nginx 配置文件的存储目录，/etc/nginx/conf.d 是容器内 nginx 配置文件的存储目录。</li><li>–link myphp-fpm:php: 把 myphp-fpm 的网络并入 nginx，并通过修改 nginx 的 /etc/hosts，把域名 php 映射成 127.0.0.1，让 nginx 通过 php:9000 访问 php-fpm。</li></ul><p>接下来就可以在~/nginx/www目录下创建php项目来访问</p><h5 id="4-安装MySQL"><a href="#4-安装MySQL" class="headerlink" title="4. 安装MySQL"></a>4. 安装MySQL</h5><p>拉取官方镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:8.0.16</span><br></pre></td></tr></table></figure><p>创建MySQL相关目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  ~/mysql/data ~/mysql/log ~/mysql/conf</span><br></pre></td></tr></table></figure><p>创建~/mysql/conf/my.cnf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">#</span><br><span class="line"># This program is free software; you can redistribute it and/or modify</span><br><span class="line"># it under the terms of the GNU General Public License as published by</span><br><span class="line"># the Free Software Foundation; version 2 of the License.</span><br><span class="line">#</span><br><span class="line"># This program is distributed in the hope that it will be useful,</span><br><span class="line"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="line"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><br><span class="line"># GNU General Public License for more details.</span><br><span class="line">#</span><br><span class="line"># You should have received a copy of the GNU General Public License</span><br><span class="line"># along with this program; if not, write to the Free Software</span><br><span class="line"># Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># The MySQL  Server configuration file.</span><br><span class="line">#</span><br><span class="line"># For explanations see</span><br><span class="line"># http://dev.mysql.com/doc/mysql/en/server-system-variables.html</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">pid-file        = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket          = /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">secure-file-priv= NULL</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line">lower_case_table_names=1</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line"># Custom config should go here</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br></pre></td></tr></table></figure><p>创建mysql8容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">--restart=always \</span><br><span class="line">--privileged=true \</span><br><span class="line">--name mysql8 \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=&quot;TRlmRw8xGqYM&quot; \</span><br><span class="line">-v /root/mysql/data:/var/lib/mysql:rw \</span><br><span class="line">-v /root/mysql/log:/var/log/mysql:rw \</span><br><span class="line">-v /root/mysql/conf/my.cnf:/etc/mysql/my.cnf:rw \</span><br><span class="line">-v /etc/localtime:/etc/localtime:ro \</span><br><span class="line">-d mysql:8.0.16</span><br></pre></td></tr></table></figure><p>相关命令：</p><ul><li><p>进入镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it mysql:8.0.16 /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>进入容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql8 /bin/sh</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> php </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 搭建 jenkins</title>
      <link href="/2020/01/06/docker-jenkins/"/>
      <url>/2020/01/06/docker-jenkins/</url>
      
        <content type="html"><![CDATA[<h4 id="几个可用的Jenkins-Docker镜像"><a href="#几个可用的Jenkins-Docker镜像" class="headerlink" title="几个可用的Jenkins Docker镜像"></a>几个可用的Jenkins Docker镜像</h4><p>建议使用的Docker映像是<a href="https://hub.docker.com/r/jenkinsci/blueocean/" target="_blank" rel="noopener">enkinsci/blueocean image</a>该镜像包含当前的长期支持 (LTS) 的Jenkins版本 （可以投入使用） ，捆绑了所有Blue Ocean插件和功能。这意味着你不需要单独安装Blue Ocean插件。</p><blockquote><p>jenkinsci/blueocean每次发布Blue Ocean新版本时，都会发布新镜像。您可以在 <a href="https://hub.docker.com/r/jenkinsci/blueocean/tags/" target="_blank" rel="noopener">标签</a>page页上看到以前发布的镜像版本列表 。</p></blockquote><blockquote><p>您还可以使用其他Jenkins Docker镜像（在Docker Hub上可通过<a href="https://hub.docker.com/r/jenkins/jenkins/" target="_blank" rel="noopener">enkins/jenkins</a>。 但是，这些不会随Blue Ocean的发布而提供，需要通过 Jenkins中的<a href="https://jenkins.io/zh/doc/book/managing/" target="_blank" rel="noopener">anage Jenkins</a> &gt; <a href="https://jenkins.io/zh/doc/book/managing/plugins" target="_blank" rel="noopener">Manage Plugins</a>页面进行安装。</p></blockquote><a id="more"></a><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li>打开一个终端窗口</li><li>下载 <code>jenkinsci/blueocean</code> 镜像并使用以下docker run 命令将其作为Docker中的容器运行 ：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -u root \</span><br><span class="line">  --rm \</span><br><span class="line">  -t \</span><br><span class="line">  -d \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -p 50000:50000 \</span><br><span class="line">  -v jenkins-data:/var/jenkins_home \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><code>--rm</code> (可选) jenkinsci/blueocean 关闭时自动删除Docker容器（下图为实例）。如果您需要退出Jenkins，这可以保持整洁。</p></li><li><p><code>-d</code>（可选）jenkinsci/blueocean 在后台运行容器（即“分离”模式）并输出容器ID。如果您不指定此选项， 则在终端窗口中输出正在运行的此容器的Docker日志。</p></li><li><p><code>-p 8080:8080</code> 映射（例如“发布”）jenkinsci/blueocean 容器的端口8080到主机上的端口8080。 第一个数字代表主机上的端口，而最后一个代表容器的端口。因此，如果您为此选项指定 -p 49000:8080 ，您将通过端口49000访问主机上的Jenkins。</p></li><li><p><code>-p 50000:50000</code>（可选）将 jenkinsci/blueocean 容器的端口50000 映射到主机上的端口50000。 如果您在其他机器上设置了一个或多个基于JNLP的Jenkins代理程序，而这些代理程序又与 jenkinsci/blueocean 容器交互（充当“主”Jenkins服务器，或者简称为“Jenkins主”）， 则这是必需的。默认情况下，基于JNLP的Jenkins代理通过TCP端口50000与Jenkins主站进行通信。 您可以通过“ 配置全局安全性” 页面更改Jenkins主服务器上的端口号。如果您要将您的Jenkins主机的JNLP代理端口的TCP端口 值更改为51000（例如），那么您需要重新运行Jenkins（通过此 docker run …​命令）并指定此“发布”选项 -p 52000:51000，其中最后一个值与Jenkins master上的这个更改值相匹配，第一个值是Jenkins主机的主机上的端口号， 通过它，基于JNLP的Jenkins代理与Jenkins主机进行通信 - 例如52000。</p></li><li><p><code>-v jenkins-data:/var/jenkins_home</code>（可选，但强烈建议）映射在容器中的<code>/var/jenkins_home</code> 目录到具有名字 jenkins-data 的volume。 如果这个卷不存在，那么这个 docker run 命令会自动为你创建卷。 如果您希望每次重新启动Jenkins（通过此 docker run … 命令）时保持Jenkins状态，则此选项是必需的 。 如果你没有指定这个选项，那么在每次重新启动后，Jenkins将有效地重置为新的实例。<br>注意: 所述的 jenkins-data 卷也可以 <code>docker volume create</code>命令创建： <code>docker volume create jenkins-data</code> 代替映射 <code>/var/jenkins_home</code> 目录转换为Docker卷，还 可以将此目录映射到计算机本地文件系统上的目录。 例如，指定该选项 <code>-v $HOME/jenkins:/var/jenkins_home</code> 会将容器的 /var/jenkins_home 目录映射 到 本地计算机上目录中的 jenkins 子目录， 该$HOME目录通常是 <code>/Users/&lt;your-username&gt;/jenkins</code> 或<code>/home/&lt;your-username&gt;/jenkins</code>。</p></li><li><p><code>-v /var/run/docker.sock:/var/run/docker.sock</code>（可选 /var/run/docker.sock 表示Docker守护程序通过其监听的基于Unix的套接字。 该映射允许 jenkinsci/blueocean 容器与Docker守护进程通信， 如果 jenkinsci/blueocean 容器需要实例化其他Docker容器，则该守护进程是必需的。 如果运行声明式管道，其语法包含agent部分用 docker<br>例如， agent { docker { … } } 此选项是必需的。 在Pipeline Syntax 页面上阅读更多关于这个的信息 </p></li><li><p>jenkinsci/blueocean Docker镜像本身。如果此镜像尚未下载，则此 docker run 命令 将自动为您下载镜像。此外，如果自上次运行此命令后发布了此镜像的任何更新， 则再次运行此命令将自动为您下载这些已发布的镜像更新。 注意：这个Docker镜像也可以使用以下 docker pull命令独立下载（或更新） ： <code>docker pull jenkinsci/blueocean</code></p></li></ul><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><ol><li>浏览到 IP:8080（或安装时为Jenkins配置的任何端口），并等待 解锁 Jenkins 页面出现。</li><li>进入Jenkins容器，<code>/var/jenkins_home/secrets/initialAdminPassword</code>文件下，找到Administrator密码。</li><li>之后安装插件，创建管理员用户，等，按照提示，一步一步操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清理docker</title>
      <link href="/2019/12/24/docker-clean/"/>
      <url>/2019/12/24/docker-clean/</url>
      
        <content type="html"><![CDATA[<p>经常使用docker，会发现docker占用资源膨胀的很快，所以，本文介绍如何清理docker占用的系统资源，具体说就是删除那些无用的镜像、容器、网络和数据卷。</p><h4 id="查看docker占用的资源"><a href="#查看docker占用的资源" class="headerlink" title="查看docker占用的资源"></a>查看docker占用的资源</h4><ul><li><code>docker container ls</code>：默认只列出正在运行的容器，-a 选项会列出包括停止的所有容器。</li><li><code>docker image ls</code>：列出镜像信息，-a 选项会列出 intermediate 镜像(就是其它镜像依赖的层)。</li><li><code>docker volume ls</code>：列出数据卷。</li><li><code>docker network ls</code>：列出 network。</li><li><code>docker info</code>：显示系统级别的信息，比如容器和镜像的数量等。</li></ul><a id="more"></a><p>通过这些命令查看 docker 使用的资源情况后，相信你已经决定要清理 docker 占用的一些资源了！让我们先从那些未被使用的资源开始。</p><h4 id="删除那些未被使用的资源"><a href="#删除那些未被使用的资源" class="headerlink" title="删除那些未被使用的资源"></a>删除那些未被使用的资源</h4><p>Docker 提供了方便的 <code>docker system prune</code> 命令来删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune</span><br></pre></td></tr></table></figure><p>安全起见，这个命令默认不会删除那些未被任何容器引用的数据卷，如果需要同时删除这些数据卷，你需要显式的指定 –volumns 参数。比如你可能想要执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune --all --force --volumes</span><br></pre></td></tr></table></figure><p>这次不仅会删除数据卷，而且连确认的过程都没有了！注意，使用 <code>--all</code> 参数后会删除所有未被引用的镜像而不仅仅是 dangling 镜像。</p><blockquote><p><code>dangling images</code>: 其实可以简单的理解为未被任何镜像引用的镜像。比如在你重新构建了镜像后，那些之前构建的且不再被引用的镜像层就变成了 dangling images。</p></blockquote><blockquote><p><code>intermediate 镜像</code>: 在本地的镜像更新之后，就会出现 <none> 镜像。这表示旧的镜像已经不再被引用了，此时它们就变成了 <code>dangling images</code>。如果使用 -a 参数，你还会发现另外一种类型的 <none> 镜像，它们的 repository 和 tag 列都表现为 <none>，这些镜像被称为 intermediate 镜像(就是其它镜像依赖的层)。</none></none></none></p></blockquote><p>我们还可在不同在子命令下执行 prune，这样删除的就是某类资源：<br><code>docker container prune</code> # 删除所有退出状态的容器<br><code>docker volume prune</code> # 删除未被使用的数据卷<br><code>docker image prune</code> # 删除 dangling 或所有未被使用的镜像</p><h4 id="清空docker"><a href="#清空docker" class="headerlink" title="清空docker"></a>清空docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune --all --force --volumns</span><br></pre></td></tr></table></figure><p>如果在执行这个命令前系统中所有的容器都已停止，那么这个命令就会移除所有的资源！好，现在让我们想办法停掉系统中的所有容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop</span><br></pre></td></tr></table></figure><p>该命令可以停止一个或多个容器，我们只需要把系统中所有在运行的容器罗列出来就可以了。<br>由于 docker 并不介意我们再次停止一个已经停止了的容器，干脆简单粗暴点，直接列出所有的容器(包括已经停止的)！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a -q</span><br></pre></td></tr></table></figure><ul><li>-a 显示所有的容器</li><li>-q 只显示数字形式的容器 ID</li></ul><p>然后把这里命令执行的结果作为 <code>docker container stop</code> 命令的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container ls -a -q)</span><br></pre></td></tr></table></figure><p>完整的恢复 docker 环境的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container ls -a -q) &amp;&amp; docker system prune --all --force --volumns</span><br></pre></td></tr></table></figure><p>和前面的 prune 命令类似，也可以完全删除某一类资源：<br>删除容器：<code>docker container rm $(docker container ls -a -q)</code><br>删除镜像：<code>docker image rm $(docker image ls -a -q)</code><br>删除数据卷：<code>docker volume rm $(docker volume ls -q)</code><br>删除 network：<code>docker network rm $(docker network ls -q)</code></p><h4 id="创建-shell-别名"><a href="#创建-shell-别名" class="headerlink" title="创建 shell 别名"></a>创建 shell 别名</h4><p>上面的命令可以完成任务但是却很繁琐，我们可以通过 shell 的别名功能来简化这些命令的执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias docker-clean-unused=&apos;docker system prune --all --force --volumes&apos;</span><br><span class="line">alias docker-clean-all=&apos;docker stop $(docker container ls -a -q) &amp;&amp; docker system prune --all --force --volumes&apos;</span><br></pre></td></tr></table></figure><p>把上面的命令写入到用户的 <code>~/.bashrc</code> 文件中就可以了！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laradock 搭建php环境</title>
      <link href="/2019/12/24/docker-php-env/"/>
      <url>/2019/12/24/docker-php-env/</url>
      
        <content type="html"><![CDATA[<h5 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. 安装docker</h5><p>移除旧版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><a id="more"></a><p>安装必要的系统工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>添加软件源信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>更新 yum 缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><p>安装 Docker-ce：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>启动 Docker 后台服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>安装docker-compose：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">也可以直接去官网下载相应版本</span><br><span class="line">https://github.com/docker/compose/releases</span><br><span class="line">然后重命名并修改权限</span><br></pre></td></tr></table></figure><h5 id="2-部署php环境"><a href="#2-部署php环境" class="headerlink" title="2. 部署php环境"></a>2. 部署php环境</h5><ol><li>克隆laradock<br>laradock 官方文档：<a href="http://laradock.io/" target="_blank" rel="noopener">http://laradock.io/</a><br>laradock github：<a href="https://github.com/laradock/laradock" target="_blank" rel="noopener">https://github.com/laradock/laradock</a></li></ol><p>Already have a PHP project: 在项目里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Laradock/laradock.git</span><br><span class="line">进入laradock:</span><br><span class="line">cp env-example .env</span><br></pre></td></tr></table></figure><p>Don’t have a PHP project yet: 和项目同级目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/laradock/laradock.git</span><br><span class="line">进入laradock：</span><br><span class="line">cp env-example .env</span><br><span class="line">修改为项目文件名称：</span><br><span class="line">APP_CODE_PATH_HOST=../project-z/</span><br></pre></td></tr></table></figure><ol start="2"><li>直接用 docker-compose 运行需要启用的服务：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d nginx mysql php-fpm</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-laravel-配置文件"><a href="#3-laravel-配置文件" class="headerlink" title="3. laravel 配置文件"></a>3. laravel 配置文件</h5><p>Laravel 配置文件需要注意的问题是，在 .env 文件中，mysql 和 redis 的地址需填写成这样，而不是 ip 地址形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DB_CONNECTION=mysql </span><br><span class="line">DB_HOST=mysql </span><br><span class="line">DB_PORT=3306 </span><br><span class="line">DB_DATABASE=xxxx</span><br><span class="line">DB_USERNAME=root </span><br><span class="line">DB_PASSWORD=root </span><br><span class="line"></span><br><span class="line">REDIS_HOST=redis </span><br><span class="line">REDIS_PASSWORD=null </span><br><span class="line">REDIS_PORT=6379</span><br></pre></td></tr></table></figure><h5 id="4-nginx配置"><a href="#4-nginx配置" class="headerlink" title="4. nginx配置"></a>4. nginx配置</h5><p>在laradock文件夹，nginx/sites/中配置*.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server ipv6only=on;</span><br><span class="line"></span><br><span class="line">    # For https</span><br><span class="line">    # listen 443 ssl default_server;</span><br><span class="line">    # listen [::]:443 ssl default_server ipv6only=on;</span><br><span class="line">    # ssl_certificate /etc/nginx/ssl/default.crt;</span><br><span class="line">    # ssl_certificate_key /etc/nginx/ssl/default.key;</span><br><span class="line"></span><br><span class="line">    server_name xxxxx.com www.xxxxx.com;</span><br><span class="line">    root /var/www/public;                   ### 注：root为容器内的路径</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         try_files $uri $uri/ /index.php$is_args$args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        try_files $uri /index.php =404;</span><br><span class="line">        fastcgi_pass php-upstream;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_buffers 16 16k;</span><br><span class="line">        fastcgi_buffer_size 32k;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        #fixes timeouts</span><br><span class="line">        fastcgi_read_timeout 600;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /\.ht &#123;</span><br><span class="line">        deny all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /.well-known/acme-challenge/ &#123;</span><br><span class="line">        root /var/www/letsencrypt/;</span><br><span class="line">        log_not_found off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx操作：<br>在laradock文件夹内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose restart nginx</span><br><span class="line">或者：</span><br><span class="line">docker-compose stop nginx</span><br><span class="line">docker-compose up -d nginx</span><br></pre></td></tr></table></figure><h5 id="5-执行composer"><a href="#5-执行composer" class="headerlink" title="5. 执行composer"></a>5. 执行composer</h5><p>执行 composer 等操作，需要进入到 workspace 容器中进行，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose exec workspace bash</span><br></pre></td></tr></table></figure><p>进入到 workspace 容器，就可以进行 compose 命令等操作了。<br>具体使用上的问题请参加 laradock 官方文档，上面都有说明。</p><h5 id="6-MySQL8修改验证方式"><a href="#6-MySQL8修改验证方式" class="headerlink" title="6. MySQL8修改验证方式"></a>6. MySQL8修改验证方式</h5><p>mysql 8.0 将密码验证方式由以前的 mysql_native_password 改为了 caching_sha2_password 。可以进入 mysql 容器 bash，登录 mysql ，将验证方式修改成原来的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#在laradock文件夹中执行：</span><br><span class="line">docker-compose exec mysql bash</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br><span class="line">mysql&gt; grant all PRIVILEGES on *.* to root@&apos;%&apos; WITH GRANT OPTION;</span><br><span class="line">mysql&gt; ALTER user &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;root&apos;; // 设置root远程登录</span><br><span class="line">mysql&gt; ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;root&apos;; // 设置root本地登录</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure><p>现在就可以用 root  登录了。为了使新建用户的验证方式默认为 mysql_native_password ，可以修改 my.cnf 文件，在 [mysqld] 部分中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_authentication_plugin = mysql_native_password</span><br></pre></td></tr></table></figure><h5 id="7-laradock-默认装的是-mysql-最新版本-mysql8-，也可以更换成低版本的-mysql"><a href="#7-laradock-默认装的是-mysql-最新版本-mysql8-，也可以更换成低版本的-mysql" class="headerlink" title="7. laradock 默认装的是 mysql 最新版本(mysql8)，也可以更换成低版本的 mysql"></a>7. laradock 默认装的是 mysql 最新版本(mysql8)，也可以更换成低版本的 mysql</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 修改 .env 文件</span><br><span class="line">MYSQL_VERSION=5.7 # 默认为 latest</span><br><span class="line"></span><br><span class="line">#停止mysql容器</span><br><span class="line">docker-compose stop mysql</span><br><span class="line"></span><br><span class="line"># 删除旧数据库数据</span><br><span class="line">rm -rf ~/.laradock/data/mysql</span><br><span class="line"></span><br><span class="line"># 重新构建新 mysql</span><br><span class="line">docker-compose build mysql</span><br><span class="line"></span><br><span class="line"> # 重新创建容器</span><br><span class="line">docker-compose up -d nginx mysql</span><br><span class="line"></span><br><span class="line"># 查看现有 mysql 版本</span><br><span class="line">docker inspect laradock_mysql_1</span><br><span class="line"></span><br><span class="line"># 修改MySQL密码</span><br><span class="line">mysql&gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;123&apos;;</span><br><span class="line">或者</span><br><span class="line">mysql&gt; USE mysql;</span><br><span class="line">mysql&gt; UPDATE user SET authentication_string=PASSWORD(&quot;NEWPASSWORD&quot;) WHERE User=&apos;root&apos;;</span><br></pre></td></tr></table></figure><h5 id="8-添加Redis配置"><a href="#8-添加Redis配置" class="headerlink" title="8. 添加Redis配置"></a>8. 添加Redis配置</h5><p>去修改 redis 的配置的时候，才发现默认安装的时候并没有添加 redis 的配置。所以重装配置下：<br>修改<code>laradock/redis/Dockerfile</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM redis:latest</span><br><span class="line"></span><br><span class="line">LABEL maintainer=&quot;Mahmoud Zalt &lt;mahmoud@zalt.me&gt;&quot;</span><br><span class="line"></span><br><span class="line">## For security settings uncomment, make the dir, copy conf, and also start with the conf, to use it</span><br><span class="line">RUN mkdir -p /usr/local/etc/redis</span><br><span class="line">COPY redis.conf /usr/local/etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">VOLUME /data</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line"></span><br><span class="line">CMD [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;]</span><br><span class="line">#CMD [&quot;redis-server&quot;]</span><br></pre></td></tr></table></figure><p>编辑配置文件:<br>默认情况 <code>redis</code> 目录下有 <code>redis.conf</code> 文件，修改以下两点即可</p><ol><li>注释 <code>bind 127.0.0.1</code></li><li><code>protected-mode</code> 改为 <code>no</code><br>其他配置根据自己情况进行修改。</li></ol><p>重装 redis:</p><ol><li>切换到 <code>laradock</code> 目录</li><li>停止redis <code>docker-compose stop redis</code></li><li>重装 <code>docker-compose build --no-cache redis</code></li><li>启动 <code>docker-compose up -d redis</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置环境变量PATH 和 查看PATH</title>
      <link href="/2019/11/14/mac-env-path/"/>
      <url>/2019/11/14/mac-env-path/</url>
      
        <content type="html"><![CDATA[<h4 id="理论篇"><a href="#理论篇" class="headerlink" title="理论篇"></a>理论篇</h4><p>Mac系统的环境变量，加载顺序为：<br><code>/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc</code></p><ul><li>/etc/profile和/etc/paths是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。</li><li>后面3个按照从前往后的顺序读取，如果/.bash_profile文件存在，则后面的几个文件就会被忽略不读了，如果/.bash_profile文件不存在，才会以此类推读取后面的文件。</li><li>~/.bashrc没有上述规则，它是bash shell打开的时候载入的。</li></ul><p>PATH的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#中间用冒号隔开</span><br><span class="line">export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="上述文件的科普"><a href="#上述文件的科普" class="headerlink" title="上述文件的科普"></a>上述文件的科普</h5><ul><li><p>/etc/paths （全局建议修改这个文件 ）<br>编辑 paths，将环境变量添加到 paths文件中 ，一行一个路径<br>Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。</p></li><li><p>/etc/profile （建议不修改这个文件 ）<br>全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</p></li><li><p>/etc/bashrc （一般在这个文件中添加系统级环境变量）<br>全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。</p></li><li><p>~/.profile 文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置<br>使用注意：如果你有对/etc/profile有修改的话必须得重启你的修改才会生效，此修改对每个用户都生效。</p></li><li><p>~/.bashrc 每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.<br>使用注意：对所有的使用bash的用户修改某个配置并在以后打开的bash都生效的话可以修改这个文件，修改这个文件不用重启，重新打开一个bash即可生效。</p></li><li><p><del>/.bash_profile 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）<br>使用注意：需要需要重启才会生效，/etc/profile对所有用户生效，</del>/.bash_profile只对当前用户生效。</p></li></ul><p><code>source ~/.bash_profile</code> 或者 <code>~/.profile</code> 环境信息生效</p><h4 id="操作篇"><a href="#操作篇" class="headerlink" title="操作篇"></a>操作篇</h4><h5 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h5><ol><li><p>创建一个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/paths.d/mysql</span><br></pre></td></tr></table></figure></li><li><p>用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/paths.d/mysql</span><br></pre></td></tr></table></figure></li><li><p>编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/MAMP/Library/bin</span><br></pre></td></tr></table></figure></li><li><p>source 相应的文件 生效配置环境</p></li></ol><blockquote><p>该mac的mysql环境变量配置方法如下：<br>创建软连接至/usr/local/bin环境变量目录<br><code>sudo ln -s /Applications/MAMP/Library/bin/mysql /usr/local/bin/mysql</code></p></blockquote><p>注：</p><blockquote><p>Mac的这个bin目录，是一个已经包含在环境变量里的目录，程序放在里面或者链接到里面就可以在终端里直接执行。</p></blockquote><blockquote><p>Mac的usr/bin目录是不允许增删文件的，可以通过向usr/local/bin增删文件来实现在终端里直接运行，往后者里面增删文件只要有管理员权限就可以了。</p></blockquote><h5 id="单个环境变量设置"><a href="#单个环境变量设置" class="headerlink" title="单个环境变量设置"></a>单个环境变量设置</h5><ol><li><p>vim ~/.bash_profile （任意一个文件中添加用户级环境变量）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 第一个是PHP地址；第二个是nginx地址</span><br><span class="line">export PATH=&quot;/Applications/MAMP/bin/php/php7.3.1/bin:/Applications/MAMP/Library/sbin:$PATH&quot;</span><br></pre></td></tr></table></figure></li><li><p>source ~/.bash_profile 生效</p></li></ol><h5 id="查看PATH"><a href="#查看PATH" class="headerlink" title="查看PATH"></a>查看PATH</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SSHFS 将远程文件挂载到本地</title>
      <link href="/2019/11/14/mac-sshfs-to-local/"/>
      <url>/2019/11/14/mac-sshfs-to-local/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SSHFS允许您使用SFTP安装远程文件系统。 大多数SSH服务器默认支持并启用此SFTP访问，因此SSHFS使用起来非常简单，服务器端无需执行任何操作。</p></blockquote><p>在MacOS中使用SSHFS需要FUSE的支持</p><blockquote><p>用于 macOS 的 FUSE 允许您通过第三方文件系统扩展 macOS 的本地文件处理功能。 它是 MacFUSE 的继任者，已被许多产品用作软件构建块，但不再维护;</p></blockquote><a id="more"></a><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li><p>下载安装<br>从 <a href="https://osxfuse.github.io/" target="_blank" rel="noopener">官网</a>下载最新版的 <code>FUSE for macOS</code> 和 <code>SSHFS</code> 直接安装。<br>下载速度较慢，以存放至百度云备用</p></li><li><p>HomeBrew安装 (安装太慢，不推荐)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install osxfuse</span><br><span class="line">$ brew cask install sshfs</span><br></pre></td></tr></table></figure></li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>新建本地挂载点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir local-file</span><br></pre></td></tr></table></figure><p>挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sshfs user@hostname:/absolute/path/to/document local-file</span><br></pre></td></tr></table></figure><p>远程的地址最好使用绝对路径。此时打开该文件夹就可以访问远程文件了。</p><p>卸载挂载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umount local-file</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sshfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置https 和 HTTP2</title>
      <link href="/2019/11/14/linux-https-http2/"/>
      <url>/2019/11/14/linux-https-http2/</url>
      
        <content type="html"><![CDATA[<h4 id="配置ssl证书"><a href="#配置ssl证书" class="headerlink" title="配置ssl证书"></a>配置ssl证书</h4><ul><li>证书说明：这里使用的证书是阿里云个人一年免费的SSL证书，只需要在阿里云上申请即可获得。</li><li>web服务器说明：这里采用的web服务器是Nginx服务器。</li><li>服务器操作系统说明：这里使用的是Centos 7.x系统。</li><li>终端登陆工具与FTP工具说明：这里使用的是Xshell与Xftp工具。</li></ul><a id="more"></a><h5 id="下载证书"><a href="#下载证书" class="headerlink" title="下载证书"></a>下载证书</h5><p>登陆到阿里云控制台，今天证书安全下载界面，选择<code>Nginx/Tengine</code>，下载证书，并解压到桌面。<br><img src="https://www.zlf520.com.cn/storage/blog/Cc8uxSDFty7vf857CBcHcRX6qj268IbpNfV0jgqu.png" alt></p><h5 id="上传证书到服务器"><a href="#上传证书到服务器" class="headerlink" title="上传证书到服务器"></a>上传证书到服务器</h5><ol><li><p>登陆到服务器，并进入到Nginx目录:<br><img src="https://www.zlf520.com.cn/storage/blog/GwBdGbsYz5QkUFuSarct1sWkLM7qrZzeeRx9Q9sH.png" alt></p></li><li><p>创建证书存放目录:<br><img src="https://www.zlf520.com.cn/storage/blog/a3sxQ00UIzTsqUmdi56AUbyvcqH0YdEuAozVpqMZ.png" alt></p></li><li><p>使用Xftp将证书上传至新建的目录下:<br><img src="https://www.zlf520.com.cn/storage/blog/vmVT7mm0gtTjNPxJlmGoz82RaGGl4yRcfbmW4D47.png" alt></p></li></ol><h5 id="配置Nginx使其支持SSL证书"><a href="#配置Nginx使其支持SSL证书" class="headerlink" title="配置Nginx使其支持SSL证书"></a>配置Nginx使其支持SSL证书</h5><ol><li><p>进入nginx下的conf.d目录，创建一个新的.conf文件，命名为ssl.域名.conf(命名可任意，但需以.conf结尾)。<br><img src="https://www.zlf520.com.cn/storage/blog/GosPIFgAZykmzYWMLA1QCcDjS25RglkVH3R3A4A9.png" alt></p></li><li><p>为新建的.conf文件添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    </span><br><span class="line">    # 修改为你的域名</span><br><span class="line">    server_name 域名.com www.域名.com;</span><br><span class="line">    </span><br><span class="line">    ssl on;</span><br><span class="line">    </span><br><span class="line">    # root目录，即为你网站的存放目录</span><br><span class="line">    root /mnt/www/域名.com/public_html/wordpress/;</span><br><span class="line">    </span><br><span class="line">    index index.html index.htm index.php;</span><br><span class="line">    </span><br><span class="line">    # 将下面两行修改为SSL证书存放路径</span><br><span class="line">    ssl_certificate /etc/nginx/ssl/域名.com/214190949470644.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/域名.com/214190949470644.key;</span><br><span class="line">    </span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    </span><br><span class="line">    # 以下为Nginx的基本配置</span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        include fastcgi.conf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://www.zlf520.com.cn/storage/blog/QlZBwJNlyAQIuXOVFCt7yrMi54WCj1mVmGJH6RwF.png" alt></p><ol start="3"><li>测试下配置的正确性，成功后重启下Nginx，再打开浏览器测试HTTPS是否能正常访问。<br><img src="https://www.zlf520.com.cn/storage/blog/uZgeTIjbMemc3TV8ExCwVsUHKXO2hqHgiM6FZYBT.png" alt></li></ol><blockquote><p>另外说明：可以看到目前conf.d目录里有3个以.conf结尾的配置文件，basic.conf为基本的解析配置文件；域名.conf为不使用SSL证书的http配置文件；ssl.域名.com为新增加的使用SSL证书的HTTPS配置文件。因此，在目前未配置301重定向的情况下，打开浏览器测试网站的时候，可以发现网站即可正常访问http,也可以正常访问https。</p></blockquote><h4 id="为Nginx配置301重定向"><a href="#为Nginx配置301重定向" class="headerlink" title="为Nginx配置301重定向"></a>为Nginx配置301重定向</h4><p>说明：在上面说了，目前网站的状态应该是http和https都可以正常访问。现在则为Nginx配置一下301重定向，这样当访问网站的时候就会自动定向到https,而不会在通过http访问网站了。</p><ol><li><p>进入Nginx配置目录，打开http的配置文件<br><img src="https://www.zlf520.com.cn/storage/blog/bzyoEZAYkuh6nJU1RdEtgfKzmhvsBzUwPsP7uqGj.png" alt></p></li><li><p>编辑域名.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    # 将“域名”改为你自己的域名</span><br><span class="line">    server_name 域名.com www.域名.com;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：这里编辑的是域名.conf，而不是ssl.域名.conf！！！</strong><br><img src="https://www.zlf520.com.cn/storage/blog/fZVHThVr5a4w6TNMgqfRAAMJmdRrVohrIwyqWIf4.png" alt></p><ol start="3"><li>重启Nginx，打开浏览器测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure></li></ol><p>配置至此，网站已经只会再通过https访问了，但是仍然还不会使用http2.0协议.</p><h4 id="配置HTTP2"><a href="#配置HTTP2" class="headerlink" title="配置HTTP2"></a>配置HTTP2</h4><h5 id="查看网站协议"><a href="#查看网站协议" class="headerlink" title="查看网站协议"></a>查看网站协议</h5><p>打开浏览器，将审查元素打开，点击Network选项卡，将Protocol调出来，查看传输协议。目前显示的为http/1.1，传输协议。<br><img src="https://www.zlf520.com.cn/storage/blog/yVivQ4sxWxIraR0vR5uzJorUWBxQHrB0w6ngN7cU.png" alt></p><h5 id="查看Nginx版本，查看OpenSSL版本"><a href="#查看Nginx版本，查看OpenSSL版本" class="headerlink" title="查看Nginx版本，查看OpenSSL版本"></a>查看Nginx版本，查看OpenSSL版本</h5><p>目前显示的版本是nginx/1.10.2，OpenSSL 1.0.1e-fips，因为之前安装Nginx时，使用的时系统默认的源，然而Centos7自带的Nginx版本并不够新，想要支持使用http2.0协议，OpenSS必须升级到2.0版本以上才可以。因此要对Nginx重新编译。<br><img src="https://www.zlf520.com.cn/storage/blog/EIYZ0xb19Lhe4hXbvDOKXER5IoV4JbgF7rHieexn.png" alt></p><h5 id="编译安装Nginx和openssl"><a href="#编译安装Nginx和openssl" class="headerlink" title="编译安装Nginx和openssl"></a>编译安装Nginx和openssl</h5><ol><li><p>安装编译过程中需要使用的工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget curl perl gcc pcre-devel zlib-devel make -y</span><br></pre></td></tr></table></figure></li><li><p>下载Nginx源和openssl源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//下载openssl新版的源和Nginx新版源</span><br><span class="line">wget https://www.openssl.org/source/openssl-1.0.2l.tar.gz http://nginx.org/download/nginx-1.11.10.tar.gz</span><br><span class="line"></span><br><span class="line">//解压两个压缩包</span><br><span class="line">tar zxvf nginx-1.11.10.tar.gz</span><br><span class="line">tar zxvf openssl-1.0.2l.tar.gz</span><br><span class="line"></span><br><span class="line">//重命名nginx和openssl</span><br><span class="line">mv nginx-1.11.10/ nginx</span><br><span class="line">mv openssl-1.0.2l/ openssl</span><br></pre></td></tr></table></figure></li><li><p>编译nginx</p></li></ol><ul><li><p>首先卸载原先版本的额nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove nginx -y</span><br></pre></td></tr></table></figure></li><li><p>配置编译nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//进入nginx和openssl所在目录。</span><br><span class="line">cd ~</span><br><span class="line">//将nginx和openssl移动到/usr/local/src文件夹</span><br><span class="line">mv nginx/ openssl/ /usr/local/src/</span><br><span class="line"></span><br><span class="line">//进入/etc/local/src/nginx目录下</span><br><span class="line">cd /usr/local/src/nginx</span><br><span class="line"></span><br><span class="line">//配置nginx</span><br><span class="line">./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_stub_status_module --with-http_auth_request_module --with-threads --with-stream --with-stream_ssl_module --with-http_slice_module --with-mail --with-mail_ssl_module --with-file-aio --with-http_v2_module --with-stream_realip_module --with-openssl=/usr/local/src/openssl</span><br><span class="line"></span><br><span class="line">//使用make命令编译一下,时间较长</span><br><span class="line">make</span><br><span class="line">//编译完成后执行下make insatll</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">//为新编译的nginx添加用户，创建配置目录</span><br><span class="line">useradd nginx &amp;&amp; mkdir /etc/nginx/conf.d</span><br><span class="line"></span><br><span class="line">//创建nginx缓存目录，并设置一些权限</span><br><span class="line">mkdir /var/cache/nginx &amp;&amp; chown nginx:root /var/cache/nginx</span><br><span class="line"></span><br><span class="line">//删除用不着的文件</span><br><span class="line">rm -rf /usr/local/src/nginx &amp;&amp; rm -rf /usr/local/src/openssl &amp;&amp; rm -rf /var/cache/yum</span><br></pre></td></tr></table></figure></li><li><p>继续配置nginx，并启动它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//配置nginx服务文件</span><br><span class="line">vim /usr/lib/systemd/system/nginx.service</span><br><span class="line"></span><br><span class="line">//为nginx.service添加配置代码</span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network-online.target remote-fs.target nss-lookup.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">ExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.conf</span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">//启动下nginx，再设置开机启动</span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl enable nginx</span><br><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure></li><li><p>编辑nginx.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//进入nginx目录</span><br><span class="line">cd /etc/nginx/</span><br><span class="line"></span><br><span class="line">//为nginx.conf添加代码</span><br><span class="line">vim nginx.conf</span><br><span class="line"></span><br><span class="line">//在nginx.conf中的gzip on代码下面一行添加如下代码</span><br><span class="line">include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">//重启nginx</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure></li></ul><h5 id="配置http2-0协议"><a href="#配置http2-0协议" class="headerlink" title="配置http2.0协议"></a>配置http2.0协议</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//编辑ssl.域名.conf文件</span><br><span class="line">vim ssl.域名.conf</span><br><span class="line"></span><br><span class="line">//在第一行listen配置项中添加 ssl http2</span><br><span class="line">server &#123;</span><br><span class="line">listen 443 ssl http2;</span><br><span class="line">.....见第一篇中的.conf配置文件</span><br><span class="line"></span><br><span class="line">//重启nginx</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p><img src="https://www.zlf520.com.cn/storage/blog/uEY7Iz2l1g7bLfDWJ8gfxvIVbHlgAgNFYtCYzZCC.png" alt></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>至此，http2.0协议配置完成，打开浏览器查看传输协议。<br><img src="https://www.zlf520.com.cn/storage/blog/CEyJxd4I0HYEdzJxkCX0hPjxGVDzn9yA5IBlKusx.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10+Ubuntu17.04双系统安装</title>
      <link href="/2019/11/14/linux-two-system/"/>
      <url>/2019/11/14/linux-two-system/</url>
      
        <content type="html"><![CDATA[<ol><li>本教程默认已安装win10，即是在win10正常使用基础上进行的</li><li>本教程自动忽略虚拟机和wubi安装，隔靴搔痒而已，毋庸置疑最好的方式还是u盘安装</li><li>本教程同样适用于Win10+Ubuntu16.04LTS，亲测一样成功</li><li>本教程全部图片来自网络（自己太懒并没有截图，只为讲述教程进行中的画面，因此图仅供参考）</li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>Ubuntu系统的的ISO、UltraISO、EasyBCD、U盘</p><a id="more"></a><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h5><h5 id="创建磁盘分区"><a href="#创建磁盘分区" class="headerlink" title="创建磁盘分区"></a>创建磁盘分区</h5><ol><li><p>按住<code>Win + X</code>，选择“磁盘管理”<br><img src="https://www.zlf520.com.cn/storage/blog/WrmrRSowwCAji0DG85ueDqP0K58T1fYbsf3t1TOf.png" alt></p></li><li><p>选择剩余空间较大的可分配磁盘，右键并选择“压缩卷”，这里选择压缩E盘50G左右的空间<br><img src="https://www.zlf520.com.cn/storage/blog/07goXKc0sGobzkuyPvxwXuLp3bQPocNtIqPiKexA.png" alt></p></li><li><p>点击“压缩”之后，E盘后部出现黑色的50G“未分配空间”<br><img src="https://www.zlf520.com.cn/storage/blog/jhbihNrN7POzsIrFlGX2Ik4HaXTB9CZBaftDhEvf.png" alt></p></li></ol><p>至此，磁盘分区过程完成</p><h5 id="禁用快速启动-可选但是建议"><a href="#禁用快速启动-可选但是建议" class="headerlink" title="禁用快速启动(可选但是建议)"></a>禁用快速启动(可选但是建议)</h5><p>按住<code>Win + X</code>(请记住这个万能的组合)，选择“电源选项”，依次执行：<br>“选择电源按钮的功能” -&gt; “更改当前不可用的设置” -&gt; 取消选择”启用快速启动”</p><blockquote><p>注： “快速启动”是Windows 8时代引进的新特性，建议关闭该特性的原因是，“快速启动”会影响Grub开机引导过程，可能出现无法载入Ubuntu的状况，最后选择“保存修改”。</p></blockquote><h5 id="制作Ubuntu的启动U盘"><a href="#制作Ubuntu的启动U盘" class="headerlink" title="制作Ubuntu的启动U盘"></a>制作Ubuntu的启动U盘</h5><p>（用U盘安装过操作系统的童鞋可以跳过这一步）</p><ol><li><p>备份待写入的U盘并将其插入电脑，进入UltraISO，打开镜像文件（即你已经下载好的ubuntu ISO镜像文件）<br><img src="https://www.zlf520.com.cn/storage/blog/YCx6fNLItMMAxquXm3yuJZF4lRSVU683wra4ZrgH.png" alt></p></li><li><p>启动&gt;写入硬盘映像<br><img src="https://www.zlf520.com.cn/storage/blog/efzH2s6lRKsskAGHMAcJesblmInYCWD5IuUzuzvC.png" alt></p></li><li><p>按默认值写入<br><img src="https://www.zlf520.com.cn/storage/blog/lpWgvtLL6zRpEY3UyKN2Fq9OAnkC7hcCabnvIU1L.png" alt><br><img src="https://www.zlf520.com.cn/storage/blog/5TMlK0XSGSj46fpPY4dASwXkw6iUiwb9zxhrXMUv.png" alt></p></li><li><p>完成硬盘映像写入，别拔U盘</p></li></ol><h5 id="U盘安装Ubuntu"><a href="#U盘安装Ubuntu" class="headerlink" title="U盘安装Ubuntu"></a>U盘安装Ubuntu</h5><p>重启，并按进入bios的快捷键(电脑不同型号快捷键不同，我的联想F2），进入系统bios后设置优先u盘启动，设置后电脑自动重启并进入ubuntu安装界面。</p><ol><li><p>选择“试用Ubuntu Kylin”<br><img src="https://www.zlf520.com.cn/storage/blog/T1OklFoA4bf5ilVNXOPpClnsgs7173rYV7fslqXb.jpeg" alt></p></li><li><p>进入ubuntu主界面然后双击打开ubuntu安装文件,完成默认设置</p><blockquote><p>注：如果网络和空间匀速，可以选择“安装中下载更新”和“安装这个第三方软件”（可以不选择，我建议不选择，费时间也没啥用）</p></blockquote></li><li><p>U盘安装Ubuntu本教程最重要的的一步，选择“其他选项”<br><img src="https://www.zlf520.com.cn/storage/blog/ID9u1HXtsnshq4NYyW4FhCgVlcXD4i6fUbkllXSQ.jpeg" alt></p></li><li><p>单击“创建新分区表”，点击的“+”创建4个主要的基础分区（这里之前未分配的50G就是给ubuntu系统的50G），按以下参数设置4个主要的基础分区：</p></li></ol><table><thead><tr><th>大小</th><th>分区</th><th>位置</th><th>格式</th><th>地址</th></tr></thead><tbody><tr><td>10G</td><td>主分区</td><td>空间起始位置</td><td>Ext4日志文件系统</td><td>/</td></tr><tr><td>4G</td><td>逻辑分区</td><td>空间起始位置</td><td>交换空间</td><td>/swap</td></tr><tr><td>200MB</td><td>逻辑分区</td><td>空间起始位置</td><td>Ext4日志文件系统</td><td>/boot</td></tr><tr><td>剩余的空间</td><td>逻辑分区</td><td>空间起始位置</td><td>Ext4日志文件系统</td><td>/home</td></tr></tbody></table><blockquote><p>当然这里还可创建自己的其他分区如/123分区，只要设置为逻辑分区、空间起始位置、Ext4日志文件系统即可，新手强烈建议忽略此步，按上面设置即可</p></blockquote><p>安装启动引导设备的参数选择：与<code>/boot</code>所在的编号一致。设置好后安装即可，之后的选项（所在地点、键盘布局、电脑名称、开机密码等）正常进行直到安装完毕，大功告成。</p><ol start="5"><li>重启系统，进入Win10完成最后的引导设置。</li></ol><h5 id="EasyBCD引导Ubuntu"><a href="#EasyBCD引导Ubuntu" class="headerlink" title="EasyBCD引导Ubuntu"></a>EasyBCD引导Ubuntu</h5><ol><li><p>重启在win10下进入EasyBCD，选择“添加新条目”，选择Linux/BSD操作系统，在“驱动器”栏目选择接近200M（与boot的那个接近）的Linux分区，点添加条目<br><img src="https://www.zlf520.com.cn/storage/blog/9k9Ozy1UksO26QeTZMKnKBI5Tl34Y8ePOWhQ8dsn.png" alt></p></li><li><p>完成条目添加后，重启电脑，会发现Win10和Ubuntu的双系统已经完成安装<br><img src="https://www.zlf520.com.cn/storage/blog/wxdM8iYcJdbd3A4kfDkgiyVpB5PTO7XB7RooPGFZ.jpeg" alt></p></li><li><p>大功告成，祝玩得开心</p><blockquote><p>后记：用Windows引导Ubuntu最大的好处就是，当不再需要Ubuntu的时候，直接在Windows磁盘管理中将其所在所有分区删除，然后将EasyBCD中对应条目删除即可。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> win </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 中添加一个新用户并授权</title>
      <link href="/2019/11/14/linux-centos-add-new-user/"/>
      <url>/2019/11/14/linux-centos-add-new-user/</url>
      
        <content type="html"><![CDATA[<h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><p>创建一个用户名为：linuxidc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# adduser linuxidc</span><br></pre></td></tr></table></figure><p>为这个用户初始化密码，linux会判断密码复杂度，不过可以强行忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# passwd linuxidc</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>个人用户的权限只可以在本home下有完整权限，其他目录要看别人授权。而经常需要root用户的权限，这时候sudo可以化身为root来操作。我记得我曾经sudo创建了文件，然后发现自己并没有读写权限，因为查看权限是root创建的。</p><p>新创建的用户并不能使用sudo命令，需要给他添加授权。</p><ol><li><p>sudo命令的授权管理是在sudoers文件里的。可以看看sudoers：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# whereis sudoers</span><br><span class="line">sudoers: /etc/sudoers /etc/sudoers.d /usr/libexec/sudoers.so /usr/share/man/man5/sudoers.5.gz</span><br></pre></td></tr></table></figure></li><li><p>找到这个文件位置之后再查看权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /etc/sudoers</span><br><span class="line">-r--r----- 1 root root 4251 9月 25 15:08 /etc/sudoers</span><br></pre></td></tr></table></figure></li><li><p>是的，只有只读的权限，如果想要修改的话，需要先添加w权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod -v u+w /etc/sudoers</span><br><span class="line">mode of &quot;/etc/sudoers&quot; changed from 0440 (r--r-----) to 0640 (rw-r-----)</span><br></pre></td></tr></table></figure></li><li><p>然后就可以添加内容了，在下面的一行下追加新增的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/sudoers</span><br><span class="line"></span><br><span class="line">## Allow root to run any commands anywher</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line">linuxidc ALL=(ALL) ALL #这个是新增的用户</span><br></pre></td></tr></table></figure></li><li><p><code>wq</code>保存退出，这时候要记得将写权限收回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod -v u-w /etc/sudoers</span><br><span class="line">mode of &quot;/etc/sudoers&quot; changed from 0640 (rw-r-----) to 0440 (r--r-----)</span><br></pre></td></tr></table></figure></li><li><p>这时候使用新用户登录，使用sudo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[linuxidc@localhost ~]$ sudo cat /etc/passwd</span><br><span class="line">[sudo] password for linuxidc:</span><br><span class="line">We trust you have received the usual lecture from the local System</span><br><span class="line">Administrator. It usually boils down to these three things:</span><br><span class="line">#1) Respect the privacy of others.</span><br><span class="line">#2) Think before you type.</span><br><span class="line">#3) With great power comes great responsibility.</span><br></pre></td></tr></table></figure></li></ol><p>第一次使用会提示你，你已经化身超人，身负责任。而且需要输入密码才可以下一步。<br>如果不想需要输入密码怎么办，将最后一个 <code>ALL</code> 修改成 <code>NOPASSWD: ALL</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文件权限</title>
      <link href="/2019/11/14/linux-file-jurisdiction/"/>
      <url>/2019/11/14/linux-file-jurisdiction/</url>
      
        <content type="html"><![CDATA[<h4 id="1-常用权限"><a href="#1-常用权限" class="headerlink" title="1. 常用权限"></a>1. 常用权限</h4><ul><li>444 r–r–r– ： 所有用户都只有读权限</li><li>600 rw——- ： 文件所有者具有读、写权限，其他用户没有权限</li><li>644 rw-r–r– ： 文件所有者具有读写权限，同组用户具有读权限，其他用户具有读权限</li><li>666 rw-rw-rw- ：文件所有者，同组用户，其他用户都具有读写权限，没有执行权限</li><li>700 rwx—— ： 文件所有者具有读写执行权限，同组用户其他用户均没有任何权限</li><li>744 rwxr–r– ： 文件所有者具有读写执行权限，同组用户和其他用户只有读权限</li><li>755 rwxr-xr-x ： 文件所有者具有读、写、执行权限，同组用户和其他用户具有读、执行权限</li><li>777 rwxrwxrwx ： 全部用户都用全权限</li></ul><a id="more"></a><h4 id="2-权限解释"><a href="#2-权限解释" class="headerlink" title="2. 权限解释"></a>2. 权限解释</h4><p>从左至右，1-3位数字代表<strong>文件所有者的权限</strong>，4-6位数字代表<strong>同组用户的权限</strong>，7-9数字代表<strong>其他用户的权限</strong>。</p><p>具体的权限是由数字来表示的，读取的权限等于4，用r表示；写入的权限等于2，用w表示；执行的权限等于1，用x表示。</p><p>通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行）。</p><p>以755为例：<br>1-3位7等于4+2+1，rwx，所有者具有读取、写入、执行权限；<br>4-6位5等于4+1+0，r-x，同组用户具有读取、执行权限但没有写入权限；<br>7-9位5，同上，也是r-x，其他用户具有读取、执行权限但没有写入权限。</p><h4 id="3-语法示例"><a href="#3-语法示例" class="headerlink" title="3. 语法示例"></a>3. 语法示例</h4><p>将文件 file1.txt 设为所有人皆可读取 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br><span class="line">或者</span><br><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure><ul><li>u 表示该文件的拥有者(User)，g 表示与该文件的拥有者属于同一个群体(Group)者，o 表示其他以外的人(Other)，a 表示这三者皆是。</li><li>+表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的artisan命令</title>
      <link href="/2019/11/14/laravel-artisan/"/>
      <url>/2019/11/14/laravel-artisan/</url>
      
        <content type="html"><![CDATA[<h4 id="全局篇"><a href="#全局篇" class="headerlink" title="全局篇"></a>全局篇</h4><ul><li><p>查看artisan命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php artisan</span><br><span class="line">php artisan list</span><br></pre></td></tr></table></figure></li><li><p>查看某个帮助命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan help make:model</span><br></pre></td></tr></table></figure></li><li><p>查看laravel版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan --version</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>使用 PHP 内置的开发服务器启动应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan serve</span><br></pre></td></tr></table></figure></li><li><p>生成一个随机的 key，并自动更新到 app/config/app.php 的 key 键值对（刚安装好需要做这一步）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan key:generate</span><br></pre></td></tr></table></figure></li><li><p>开启Auth用户功能（开启后需要执行迁移才生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:auth</span><br></pre></td></tr></table></figure></li><li><p>开启维护模式和关闭维护模式（显示503）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php artisan down</span><br><span class="line">php artisan up</span><br></pre></td></tr></table></figure></li><li><p>进入tinker工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan tinker</span><br></pre></td></tr></table></figure></li><li><p>列出所有的路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan route:list</span><br></pre></td></tr></table></figure></li><li><p>生成路由缓存以及移除缓存路由文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php artisan route:cache</span><br><span class="line">php artisan route:clear</span><br></pre></td></tr></table></figure></li></ul><h4 id="功能篇"><a href="#功能篇" class="headerlink" title="功能篇"></a>功能篇</h4><ul><li><p>创建控制器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:controller StudentController</span><br></pre></td></tr></table></figure></li><li><p>创建Rest风格资源控制器（带有index、create、store、edit、update、destroy、show方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:controller PhotoController --resource</span><br></pre></td></tr></table></figure></li><li><p>创建模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:model Student</span><br></pre></td></tr></table></figure></li><li><p>创建新建表的迁移和修改表的迁移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:migration create_users_table --create=students //创建students表</span><br><span class="line">php artisan make:migration add_votes_to_users_table --table=students//给students表增加votes字段</span><br></pre></td></tr></table></figure></li><li><p>执行迁移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan migrate</span><br></pre></td></tr></table></figure></li><li><p>创建模型的时候同时生成新建表的迁移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:model Student -m</span><br></pre></td></tr></table></figure></li><li><p>回滚上一次的迁移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan migrate:rollback</span><br></pre></td></tr></table></figure></li><li><p>回滚所有迁移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan migrate:reset</span><br></pre></td></tr></table></figure></li><li><p>创建填充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:seeder StudentTableSeeder</span><br></pre></td></tr></table></figure></li><li><p>执行单个填充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan db:seed --class=StudentTableSeeder</span><br></pre></td></tr></table></figure></li><li><p>执行所有填充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan db:seed</span><br></pre></td></tr></table></figure></li><li><p>创建中间件（app/Http/Middleware下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:middleware Activity</span><br></pre></td></tr></table></figure></li><li><p>创建队列（数据库）的表迁移（需要执行迁移才生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan queue:table</span><br></pre></td></tr></table></figure></li><li><p>创建队列类（app/jobs下）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:job SendEmail</span><br></pre></td></tr></table></figure></li><li><p>创建请求类（app/Http/Requests下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:request CreateArticleRequest</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel Queue</title>
      <link href="/2019/11/14/laravel-queue/"/>
      <url>/2019/11/14/laravel-queue/</url>
      
        <content type="html"><![CDATA[<h4 id="使用队列原因"><a href="#使用队列原因" class="headerlink" title="使用队列原因"></a>使用队列原因</h4><ul><li>异步</li><li>重试</li></ul><h4 id="使用队列场景"><a href="#使用队列场景" class="headerlink" title="使用队列场景"></a>使用队列场景</h4><ul><li>耗时比较久的，比如上传一个文件后进行一些格式的转化等。</li><li>需要保证送达率的，比如发送短信，因为要调用别人的 api，总会有几率失败，那么为了保证送达，重试就必不可少了。</li></ul><a id="more"></a><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ol><li>在开发环境我们想测试的时候，可以把 <code>Queue driver</code> 设置成为  <code>sync</code> ，这样队列就变成了同步执行，方便调试队列里面的任务。</li><li><code>Job</code> 里面的  <code>handle</code>  方法是可以注入别的 <code>class</code> 的，就像在 <code>Controller action</code> 里面也可以注入一样。</li><li>什么时候使用  <code>queue:listen</code>  什么时候使用  <code>queue:work</code> ？<br>答：Laravel 5.3 的文档已经不写  <code>queue:listen</code> 这个指令怎么用了，所以你可以看出来可能官方已经不怎么建议使用  <code>queue:listen</code> 了，但是在本地调试的时候要使用  <code>queue:listen</code> ，因为  <code>queue:work</code> 在启动后，代码修改， <code>queue:work</code> 不会再 Load 上下文，但是  <code>queue:listen</code> 仍然会重新 Load 新代码。<br>其余情况全部使用  <code>queue:work</code> 吧，因为效率更高。</li></ol><h4 id="命令讲解"><a href="#命令讲解" class="headerlink" title="命令讲解"></a>命令讲解</h4><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan queue:work --daemon --quiet --queue=default --delay=3 --sleep=3 --tries=3</span><br></pre></td></tr></table></figure><ul><li><p>–daemon<br>总体来说，在 supervisor 中一般要加这个 option，可以节省 CPU 使用。</p></li><li><p>–quiet<br>不输出任何内容</p></li><li><p>–delay=3<br>一个任务失败后，延迟 多长时间 后再重试，单位是秒。这个值的设定我个人建议不要太短，因为一个任务失败（比如网络原因），重试时间太短可能会出现连续失败的情况。</p></li><li><p>–sleep=3<br>去 Redis 中拿任务的时候，发现没有任务，休息 多长时间 ，单位是秒。这个值的设定要看你的任务是否紧急，如果是那种非常紧急的任务，不能等待太长时间。</p></li><li><p>–tries=3<br>定义 失败任务最多重试次数 。这个值的设定根据任务的重要程度来确定，一般 3 次比较适合。</p></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>Redis 里面一个任务默认最多执行60秒，如果一个任务60秒没有执行完毕，会继续放回到队列中，循环执行，那酸爽…</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel创建工具类</title>
      <link href="/2019/11/14/laravel-common-class/"/>
      <url>/2019/11/14/laravel-common-class/</url>
      
        <content type="html"><![CDATA[<p>以Common工具类为例：</p><h5 id="首先先介绍这个类的用法："><a href="#首先先介绍这个类的用法：" class="headerlink" title="首先先介绍这个类的用法："></a>首先先介绍这个类的用法：</h5><p>在一般控制器中只要 use Common; 然后在方法里面就能调用到Common类里面的方法了，<br>如Common::getSite();直接能调用到这个方法，一般这种都是比较常用的方法才放到工具类中，这样大家写的方法都能轻易的调用了。</p><a id="more"></a><h5 id="接下来就是如何创建这个工具类："><a href="#接下来就是如何创建这个工具类：" class="headerlink" title="接下来就是如何创建这个工具类："></a>接下来就是如何创建这个工具类：</h5><p>在app文件夹下面，创建一个服务文件夹名字叫做Services，然后在Services文件夹中创建一个CommonUnit.php里面的内容为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通用工具服务类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonUtils</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//写一些通用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何才能使这个类生效能在控制器中use-Common就能调用到里面的方法呢："><a href="#如何才能使这个类生效能在控制器中use-Common就能调用到里面的方法呢：" class="headerlink" title="如何才能使这个类生效能在控制器中use Common就能调用到里面的方法呢："></a>如何才能使这个类生效能在控制器中use Common就能调用到里面的方法呢：</h5><p>在config配置文件中打开app.php</p><p>在’providers’数组中添加：<br><code>App\Providers\CommonServiceProvider::class</code></p><p>在’aliases’数组中添加：<br><code>&#39;Common&#39; =&gt; App\Facades\Common::class</code></p><h5 id="在app文件夹下面创建Facades文件夹："><a href="#在app文件夹下面创建Facades文件夹：" class="headerlink" title="在app文件夹下面创建Facades文件夹："></a>在app文件夹下面创建Facades文件夹：</h5><p>里面创建一个静态类：<br>文件名称为Common.php，里面的内容为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Facades</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Facade</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Common</span> <span class="keyword">extends</span> <span class="title">Facade</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getFacadeAccessor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'CommonService'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="绑定功能到IOC容器"><a href="#绑定功能到IOC容器" class="headerlink" title="绑定功能到IOC容器:"></a>绑定功能到IOC容器:</h5><p>在app文件夹下面的Providers文件夹下面创建一个供应商文件，名字为：CommonServiceProvider.php<br>里面的内容为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Providers</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">ServiceProvider</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonServiceProvider</span> <span class="keyword">extends</span> <span class="title">ServiceProvider</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Register the application services.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'CommonService'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> \App\Services\CommonUtils();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就大工告成啦！</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel核心概念</title>
      <link href="/2019/11/14/laravel-core/"/>
      <url>/2019/11/14/laravel-core/</url>
      
        <content type="html"><![CDATA[<h4 id="自动依赖注入"><a href="#自动依赖注入" class="headerlink" title="自动依赖注入"></a>自动依赖注入</h4><blockquote><p>什么是依赖注入：通过类型提示的方式向函数传递参数。</p></blockquote><h5 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h5><p>首先，定义一个类:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/routes/web.php</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>假如我们在其他地方要使用到 Bar 提供的功能（服务），怎么办，直接传入参数即可：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/routes/web.php</span><br><span class="line">Route::get(<span class="string">'bar'</span>, <span class="function"><span class="keyword">function</span><span class="params">(Bar $bar)</span> </span>&#123;</span><br><span class="line">    dd($bar);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>访问 /bar，显示 $bar 的实例:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bar &#123;<span class="comment">#272&#125;</span></span><br></pre></td></tr></table></figure><p>也就是说，我们不需要先对其进行实例！如果学过 PHP 的面向对象，都知道，正常做法是这样:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line">$bar = <span class="keyword">new</span> Bar();</span><br><span class="line">dd($bar);</span><br></pre></td></tr></table></figure><h5 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h5><p>可以看一个稍微复杂的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $baz;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Baz $baz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;baz = $baz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$baz = <span class="keyword">new</span> Baz();</span><br><span class="line">$bar = <span class="keyword">new</span> Bar($baz);</span><br><span class="line">dd($bar);</span><br></pre></td></tr></table></figure><p>为了在 Bar 中能够使用 Baz 的功能，我们需要实例化一个 Baz，然后在实例化 Bar 的时候传入 Baz 实例。<br>在 Laravel 中，不仅仅可以自动注入 Bar，也可以自动注入 Baz:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/routes/web.php</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $baz;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Baz $baz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;baz = $baz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Route::get(<span class="string">'bar'</span>, <span class="function"><span class="keyword">function</span><span class="params">(Bar $bar)</span> </span>&#123;</span><br><span class="line">    dd($bar-&gt;baz);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>显示结果:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Baz &#123;<span class="comment">#276&#125;</span></span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>通过上述两个例子，可以看出，在 Laravel 中，我们要在类或者函数中使用其他类体用的服务，只需要通过类型提示的方式传递参数，而 Laravel 会自动帮我们去寻找响对应的依赖。</p><p>那么，Laravel 是如何完成这项工作的呢？答案就是通过服务容器。</p><h4 id="服务容器"><a href="#服务容器" class="headerlink" title="服务容器"></a>服务容器</h4><h5 id="什么是服务容器"><a href="#什么是服务容器" class="headerlink" title="什么是服务容器"></a>什么是服务容器</h5><p>服务容器，很好理解，就是装着各种服务实例的特殊类。可以通过「去餐馆吃饭」来进行类比：</p><ul><li>吃饭 - 使用服务，即调用该服务的地方</li><li>饭 - 服务</li><li>盘子 - 装饭的容器，即服务容器</li><li>服务员 - 服务提供者，负责装饭、上饭</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ol><li><p>饭：定义Rice类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/app/Rice.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rice</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">food</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'香喷喷的白米饭'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>把饭装盘子：<br>在容器中定义了名为 rice 的变量（你也可以起其他名字，比如 rice_container），绑定了 Food 的实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app()-&gt;bind(<span class="string">'rice'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> \App\Rice();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>也可以写成:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app()-&gt;bind(<span class="string">'rice'</span>,\App\Rice::class);</span><br></pre></td></tr></table></figure><p>现在，吃饭了，通过 make 方法提供吃饭的服务：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'eat'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> app()-&gt;make(<span class="string">'rice'</span>)-&gt;food();</span><br><span class="line">    <span class="comment">// 或者 return resolve('rice')-&gt;food()；</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>make 方法传入我们刚才定义的变量名即可调用该服务。<br>访问 <code>/eat</code>，返回 香喷喷的白米饭。</p><p>为了方便起见，我们在路由文件中直接实现了该过程，相当于自给自足。但是服务通常由服务提供者来管理的。<br>因此，我们可以让 AppServiceProvider 这个服务员来管理该服务：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/app/Providers/AppServiceProvider.php</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Providers</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;bind(<span class="string">'rice_container'</span>,Rice::class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更为常见的是，我们自己创建一个服务员：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan make:provider RiceServiceProvider</span><br></pre></td></tr></table></figure><p>注册:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/app/Providers/RiceServiceProvider.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Rice</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;bind(<span class="string">'rice'</span>,Rice::class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了 register() 方法，但是还需要调用该方法才能真正绑定服务到容器，因此，需要将其添加到 providers 数组中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/config/app.php</span><br><span class="line"><span class="string">'providers'</span> =&gt; [</span><br><span class="line">    App\Providers\RiceServiceProvider::class,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>这一步有何作用呢？Laravel 在启动的时候会访问该文件，然后调用里面的所有服务提供者的 register() 方法，这样我们的服务就被绑定到容器中了。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>通过上述的例子，基本上可以理解服务容器和服务提供者的使用。当然了，我们更为常见的还是使用类型提示来传递参数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Rice</span>;</span><br><span class="line">Route::get(<span class="string">'eat'</span>, <span class="function"><span class="keyword">function</span><span class="params">(Rice $rice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $rice-&gt;food();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在本例中，使用自动依赖注入即可。不需要在用 bind 来手动绑定以及 make 来调用服务。那么，为什么还需要 bind 和 make 呢？ make 比较好理解，我们有一些场合 Laravel 不能提供自动解析，那么这时候手动使用 make 解析就可以了，而 bind 的学问就稍微大了点，后面将会详细说明。</p><h4 id="门面"><a href="#门面" class="headerlink" title="门面"></a>门面</h4><p>门面是什么，我们回到刚才的「吃饭」的例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'eat'</span>, <span class="function"><span class="keyword">function</span><span class="params">(Rice $rice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $rice-&gt;food();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 Laravel，通常还可以这么写:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'eat'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rice::food();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'eat'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rice()-&gt;food();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那么，Laravel 是如何实现的呢？答案是通过门面。</p><h5 id="门面方法实现"><a href="#门面方法实现" class="headerlink" title="门面方法实现"></a>门面方法实现</h5><p>先来实现 Rice::food()，只需要一步：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/app/RiceFacade.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Facade</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiceFacade</span> <span class="keyword">extends</span> <span class="title">Facade</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getFacadeAccessor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'rice'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，RiceFacade 就代理了 Rice 类了，这就是门面的本质了。我们就可以直接使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'eat'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dd(\App\RiceFacade::food());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为 \App\RiceFacade 比较冗长，我们可以用 php 提供的 class_alias 方法起个别名吧：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/app/Providers/RiceServiceProvider.php</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;bind(<span class="string">'rice'</span>,\App\Rice::class);</span><br><span class="line">    class_alias(\App\RiceFacade::class, <span class="string">'Rice'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的话，就实现了一开始的用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'eat'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rice::food();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看上去就好像直接调用了 Rice 类，实际上，调用的是 RiceFacade 类来代理，因此，个人觉得Facade 翻译成假象比较合适。<br>最后，为了便于给代理类命名，Laravel 提供了统一命名别名的地方：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/config/app.php</span><br><span class="line"><span class="string">'aliases'</span> =&gt; [</span><br><span class="line">    <span class="string">'Rice'</span> =&gt; \App\RiceFacade::class,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h5 id="门面实现过程分析"><a href="#门面实现过程分析" class="headerlink" title="门面实现过程分析"></a>门面实现过程分析</h5><p>首先：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rice::food();</span><br></pre></td></tr></table></figure><p>因为 Rice 是别名，所以实际上执行的是:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\App\RiceFacade::food()</span><br></pre></td></tr></table></figure><p>但是我们的 RiceFacade 类里面并没有定义静态方法 food 啊？怎么办呢？直接抛出异常吗？不是，在 PHP 里，如果访问了不可访问的静态方法，会先调用 <code>__callstatic</code>,所以执行的是:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\App\RiceFacade::__callStatic()</span><br></pre></td></tr></table></figure><p>虽然我们在 RiceFacade 中没有定义，但是它的父类 Facade 已经定义好了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/vendor/laravel/framework/src/Illuminate/Support/Facades/Facade.php</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">($method, $args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 实例化 Rice &#123;#270&#125;</span></span><br><span class="line">$instance = <span class="keyword">static</span>::getFacadeRoot();</span><br><span class="line"><span class="comment">// 实例化失败，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (! $instance) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">'A facade root has not been set.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用该实例的方法</span></span><br><span class="line"><span class="keyword">return</span> $instance-&gt;$method(...$args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作就是第一步实例化:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getFacadeRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static</span>::resolveFacadeInstance(<span class="keyword">static</span>::getFacadeAccessor());</span><br><span class="line">    <span class="comment">// 本例中：static::resolveFacadeInstance('rice')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步查看 resolveFacadeInstance() 方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveFacadeInstance</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// rice 是字符串，因此跳过该步骤</span></span><br><span class="line">    <span class="keyword">if</span> (is_object($name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> $name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否设置了 `rice` 实例</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">static</span>::$resolvedInstance[$name])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static</span>::$resolvedInstance[$name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static</span>::$resolvedInstance[$name] = <span class="keyword">static</span>::$app[$name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步比较好理解，如果我们之前在 RiceFacade 这样写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getFacadeAccessor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> \App\Rice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就直接返回 Rice 实例了，这也是一种实现方式。<br>主要难点在于最后这行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">static</span>::$resolvedInstance[$name] = <span class="keyword">static</span>::$app[$name];</span><br></pre></td></tr></table></figure><p>看上去像是在访问 $app数组，实际上是使用 数组方式来访问对象，PHP 提供了这种访问方式接口，而 Laravel 实现了该接口。<br>也就是说，$app 属性其实就是对 Laravel 容器的引用，因此这里实际上就是访问容器上名为 rice 的对象。而我们之前学习容器的时候，已经将 rice 绑定了 Rice 类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;bind(<span class="string">'rice'</span>,\App\Rice::class);</span><br><span class="line">    <span class="comment">// class_alias(\App\RiceFacade::class, 'Rice');</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，其实就是返回该类的实例了。懂得了服务容器和服务提供者，理解门面也就不难了。</p><h5 id="辅助方法实现"><a href="#辅助方法实现" class="headerlink" title="辅助方法实现"></a>辅助方法实现</h5><p>辅助方法的实现，更简单了。不就是把 app-&gt;make(‘rice’) 封装起来嘛：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/vendor/laravel/framework/src/Illuminate/Foundation/helpers.php</span><br><span class="line"><span class="keyword">if</span> (! function_exists(<span class="string">'rice'</span>)) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rice</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> app()-&gt;make(<span class="string">'rice'</span>);</span><br><span class="line">        <span class="comment">// 等价于 return app('rice');</span></span><br><span class="line">        <span class="comment">// 等价于 return app()['rice'];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以使用了:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'eat'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dd(rice()-&gt;food());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>Laravel 提供的三种访问类的方式：</p><ul><li>依赖注入：通过类型提示的方式实现自动依赖注入</li><li>门面：通过代理来访问类</li><li>辅助方法：通过方法的方式来访问类<br>本质上，这三种方式都是借助于服务容器和服务提供者来实现。那么，服务容器本身有什么好处呢？我们接下来着重介绍下。</li></ul><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><h5 id="不好的实现"><a href="#不好的实现" class="headerlink" title="不好的实现"></a>不好的实现</h5><p>我们来看另外一个例子（为了方便测试，该例子都写在路由文件中），假设有三种类型的插座：USB、双孔、三孔插座，分别提供插入充电的服务：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsbsocketService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($deviceName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $deviceName.<span class="string">" 正在插入 USB 充电"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleSocketService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($deviceName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $deviceName.<span class="string">" 正在插入双孔插座充电"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeSocketService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($deviceName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $deviceName.<span class="string">" 正在插入三孔插座充电"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设备要使用插座的服务来充电：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $socketType; <span class="comment">// 插座类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;socketType = <span class="keyword">new</span> UsbSocketService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">power</span><span class="params">($deviceName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;socketType-&gt;insert($deviceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一台手机要进行充电:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'/charge'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $device = <span class="keyword">new</span> Device();</span><br><span class="line">    <span class="keyword">return</span> $device-&gt;power(<span class="string">"手机"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为 Laravel 提供了自动依赖注入功能，因此可以写成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'/charge/&#123;device&#125;'</span>,<span class="function"><span class="keyword">function</span><span class="params">(Device $device)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $device-&gt;power(<span class="string">"手机"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>访问 <code>/charge/phone</code>，页面显示 <code>phone 正在插入 USB 充电</code>。<br>假如，现在有一台电脑要充电，用的是三孔插座，那么我们就需要去修改 Device 类:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;socketType = <span class="keyword">new</span> ThreeSocketService();</span><br></pre></td></tr></table></figure><p>这真是糟糕的设计，设备类对插座服务类产生了依赖。更换设备类型时，经常就要去修改类的内部结构。</p><h5 id="好的实现"><a href="#好的实现" class="headerlink" title="好的实现"></a>好的实现</h5><p>为了解决上面的问题，可以参考「IOC」思路：即将依赖转移到外部。来看看具体怎么做。<br>首先定义插座类型接口：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SocketType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($deviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让每一种插座都实现该接口：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsbsocketService</span> <span class="keyword">implements</span> <span class="title">SocketType</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($deviceName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $deviceName.<span class="string">" 正在插入 USB 充电"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleSocketService</span> <span class="keyword">implements</span> <span class="title">SocketType</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($deviceName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $deviceName.<span class="string">" 正在插入双孔插座充电"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeSocketService</span> <span class="keyword">implements</span> <span class="title">SocketType</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($deviceName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $deviceName.<span class="string">" 正在插入三孔插座充电"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，设备中传入接口类型而非具体的类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $socketType; <span class="comment">// 插座类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(SocketType $socketType)</span> // 传入接口</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;socketType = $socketType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">power</span><span class="params">($deviceName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;socketType-&gt;insert($deviceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化的时候再决定使用哪种插座类型，这样依赖就转移到了外部：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'/charge'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $socketType = <span class="keyword">new</span> ThreeSocketService();</span><br><span class="line">    $device = <span class="keyword">new</span> Device($socketType);</span><br><span class="line">    <span class="keyword">echo</span> $device-&gt;power(<span class="string">"电脑"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们现在可以再不修改类结构的情况下，方便的更换插座来满足不同设备的充电需求:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'/charge'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $socketType = <span class="keyword">new</span> DoubleSocketService();</span><br><span class="line">    $device = <span class="keyword">new</span> Device($socketType);</span><br><span class="line">    <span class="keyword">echo</span> $device-&gt;power(<span class="string">"台灯"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="自动依赖注入的失效"><a href="#自动依赖注入的失效" class="headerlink" title="自动依赖注入的失效"></a>自动依赖注入的失效</h5><p>上面举的例子，我们通过 Laravel 的自动依赖注入可以进一步简化：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'/charge'</span>,<span class="function"><span class="keyword">function</span><span class="params">(Device $device)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> $device-&gt;power(<span class="string">"电脑"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的类型提示有两个，一个是 Device $device，一个是 Device 类内部构造函数传入的 SocketType $sockType。第一个没有问题，之前也试过。但是第二个 SocketType 是接口，而 Laravel 会将其当成类试图去匹配 SocketType 的类并将其实例化，因此访问 /charge 时候就会报错:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target [SocketType] is not instantiable <span class="keyword">while</span> building [Device].</span><br></pre></td></tr></table></figure><p>错误原因很明显，Laravel 没法自动绑定接口。因此，我们就需要之前的 bind 方法来手动绑定接口啦：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app()-&gt;bind(<span class="string">'SocketType'</span>,ThreeSocketService::class);</span><br><span class="line">Route::get(<span class="string">'/charge'</span>,<span class="function"><span class="keyword">function</span><span class="params">(Device $device)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> $device-&gt;power(<span class="string">"电脑"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在，如果要更换设备，我们只需要改变绑定的值就可以了:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app()-&gt;bind(<span class="string">'SocketType'</span>,DoubleSocketService::class);</span><br><span class="line">Route::get(<span class="string">'/charge'</span>,<span class="function"><span class="keyword">function</span><span class="params">(Device $device)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> $device-&gt;power(<span class="string">"台灯"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也就是说，我们将依赖转移到了外部之后，进一步由第三方容器来管理，这就是 IOC。</p><h4 id="契约"><a href="#契约" class="headerlink" title="契约"></a>契约</h4><p>契约，不是什么新奇的概念。其实就是上一个例子中，我们定义的接口:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SocketType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($deviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过契约，我们就可以保持松耦合了:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(SocketType $socketType)</span> // 传入接口而非具体的插座类型</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;socketType = $socketType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后服务容器再根据需要去绑定哪种服务即可:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app()-&gt;bind(<span class="string">'SocketType'</span>,UsbSocketService::class);</span><br><span class="line">app()-&gt;bind(<span class="string">'SocketType'</span>,DoubleSocketService::class);</span><br><span class="line">app()-&gt;bind(<span class="string">'SocketType'</span>,ThreeSocketService::class)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel 跨域</title>
      <link href="/2019/11/11/laravel-cross-domain/"/>
      <url>/2019/11/11/laravel-cross-domain/</url>
      
        <content type="html"><![CDATA[<h5 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h5><p>出于安全性的原因，浏览器会限制 Script 中的跨域请求。由于 XMLHttpRequest 遵循同源策略，所有使用 XMLHttpRequest 构造 HTTP 请求的应用只能访问自己的域名，如果需要构造跨域的请求，那么开发者需要配合浏览器做出一些允许跨域的配置。</p><a id="more"></a><p>W3C 应用工作组推荐了一种跨资源共享的机制，这种机制让 Web 应用服务器能支持跨站访问控制，从而使得安全的进行跨站数据传输成为可能，该机制通过几种方式来对原有模式进行了扩展：</p><ul><li>响应的头部应该追加 Access-Control-Allow-Orign，用来表明哪些请求源被允许访问资源内容</li><li>浏览器会对请求源和响应中的值进行匹配验证</li><li>对于跨域的请求，浏览器会预发送一个非简单方式的请求，来判断给定资源是否准备接受跨域资源访问</li><li>服务端应用通过检查请求头部的 Orign 来判定请求是否跨域。</li></ul><h5 id="跨源资源共享标准"><a href="#跨源资源共享标准" class="headerlink" title="跨源资源共享标准"></a>跨源资源共享标准</h5><p>跨源资源共享标准通过新增一系列 HTTP 头，让服务器能声明哪些来源可以通过浏览器访问该服务器上的资源。另外，对哪些会对服务器数据造成破坏性响应的 HTTP 请求方法（特别是 GET 以外的 HTTP 方法，或者搭配某些 MIME 类型的 POST 请求），标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求（preflight request），从而获取知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。服务器端也可以通知客户端，是不是需要随同请求一起发送信用信息（包括 Cookies 和 HTTP 认证相关数据）。</p><h5 id="响应头Response-Header"><a href="#响应头Response-Header" class="headerlink" title="响应头Response Header"></a>响应头Response Header</h5><ul><li>Access-Control-Allow-Origin : 指明哪些请求源被允许访问资源，值可以为 “*”，”null”，或者单个源地址。</li><li>Access-Control-Allow-Credentials : 指明当请求中省略 creadentials 标识时响应是否暴露。对于预请求来说，它表明实际的请求中可以包含用户凭证。</li><li>Access-Control-Expose-Headers : 指明哪些头信息可以安全的暴露给 CORS API 规范的 API。</li><li>Access-Control-Max-Age : 指明预请求可以在预请求缓存中存放多久。</li><li>Access-Control-Allow-Methods : 对于预请求来说，哪些请求方式可以用于实际的请求。</li><li>Access-Control-Allow-Headers : 对于预请求来说，指明了哪些头信息可以用于实际的请求中。</li><li>Origin : 指明预请求或者跨域请求的来源。</li><li>Access-Control-Request-Method : 对于预请求来说，指明哪些预请求中的请求方式可以被用在实际的请求中。</li><li>Access-Control-Request-Headers : 指明预请求中的哪些头信息可以用于实际的请求中。</li></ul><h5 id="请求头Request-Header"><a href="#请求头Request-Header" class="headerlink" title="请求头Request Header"></a>请求头Request Header</h5><ul><li>Origin : 表明发送请求或预请求的来源。</li><li>Access-Control-Request-Method : 在发送预请求时带该请求头，表明实际的请求将使用的请求方式。</li><li>Access-Control-Request-Headers : 在发送预请求时带有该请求头，表明实际的请求将携带的请求头。</li></ul><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php namespace App\Http\Middleware;</span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line">use Response;</span><br><span class="line">class EnableCrossRequestMiddleware &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Handle an incoming request.</span><br><span class="line">   *</span><br><span class="line">   * @param  \Illuminate\Http\Request  $request</span><br><span class="line">   * @param  \Closure  $next</span><br><span class="line">   * @return mixed</span><br><span class="line">   */</span><br><span class="line">  public function handle($request, Closure $next)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    $response = $next($request);</span><br><span class="line">        $response-&gt;header(&apos;Access-Control-Allow-Origin&apos;, config(&apos;app.allow&apos;));</span><br><span class="line">        $response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Origin, Content-Type, Cookie, Accept&apos;);</span><br><span class="line">        $response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;GET, POST, PATCH, PUT, OPTIONS&apos;);</span><br><span class="line">        $response-&gt;header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;);</span><br><span class="line">        return $response;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有以下需要注意的地方：</p><ul><li>对于跨域访问并需要伴随认证信息的请求(需要携带cookie的)，需要在 XMLHttpRequest(axios中) 实例中指定 withCredentials 为 true。</li><li>这个中间件你可以根据自己的需求进行构建，如果需要在请求中伴随认证信息（包含 cookie，session）那么你就需要指定 Access-Control-Allow-Credentials 为 true, 因为对于预请求来说如果你未指定该响应头，那么浏览器会直接忽略该响应。</li><li>在响应中指定 Access-Control-Allow-Credentials 为 true 时，Access-Control-Allow-Origin 不能指定为 *</li><li>后置中间件只有在正常响应时才会被追加响应头，而如果出现异常，这时响应是不会经过中间件的。</li><li>注册这个 middleware 到 kernel 中. 分别在 protected $middleware  数组中和 protected $routeMiddleware 数组中，添加我们刚才创建的那个文件class名 和 使用 <code>cors</code> 这个别名.</li><li>本地开发过程中，必须在protected $middleware中添加跨域的中间件才能实现本地跨域。</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP高并发支撑</title>
      <link href="/2019/11/11/php-high-concurrence/"/>
      <url>/2019/11/11/php-high-concurrence/</url>
      
        <content type="html"><![CDATA[<h5 id="简单的架构"><a href="#简单的架构" class="headerlink" title="简单的架构"></a>简单的架构</h5><p><img src="https://www.zlf520.com.cn/storage/blog/Nb878DTceh.png" alt></p><a id="more"></a><h5 id="系统集群化部署"><a href="#系统集群化部署" class="headerlink" title="系统集群化部署"></a>系统集群化部署</h5><p>添加负载均衡层，将请求均匀打到系统层。<br>系统层采用集群化部署多台机器，扛住初步的并发压力。<br><img src="https://www.zlf520.com.cn/storage/blog/Ogr65jgcLd.png" alt></p><h5 id="数据库分库分表-读写分离"><a href="#数据库分库分表-读写分离" class="headerlink" title="数据库分库分表 + 读写分离"></a>数据库分库分表 + 读写分离</h5><p>并发量继续增长时，我们就需要 focus 在数据库层面：分库分表、读写分离。<br><img src="https://www.zlf520.com.cn/storage/blog/16rEhN79QJ.png" alt></p><h5 id="缓存集群引入"><a href="#缓存集群引入" class="headerlink" title="缓存集群引入"></a>缓存集群引入</h5><p>不要盲目进行数据库扩容，数据库服务器成本昂贵，且本身就不是用来承载高并发的<br>针对写少读多的请求，引入缓存集群，用缓存集群抗住大量的读请求<br><img src="https://www.zlf520.com.cn/storage/blog/rBwJS5a4uO.png" alt></p><h5 id="引入消息中间件集群"><a href="#引入消息中间件集群" class="headerlink" title="引入消息中间件集群"></a>引入消息中间件集群</h5><p>消息中间件本身也跟缓存系统一样，可以用很少的资源支撑很高的并发请求，用他来支撑部分允许异步化的高并发写入是没问题的，比使用数据库直接支撑那部分高并发请求要减少很多的机器使用量。<br><img src="https://www.zlf520.com.cn/storage/blog/VCqcK8U5ME.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让Google搜索到搭建在Github Pages上的博客</title>
      <link href="/2019/10/11/google-search-console/"/>
      <url>/2019/10/11/google-search-console/</url>
      
        <content type="html"><![CDATA[<p>使用Hexo博客框架和GitHub结合搭建博客是一种很不错的选择，但是如何能让博客被Google到呢？</p><h4 id="查看是否被收录"><a href="#查看是否被收录" class="headerlink" title="查看是否被收录"></a>查看是否被收录</h4><p>首先查看是否已被Google收录，在Google中搜索：<br><code>site:https://liwen-git.github.io/</code><br>如果未查询到则继续往下看。</p><a id="more"></a><h4 id="搜索资源提交"><a href="#搜索资源提交" class="headerlink" title="搜索资源提交"></a>搜索资源提交</h4><p>进入<a href="https://search.google.com/search-console?resource_id=https%3A%2F%2Fliwen-git.github.io%2F" target="_blank" rel="noopener">Google Search Console</a><br>登录之后，提交自己的博客网址：<br><img src="https://www.zlf520.com.cn/storage/blog/NWsVlwHIhO34Y6ggf22Z7cobgwDQpkUZbmdaThaf.png" alt></p><p>选取HTML标记来进行验证，使用推荐方法会被<code>sudo hexo clean</code>命令清除：<br><img src="https://www.zlf520.com.cn/storage/blog/Ebh4ABIqHxX6gnEXFweD7lhgqVNsdkpBRgcSndhg.png" alt></p><p>将Search Console给的meta标签的信息添加到主题的目录下head.swig文件中，这里使用的是Next主题,其他主题也是类似的，在Hexo/themes/next/layout/_partials/head/head.swig文件中原有meta标签后面添加刚才复制的meta标签。</p><p>这时点击验证是无法通过的，需要将你的修改后的Hexo博客更新并部署到Github Pages上之后才可以验证，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g</span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure><p>验证后会提示成功，点击”继续“，先不要关闭这个页面，后面还要用。</p><h4 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h4><p>站点地图(Site Map)是用来注明网站结构的文件，我们希望搜索引擎的爬虫了解我们的网站结构，以便于高效爬取内容，快速建立索引。</p><h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><p>首先为Hexo安装hexo-generator-sitemap插件，在Hexo博客目录下运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h5 id="重新编译"><a href="#重新编译" class="headerlink" title="重新编译"></a>重新编译</h5><p>配置Hexo的_config.yml文件，添加如下字段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br></pre></td></tr></table></figure><p>然后重新生成博客文件，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo g</span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure><p>此时应该可以在public目录下看到sitemap.xml文件了。</p><h5 id="添加-测试站点地图"><a href="#添加-测试站点地图" class="headerlink" title="添加/测试站点地图"></a>添加/测试站点地图</h5><p>回到之前提交搜索资源的页面，在左边侧边栏找到“站点地图”,添加新的站点地图，将<a href="https://liwen-git.github.io/sitemap.xml提交并刷新，就可以看到博客的网站结构了。" target="_blank" rel="noopener">https://liwen-git.github.io/sitemap.xml提交并刷新，就可以看到博客的网站结构了。</a></p><p><img src="https://www.zlf520.com.cn/storage/blog/N6eBBHxr147jG7kQqIEwJLYXkY4INqpo0ErmrJ1n.png" alt></p><p>如果没有什么问题的话，到这里就结束了，但是现在用Google还不能立即查到博客的内容，要等到搜索引擎下一次更新检索时才会有显示。</p><h5 id="若站点地图无法获取"><a href="#若站点地图无法获取" class="headerlink" title="若站点地图无法获取"></a>若站点地图无法获取</h5><p>如果出现了上图的情况，可能是站点地图生成有问题，可以使用<a href="https://www.xml-sitemaps.com/" target="_blank" rel="noopener">XML-Sitemaps</a>重新生成站点地图，然后下载，替换blog/public中的sitemap.xml文件。<br><img src="https://www.zlf520.com.cn/storage/blog/xhGqFJdJm9KS8V2gNrihpXcH36mWEViJ3E8RGQL9.png" alt></p><h5 id="若站点地图报错：不允许此网址"><a href="#若站点地图报错：不允许此网址" class="headerlink" title="若站点地图报错：不允许此网址"></a>若站点地图报错：不允许此网址</h5><p>可能是站点地图sitemap.xml中的所有网址是以<code>yousite.com</code>开头的，所以站点地图报错</p><blockquote><p>解决：在<code>blog/_config.yml</code>中修改url为你自己的地址<br>之后重新编译上传，重新生成sitemap.xml，重新提交即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Homebrew切换镜像源</title>
      <link href="/2019/09/24/homebrew-mirrors/"/>
      <url>/2019/09/24/homebrew-mirrors/</url>
      
        <content type="html"><![CDATA[<h5 id="切换中科大镜像源："><a href="#切换中科大镜像源：" class="headerlink" title="切换中科大镜像源："></a>切换中科大镜像源：</h5><ol><li>替换brew.git<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Homebrew</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br></pre></td></tr></table></figure></li></ol><p>切换回官方源：</p><blockquote><p><a href="https://github.com/Homebrew/brew" target="_blank" rel="noopener">https://github.com/Homebrew/brew</a></p></blockquote><a id="more"></a><ol start="2"><li>替换homebrew-core.git<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</span><br><span class="line"></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line">brew update</span><br></pre></td></tr></table></figure></li></ol><p>切换官方源：</p><blockquote><p><a href="https://github.com/Homebrew/homebrew-core" target="_blank" rel="noopener">https://github.com/Homebrew/homebrew-core</a></p></blockquote><ol start="3"><li>替换Homebrew Bottles源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profile</span><br><span class="line"></span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ol><p>切换回官方：</p><blockquote><p>删除~/.bash_profile中的HOMEBREW_BOTTLE_DOMAIN源即可</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-ide-helper</title>
      <link href="/2019/09/24/laravel-ide-helper/"/>
      <url>/2019/09/24/laravel-ide-helper/</url>
      
        <content type="html"><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果只想在开发环境安装请加上 --dev</span><br><span class="line">composer require --dev barryvdh/laravel-ide-helper</span><br></pre></td></tr></table></figure><p>在 「config/app.php」的 「providers」数组中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class,</span><br></pre></td></tr></table></figure><blockquote><p>如果你的 Laravel 版本小于 5.5 的话，请注册服务提供者，否则请忽略</p></blockquote><a id="more"></a><p>如果你只在开发环境中安装「larave-ide-helper」，那么可以在「app/Providers/AppServiceProvider.php」的「register」方法中写入下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public function register()</span><br><span class="line">&#123;</span><br><span class="line">    if ($this-&gt;app-&gt;environment() !== &apos;production&apos;) &#123;</span><br><span class="line">        $this-&gt;app-&gt;register(\Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出配置文件,即：config/ide-helper.php（如果默认配置就满足需求了，也可以忽略这一步）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan vendor:publish --provider=&quot;Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider&quot; --tag=config</span><br></pre></td></tr></table></figure><p>好了，接下去可以愉快的使用了</p><h4 id="自动为-Laravel-的-Facades-生成注释"><a href="#自动为-Laravel-的-Facades-生成注释" class="headerlink" title="自动为 Laravel 的 Facades 生成注释"></a>自动为 Laravel 的 Facades 生成注释</h4><p>在命令行下运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan ide-helper:generate</span><br></pre></td></tr></table></figure><blockquote><p>注: 如果存在文件 「bootstrap/compiled.php」 需要先删除， 可以在生成文当前运行 php artisan clear-compiled。</p></blockquote><h4 id="自动为模型生成注释"><a href="#自动为模型生成注释" class="headerlink" title="自动为模型生成注释"></a>自动为模型生成注释</h4><ul><li><p>多个模型：直接 <code>php artisan ide-helper:models</code>，当然也可以 <code>php artisan ide-helper:models -W</code></p></li><li><p>单个模型：这个不能按照 github 上的 readme 来，坑爹。必须指明具体的类全名：<code>php artisan ide-helper:models &quot;App\Http\Models\User&quot;</code>。</p></li></ul><p>为所有模型生成注释 <code>php artisan ide-helper:models</code>, 这时会出现询问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you want to overwrite the existing model files? Choose no to write to _ide_helper_models.php instead? (Yes/No):  (yes/no) [no]:</span><br></pre></td></tr></table></figure><p>输入 yes 则会直接在模型文件中写入注释，否则会生成「_ide_helper_models.php」文件。建议选择 yes，这样在跟踪文件的时候不会跳转到「_ide_helper_models.php」文件，不过这么做最好对模型文件做个备份，至少在生成注释之前用 git 控制一下版本，以防万一。</p><blockquote><p>提示： 为模型生成字段信息必须在数据库中存在相应的数据表，不要生成 migration 还没运行 migrate 的时候就生成注释，这样是得不到字段信息的。</p></blockquote><h4 id="自动为链式操作注释"><a href="#自动为链式操作注释" class="headerlink" title="自动为链式操作注释"></a>自动为链式操作注释</h4><p>这是什么意思呢？举个例子，在 migration 文件中经常可以看见这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$table-&gt;string(&apos;email&apos;)-&gt;unique();</span><br></pre></td></tr></table></figure><p>这时候就算调用过了 <code>php artisan ide-helper:generate</code>，在调用像 -&gt;unique() 这样的链式操作的时候也无法实现代码提示，这时候需要将配置文件「如果导出的话」<code>&#39;include_fluent&#39; =&gt; false</code> 修改为 <code>&#39;include_fluent&#39; =&gt; true</code>，重新运行 <code>php artisan ide-helper:generate</code>。试试效果吧！</p><h4 id="生成-phpStorm-meta-php"><a href="#生成-phpStorm-meta-php" class="headerlink" title="生成 .phpStorm.meta.php"></a>生成 .phpStorm.meta.php</h4><p>可以生成一个PhpStorm meta 文件去支持工厂模式. 对于 Laravel, 这意味着我们可以让 PhpStorm 理解我们从 IoC 容器中解决了什么类型的对象。例如：事件将返回一个「Illuminate\Events\Dispatcher」对象，利用 meta 文件您可以调用 app(‘events’) 并且它将自动完成 Dispatcher 的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app(&apos;events&apos;)-&gt;fire();</span><br><span class="line">\App::make(&apos;events&apos;)-&gt;fire();</span><br><span class="line"></span><br><span class="line">/** @var \Illuminate\Foundation\Application $app */</span><br><span class="line">$app-&gt;make(&apos;events&apos;)-&gt;fire();</span><br><span class="line"></span><br><span class="line">// When the key is not found, it uses the argument as class name</span><br><span class="line">app(&apos;App\SomeClass&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>提示：您可能需要重启 Phpstorm 使 .phpStorm.meta.php 文件生效。</p></blockquote><h4 id="自动运行-generate"><a href="#自动运行-generate" class="headerlink" title="自动运行 generate"></a>自动运行 generate</h4><p>想在依赖包更新是自动更新注释，可以在 composer.json 文件中做如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">    &quot;post-update-cmd&quot;: [</span><br><span class="line">        &quot;Illuminate\\Foundation\\ComposerScripts::postUpdate&quot;,</span><br><span class="line">        &quot;php artisan ide-helper:generate&quot;,</span><br><span class="line">        &quot;php artisan ide-helper:meta&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示：如果只在 dev 环境下部署 ide helper 还是不要这么做了，防止在生产环境中报错导致不必要的麻烦。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TortoiseGit 和 Git 配置使用同一私钥</title>
      <link href="/2019/09/24/tortoisegit-key/"/>
      <url>/2019/09/24/tortoisegit-key/</url>
      
        <content type="html"><![CDATA[<h4 id="tortoisegit-和-git-私钥格式"><a href="#tortoisegit-和-git-私钥格式" class="headerlink" title="tortoisegit 和 git 私钥格式"></a>tortoisegit 和 git 私钥格式</h4><ol><li><p>tortoisegit 默认使用putty格式的私钥（id_rsa.ppk）：<br> <img src="https://www.zlf520.com.cn/storage/blog/putty.jpg" alt></p></li><li><p>git 默认使用openssh格式的私钥 (id_ras)：<br> <img src="https://www.zlf520.com.cn/storage/blog/openssh.jpg" alt></p><a id="more"></a>    </li></ol><h4 id="首先通过ssh-keygen命令生产通用的id-ras-pub公钥-和-id-rsa的git私钥"><a href="#首先通过ssh-keygen命令生产通用的id-ras-pub公钥-和-id-rsa的git私钥" class="headerlink" title="首先通过ssh-keygen命令生产通用的id_ras.pub公钥 和 id_rsa的git私钥"></a>首先通过ssh-keygen命令生产通用的id_ras.pub公钥 和 id_rsa的git私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>然后可以在用户主目录里找到.ssh目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><h4 id="使用puttyGen将git的openssh格式秘钥转化为putty格式"><a href="#使用puttyGen将git的openssh格式秘钥转化为putty格式" class="headerlink" title="使用puttyGen将git的openssh格式秘钥转化为putty格式"></a>使用puttyGen将git的openssh格式秘钥转化为putty格式</h4><ol><li>运行PuTTYGen，在Conversions菜单中点击Import key，选择ssh-keygen生成的私钥文件所在位置，比如id_rsa文件。</li><li>点击Save private key按钮，将其保存为.ppk文件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitLab-ce搭建</title>
      <link href="/2019/09/24/gitlab-ce/"/>
      <url>/2019/09/24/gitlab-ce/</url>
      
        <content type="html"><![CDATA[<h5 id="安装并配置必要的依赖关系"><a href="#安装并配置必要的依赖关系" class="headerlink" title="安装并配置必要的依赖关系"></a>安装并配置必要的依赖关系</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-python openssh-server cronie</span><br><span class="line"></span><br><span class="line">sudo lokkit -s http -s ssh</span><br></pre></td></tr></table></figure><p>安装Postfix以发送通知电子邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install postfix</span><br><span class="line">sudo service postfix start</span><br><span class="line">sudo chkconfig postfix on</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="添加gitLab仓库到yum源，并安装"><a href="#添加gitLab仓库到yum源，并安装" class="headerlink" title="添加gitLab仓库到yum源，并安装"></a>添加gitLab仓库到yum源，并安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash</span><br><span class="line"></span><br><span class="line">sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; yum -y install gitlab-ce</span><br></pre></td></tr></table></figure><p>EXTERNAL_URL是设置用什么域名访问你的gitlab，此时也可以直接yum install gitlab-ce。<br>安装完成后再修改配置文件/etc/gitlab/gitlab.rb</p><h5 id="运行配置命令"><a href="#运行配置命令" class="headerlink" title="运行配置命令"></a>运行配置命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>这样就可以访问你的gitLab了。</p><h5 id="修改nginx端口（使用gitLab内置nginx）"><a href="#修改nginx端口（使用gitLab内置nginx）" class="headerlink" title="修改nginx端口（使用gitLab内置nginx）"></a>修改nginx端口（使用gitLab内置nginx）</h5><ol><li><p>修改nginx端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">nginx[&apos;listen_port&apos;] = 82    #默认值即80端口 nginx[&apos;listen_port&apos;] = nil</span><br><span class="line"></span><br><span class="line">vim /var/opt/gitlab/nginx/conf/gitlab-http.conf</span><br><span class="line"></span><br><span class="line">listen *:82;    #默认值listen *:80;</span><br></pre></td></tr></table></figure></li><li><p>修改unicorn端口(可以不修改)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">unicorn[&apos;port&apos;] = 8082   #原值unicorn[&apos;port&apos;] = 8080</span><br><span class="line"></span><br><span class="line">vim /var/opt/gitlab/gitlab-rails/etc/unicorn.rb</span><br><span class="line"></span><br><span class="line">listen &quot;127.0.0.1:8082&quot;, :tcp_nopush =&gt; true  #原值listen &quot;127.0.0.1:8080&quot;, :tcp_nopush =&gt; true</span><br></pre></td></tr></table></figure></li><li><p>保存配置并重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line">sudo gitlab-ctl restart</span><br><span class="line">sudo gitlab-ctl status</span><br></pre></td></tr></table></figure></li></ol><p>访问 ip:82 成功。</p><h5 id="gitLab服务命令"><a href="#gitLab服务命令" class="headerlink" title="gitLab服务命令"></a>gitLab服务命令</h5><table><thead><tr><th>说明</th><th>常用命令</th></tr></thead><tbody><tr><td>重新加载配置， 每次修改/etc/gitlab/gitlab.rb文件之后执行</td><td>sudo gitlab-ctl reconfigure</td></tr><tr><td>启动</td><td>sudo gitlab-ctl start</td></tr><tr><td>停止</td><td>sudo gitlab-ctl stop</td></tr><tr><td>重启</td><td>sudo gitlab-ctl restart</td></tr><tr><td>查看状态</td><td>sudo gitlab-ctl status</td></tr><tr><td>查看所有日志</td><td>sudo gitlab-ctl tail</td></tr><tr><td>查看 nginx 访问日志</td><td>sudo gitlab-ctl tail nginx/gitlab_acces.log</td></tr><tr><td>查看 postgresql 日志</td><td>sudo gitlab-ctl tail postgresql</td></tr><tr><td>检查gitLab状态</td><td>gitlab-rake gitlab:check</td></tr><tr><td>检查环境和配置是否正确</td><td>gitlab-rake gitlab:env:info</td></tr><tr><td>清除缓存</td><td>gitlab-rake cache:clear</td></tr></tbody></table><h5 id="相关文件位置"><a href="#相关文件位置" class="headerlink" title="相关文件位置"></a>相关文件位置</h5><table><thead><tr><th>内容</th><th>位置</th></tr></thead><tbody><tr><td>日志</td><td>/var/log/gitlab</td></tr><tr><td>gitlab_url</td><td>/opt/gitlab/embedded/service/gitlab-shell/config.yml</td></tr><tr><td>nginx配置</td><td>/var/opt/gitlab/nginx/conf/gitlab-http.conf</td></tr><tr><td>gitlab主配置文件</td><td>/etc/gitlab/gitlab.rb</td></tr><tr><td>ssh路径url配置文件</td><td>/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</td></tr></tbody></table><h5 id="gitLab修改ssh默认端口"><a href="#gitLab修改ssh默认端口" class="headerlink" title="gitLab修改ssh默认端口"></a>gitLab修改ssh默认端口</h5><ul><li>vim /etc/gitlab/gitlab.rb<br>找到：gitlab_rails[‘gitlab_shell_ssh_port’] = 22</li><li>修改为：【你服务器ssh登录的端口】</li><li>重新编译：gitlab-ctl stop<br>gitlab-ctl reconfigure<br>gitlab-ctl start</li></ul><h5 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h5><blockquote><p>问题：访问报500错误<br>原因：运行gitlab-rake gitlab:check，发现gitlab-shell self-check failed；再运行sudo gitlab-ctl restart，发现redis出现timeout；<br>解决：找不到原因，暂时方法是 ps -ef | grep runsv 找到redis 的父级进程，kill -9 xxxx 全部杀掉后会自动拉起。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer autoload</title>
      <link href="/2019/09/19/composer-autoload/"/>
      <url>/2019/09/19/composer-autoload/</url>
      
        <content type="html"><![CDATA[<p>对于类库的自动加载，Composer 生成了一个 vendor/autoload.php 文件。引入这个文件，就能得到一个免费的自动加载支持。</p><blockquote><p>本文主要是介绍如何利用 Composer 自带的自动加载机制，加载本地自定义的包（即不是来自于 packagist）。</p></blockquote><a id="more"></a><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在 composer.json 文件中的 autoload 字段中添加自己的 autoloader。</p><h5 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">First/</span><br><span class="line">    |---examples/</span><br><span class="line">        |---get.php</span><br><span class="line">    |---src/</span><br><span class="line">        |---Curl.php</span><br><span class="line">    |---vendor/</span><br><span class="line">        |---composer/</span><br><span class="line">        |---autoload.php</span><br><span class="line">    |---composer.json</span><br><span class="line">    |---classmap</span><br><span class="line">        |---lib</span><br><span class="line">            |---src</span><br><span class="line">    |---ext</span><br><span class="line">        |---common</span><br><span class="line">        |   |---functions</span><br><span class="line">        |---system</span><br><span class="line">            |---functions</span><br></pre></td></tr></table></figure><h5 id="介绍PSR-4自动加载方式"><a href="#介绍PSR-4自动加载方式" class="headerlink" title="介绍PSR-4自动加载方式"></a>介绍PSR-4自动加载方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;First\\&quot;: &quot;src/&quot;,</span><br><span class="line">            &quot;Temp\\&quot;: &quot;lib/&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码采用 PSR-4 规范，该规范包含了 PHP 最新的自动加载标准，它要求必须使用 namespace （命名空间）的方式。</p><p>First\ 表示命名空间，必须以 \ 结尾，避免相似的命名空间导致冲突，若包含子命名空间，可以这样表示：First\Second\。</p><p>src/ 表示命名空间所在目录为与 Composer 的 vendor 目录同级的 src 目录，如上图框架结构所示。</p><p>如果需要在多个目录下搜索相同的命名前缀，可以用一个数组提供：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;First\\&quot;: [&quot;src/&quot;, &quot;lib/&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完 composer.json 的 autoload 字段后需要更新一下 Composer 的自动加载类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer dump-autoload</span><br></pre></td></tr></table></figure><p>对应 Curl.php 的命名空间如下表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace First;</span><br><span class="line"></span><br><span class="line">class Curl</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用 Curl.php 的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require &apos;../vendor/autoload.php&apos;;</span><br><span class="line"></span><br><span class="line">use First\Curl;</span><br><span class="line"></span><br><span class="line">$curl = new Curl();</span><br><span class="line">. . .</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><h5 id="classmap模式"><a href="#classmap模式" class="headerlink" title="classmap模式"></a>classmap模式</h5><p>懒加载，扫描目录下的所有类文件，支持递归扫描， 生成对应的类名=&gt;路径的映射，当载入需要的类时直接取出路径，速度最快<br><code>composer.json</code>的<code>autoload</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// classmap 扫描目录下的所有类文件 生成对应的类名=&gt;路径的映射</span><br><span class="line">&quot;classmap&quot;: [</span><br><span class="line">    &quot;classmap/lib/src/&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="files模式"><a href="#files模式" class="headerlink" title="files模式"></a>files模式</h5><p>自动载入的文件，主要用来载入一些没办法懒加载的公共函数<br><code>composer.json</code>的<code>autoload</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 扫描目录下的所有文件生成 hash =&gt; 路径的映射  运行时实时加载</span><br><span class="line">// 主要用来载入工具函数</span><br><span class="line">&quot;files&quot;: [</span><br><span class="line">    &quot;ext/common/functions.php&quot;,</span><br><span class="line">    &quot;ext/system/functions.php&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer镜像</title>
      <link href="/2019/09/19/composer-images/"/>
      <url>/2019/09/19/composer-images/</url>
      
        <content type="html"><![CDATA[<p>启用镜像服务的方式有两种：<br><strong>系统全局配置</strong> ：即将配置信息添加到composer的全局配置文件config.json中。<br><strong>单个项目配置</strong> ：将配置信息添加到某个项目的composer.json文件中</p><a id="more"></a><ul><li><p>修改composer 的全局配置文件<br>打开命令行（windows用户）或控制台（Linux、Mac用户）并执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- phpcomposer ---</span><br><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br><span class="line">--- aliyun 推荐 ---</span><br><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure></li><li><p>修改当前项目的composer.json配置文件：<br>进入项目根目录（也就是composer.json文件所在目录），执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure></li></ul><p>上述命令将会在当前项目中的composer.json文件的末尾自动添加镜像的配置信息（你自己也可以手动添加）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">        &quot;url&quot; : &quot;https://packagist.phpcomposer.com&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>查看composer镜像地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -gl</span><br></pre></td></tr></table></figure></li><li><p>取消配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g --unset repos.packagist</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer简介</title>
      <link href="/2019/09/19/composer/"/>
      <url>/2019/09/19/composer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。</p></blockquote><a id="more"></a><h5 id="简单解释"><a href="#简单解释" class="headerlink" title="简单解释"></a>简单解释</h5><ul><li><strong>composer install</strong> - 如有 composer.lock 文件，直接安装，否则从 composer.json 安装最新扩展包和依赖；</li><li><strong>composer update</strong> - 从 composer.json 安装最新扩展包和依赖；</li><li><strong>composer update vendor/package</strong> - 从 composer.json 或者对应包的配置，并更新到最新；</li><li><strong>composer require new/package</strong> - 添加安装 new/package , 可以指定版本，如： composer require new/package ~2.5。</li></ul><p>介绍几个日常生产流程</p><ol><li>新项目流程</li></ol><ul><li>运行 composer install ，安装扩展包并生成 composer.lock ；</li><li>提交 composer.lock 到代码版本控制器中，如：git;</li></ul><ol start="2"><li>项目协作者安装现有项目</li></ol><ul><li>克隆项目后，根目录下直接运行 composer install 从 composer.lock 中安装 指定版本 的扩展包以及其依赖；<blockquote><p>此流程适用于生产环境代码的部署。</p></blockquote></li></ul><ol start="3"><li>为项目添加新扩展包</li></ol><ul><li>使用 composer require vendor/package 添加扩展包；</li><li>提交更新后的 composer.json 和 composer.lock 到代码版本控制器中，如：git;</li></ul><h5 id="关于-composer-lock-文件"><a href="#关于-composer-lock-文件" class="headerlink" title="关于 composer.lock 文件"></a>关于 composer.lock 文件</h5><blockquote><p><strong>composer.lock</strong>  文件里保存着对每一个代码依赖的版本记录（见下图），提交到版本控制器中，并配合  <strong>composer install</strong>  使用，保证了团队所有协作者开发环境、线上生产环境中运行的代码版本的一致性。</p></blockquote><h5 id="关于扩展包的安装方法"><a href="#关于扩展包的安装方法" class="headerlink" title="关于扩展包的安装方法"></a>关于扩展包的安装方法</h5><p>那么，准备添加一个扩展包，install, update, require 三个命令都可以用来安装扩展包，选择哪一个才是正确的呢？<br>答案是：使用 <strong>composer require</strong> 命令</p><p>另外，在手动修改 composer.json 添加扩展包后， <strong>composer update new/package</strong> 进行指定扩展包更新的方式，也可以正确的安装，不过不建议使用这种方法，因为，一旦你忘记敲定后面的扩展包名，就会进入万劫不复的状态，别给自己留坑呀。</p><p>上面的概念不论对新手或者老手来说，都比较混淆，主要记住这个概念：</p><blockquote><p>原有项目新添加扩展的，都使用 <strong>composer require new/package</strong> 这种方式来安装。</p></blockquote><p>更新指定扩展到指定版本可以指定版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require &quot;foo/bar:1.0.0&quot;</span><br></pre></td></tr></table></figure><h5 id="composer其他"><a href="#composer其他" class="headerlink" title="composer其他"></a>composer其他</h5><ul><li>composer 自身升级：<strong>composer self-update</strong></li><li>composer 回滚：<strong>composer self-update –rollback</strong></li><li>composer中require 和 require-dev的区别：前者用于声明项目发布版本的依赖包，后者用于声明项目开发或测试中依赖的包。</li></ul><h5 id="composer版本号-前置-和-符号的区别"><a href="#composer版本号-前置-和-符号的区别" class="headerlink" title="composer版本号 前置~和^符号的区别"></a>composer版本号 前置~和^符号的区别</h5><p><code>~</code>和<code>^</code>的意思很接近，在<code>x.y</code>的情况下是一样的都是代表<code>x.y &lt;= 版本号 &lt; (x+1).0</code>，但是在版本号是<code>x.y.z</code>的情况下有区别，举个例子吧：</p><ul><li>~1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 1.3.0</li><li>^1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 2.0.0</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>govendor</title>
      <link href="/2019/09/18/govendor/"/>
      <url>/2019/09/18/govendor/</url>
      
        <content type="html"><![CDATA[<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><code>go get -u github.com/kardianos/govendor</code></p><a id="more"></a><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在项目根目录下执行以下命令进行vendor初始化：<br><code>govendor init</code></p><p>项目根目录下即会自动生成 vendor 目录和 vendor.json 文件</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><ul><li><p>将 已被引用 且在 $GOPATH 下的所有包复制到vendor目录<br><code>govendor add +external</code></p></li><li><p>仅从 $GOPATH 中复制指定包<br><code>govendor add gopkg.in/yaml.v2</code></p></li><li><p>列出代码中所有被引用到的包及其状态<br><code>govendor list</code></p></li><li><p>从远程仓库添加或更新某个包(不会在 $GOPATH 也存一份)<br><code>govendor fetch golang.org/x/net/context</code></p></li><li><p>安装指定版本的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</span><br><span class="line">govendor fetch golang.org/x/net/context@v1   # Get latest v1.*.* tag or branch.</span><br><span class="line">govendor fetch golang.org/x/net/context@=v1  # Get the tag or branch named &quot;v1&quot;.</span><br></pre></td></tr></table></figure></li><li><p>删除vendor中已有 但是代码中未使用的包<br><code>govendor remove +unused</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> govendor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>supervisor 维护 golang 进程</title>
      <link href="/2019/09/18/go-supervisor/"/>
      <url>/2019/09/18/go-supervisor/</url>
      
        <content type="html"><![CDATA[<h4 id="代码准备工作"><a href="#代码准备工作" class="headerlink" title="代码准备工作"></a>代码准备工作</h4><p>在代码目录执行<code>go build</code>或者<code>go install</code>来生成可执行文件</p><blockquote><p>注意：如果使用<code>go install</code>生成在bin目录下的可执行文件，需要注意代码中的日志目录问题</p></blockquote><a id="more"></a><h4 id="安装supervisor"><a href="#安装supervisor" class="headerlink" title="安装supervisor"></a>安装supervisor</h4><p>官网地址：<a href="http://supervisord.org/index.html" target="_blank" rel="noopener">http://supervisord.org/index.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python-setuptools</span><br><span class="line">sudo easy_install supervisor 或者 sudo pip install supervisor</span><br></pre></td></tr></table></figure><p>安装成功后，生成配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure><h4 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h4><p>新建一个文件夹专门放置.conf文件</p><p>在<code>/etc/</code>下新建<code>supervisor_conf_file</code>文件夹，并在该文件加下新建<code>gin_api.conf</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[program:gin_api]</span><br><span class="line">user=root</span><br><span class="line">command=/home/go/src/gin_api/gin_api #go可执行文件路劲</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=10</span><br><span class="line">stdout_logfile=/root/supervisor_log/gin_api.log #标准输出log，得去相应的目录下新建log</span><br><span class="line">stdout_logfile_maxbytes=1MB</span><br><span class="line">stdout_logfile_backups=10</span><br><span class="line">stdout_capture_maxbytes=1MB</span><br><span class="line">stderr_logfile=/root/supervisor_log/gin_api_err.log #错误输出log，得去相应的目录下新建log</span><br><span class="line">stderr_logfile_maxbytes=1MB</span><br><span class="line">stderr_logfile_backups=10</span><br><span class="line">stderr_capture_maxbytes=1MB</span><br><span class="line">stopsignal=INT</span><br><span class="line">[supervisord]</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">command：表示运行的命令，我这是填写的我demo安装包的原则路径。</span><br><span class="line">autostart：表示是否跟随supervisor一起启动。</span><br><span class="line">autorestart：如果该程序挂了，是否重新启动。</span><br><span class="line">stdout_logfile：终端标准输出重定向文件。</span><br><span class="line">stderr_logfile：终端错误输出重定向文件。</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>编辑 <code>/etc/supervisord.conf</code>，将文件最下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;[include]</span><br><span class="line">;files = relative/directory/*.ini</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files = /etc/supervisor_conf_file/*.conf</span><br></pre></td></tr></table></figure><h4 id="启动supervisord"><a href="#启动supervisord" class="headerlink" title="启动supervisord"></a>启动supervisord</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>若报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Another program is already listening on a port that one of our HTTP servers is configured to use.  Shut this program down first before starting supervisord.</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name supervisor.sock</span><br><span class="line">unlink /xxx/supervisor.sock</span><br></pre></td></tr></table></figure><p>之后再次执行启动命令。</p><p>执行命令查看gin_api服务是否启动成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo supervisorctl status</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gin_api                          RUNNING   pid 7648, uptime 0:09:57</span><br></pre></td></tr></table></figure><p>ps:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@accapp /home/go/src/gin_api]# supervisorctl </span><br><span class="line">gin_api                          RUNNING   pid 7648, uptime 0:02:39</span><br><span class="line">supervisor&gt; help</span><br><span class="line"></span><br><span class="line">default commands (type help &lt;topic&gt;):</span><br><span class="line">=====================================</span><br><span class="line">add    exit      open  reload  restart   start   tail   </span><br><span class="line">avail  fg        pid   remove  shutdown  status  update </span><br><span class="line">clear  maintail  quit  reread  signal    stop    version</span><br><span class="line"></span><br><span class="line">supervisor&gt; exit</span><br><span class="line">[root@accapp /home/go/src/gin_api]#</span><br></pre></td></tr></table></figure><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul><li><p>停止supervisor(子进程也会被停止)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl shutdown</span><br></pre></td></tr></table></figure></li><li><p>把 supervisor 相关的进程都杀掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(ps -ef|grep supervisor | awk &apos;&#123;print $2&#125;&apos;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="解决unix-tmp-supervisor-sock-no-such-file的问题"><a href="#解决unix-tmp-supervisor-sock-no-such-file的问题" class="headerlink" title="解决unix:///tmp/supervisor.sock no such file的问题"></a>解决unix:///tmp/supervisor.sock no such file的问题</h4><p>原因：tmp目录中的文件被Linux自动清除了</p><ol><li><p>新建目录和修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p  /var/supervisor_tmp/run</span><br><span class="line">sudo mkdir -p  /var/supervisor_tmp/log</span><br><span class="line"></span><br><span class="line">sudo chmod 777 /var/supervisor_tmp/run</span><br><span class="line">sudo chmod 777 /var/supervisor_tmp/log</span><br></pre></td></tr></table></figure></li><li><p>修改/etc/supervisor.conf配置文件<br>把所有的<code>/tmp</code>路径修改掉：<br><code>/tmp/supervisor.sock</code> 改成 <code>/var/supervisor_tmp/run/supervisor.sock</code><br><code>/tmp/supervisord.log</code> 改成 <code>/var/supervisor_tmp/log/supervisor.log</code><br><code>/tmp/supervisord.pid</code> 改成 <code>/var/supervisor_tmp/run/supervisor.pid</code></p></li><li><p>重启<br>杀掉supervisor进程和子进程，再启动supervisor</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> supervisor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>provide 和 inject</title>
      <link href="/2019/09/18/provide-and-inject/"/>
      <url>/2019/09/18/provide-and-inject/</url>
      
        <content type="html"><![CDATA[<p><strong>官网解释</strong>：<a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">provider/inject</a></p><p><strong>provider/inject</strong>：简单的来说就是在父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。</p><blockquote><p>需要注意的是这里不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据。</p></blockquote><a id="more"></a><p>示例：</p><ul><li><p>first：定义一个parent component, 在这里我们在父组件中provide for这个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;childOne&gt;&lt;/childOne&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import childOne from &apos;../components/test/ChildOne&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &quot;Parent&quot;,</span><br><span class="line">    provide() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            for: &quot;demo&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        childOne</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>second 定义一个子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;demo&#125;&#125;</span><br><span class="line">    &lt;childtwo&gt;&lt;/childtwo&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import childtwo from &apos;./ChildTwo&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;childOne&quot;,</span><br><span class="line">    inject: [&apos;for&apos;],</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        demo: this.for</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      childtwo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>third 定义另一个子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;demo&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    inject: [&apos;for&apos;],</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        demo: this.for</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>在2个子组件中我们使用jnject注入了provide提供的变量for，并将它提供给了data属性。</p><p>运行结果是 demo demo</p><blockquote><p>从上面这个例子可以看出，只要在父组件中调用了，那么在这个父组件生效的生命周期内，所有的子组件都可以调用inject来注入父组件中的值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive的作用</title>
      <link href="/2019/09/18/keep-alive/"/>
      <url>/2019/09/18/keep-alive/</url>
      
        <content type="html"><![CDATA[<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在vue项目中,难免会有列表页面或者搜索结果列表页面,点击某个结果之后,返回回来时,如果不对结果页面进行缓存,那么返回列表页面的时候会回到初始状态,但是我们想要的结果是返回时这个页面还是之前搜索的结果列表,这时候就需要用到vue的keep-alive技术了.<br>本人遇到的问题是element切换tab的时候，页面不会缓存，所以需要使用keep-alive。</p><a id="more"></a><h5 id="keep-alive-简介"><a href="#keep-alive-简介" class="headerlink" title="keep-alive 简介"></a>keep-alive 简介</h5><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p><p>用法也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- 该组件将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p><strong>props</strong></p><ul><li>include - 字符串或正则表达，只有匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 组件 a</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;a&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;a&quot;&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- name 为 a 的组件将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude=&quot;a&quot;&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><h5 id="配合vue-router共同使用"><a href="#配合vue-router共同使用" class="headerlink" title="配合vue-router共同使用"></a>配合vue-router共同使用</h5><p>但实际项目中,常需要配合vue-router共同使用.</p><p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view&gt;</span><br><span class="line">        &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt;</span><br><span class="line">    &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>如果只想 router-view 里面某个组件被缓存，怎么办？</p><p>增加 <strong>router.meta</strong> 属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// routes 配置</span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    name: &apos;home&apos;,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: true // 需要被缓存</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &apos;/:id&apos;,</span><br><span class="line">    name: &apos;edit&apos;,</span><br><span class="line">    component: Edit,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: false // 不需要被缓存</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;</span><br><span class="line">        &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;</span><br><span class="line">    &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;</span><br><span class="line">    &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel篇</title>
      <link href="/2019/08/08/laravel-question/"/>
      <url>/2019/08/08/laravel-question/</url>
      
        <content type="html"><![CDATA[<h6 id="1-简述laravel的生命周期"><a href="#1-简述laravel的生命周期" class="headerlink" title="1. 简述laravel的生命周期"></a>1. 简述laravel的生命周期</h6><p><img src="https://www.zlf520.com.cn/storage/blog/2D6A568E-F7DD-4DAF-B460-A7C0BD15DA60.png" alt="2623c78f9e824fb89db4552be669404c"></p><a id="more"></a><ol><li>导入composer自动加载功能，加载框架类库</li><li>引入laravel应用程序实例App</li></ol><ul><li>启动容器</li><li>注册http处理器</li><li>注册console处理器</li><li>注册异常处理器</li></ul><ol start="3"><li>启动http处理器，接收request请求</li><li>以管道的设计模式，执行部分（全局）中间件</li><li>路由解析调度</li><li>实例化当前控制器</li><li>执行web中间件</li><li>执行控制器中间件</li><li>执行控制器操作</li><li>返回response</li><li>结束框架</li></ol><hr><blockquote><p>Laravel采用了单一的入口模式，应用的所有请求入口都是public/index.php文件。</p><ol><li>注册类文件自动加载器：laravel通过composer进行依赖管理，无需开发者手动导入各种类文件，而由自动加载器自行导入。</li><li>创建服务容器：从bootstrap/app.php文件中取得laravel应用实例$app（服务容器）</li><li>创建HTTP/Console内核：传入的请求会被发送给HTTP内核或者console内核进行处理</li><li>载入服务提供者至容器：在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的应用，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件</li><li>分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给路由进行分发。路由将分发请求给一个路由或控制器，同时运行路由指定的中间件</li></ol></blockquote><hr><h6 id="2-服务提供者是什么？"><a href="#2-服务提供者是什么？" class="headerlink" title="2. 服务提供者是什么？"></a>2. 服务提供者是什么？</h6><blockquote><p>服务提供者是所有laravel应用程序引导启动的中心，laravel的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。</p></blockquote><h6 id="3-IoC容器是什么？"><a href="#3-IoC容器是什么？" class="headerlink" title="3. IoC容器是什么？"></a>3. IoC容器是什么？</h6><blockquote><p>IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。</p><p>Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。</p></blockquote><h6 id="4-Facades-是什么？"><a href="#4-Facades-是什么？" class="headerlink" title="4. Facades 是什么？"></a>4. Facades 是什么？</h6><blockquote><p>Facades（一种设计模式，通常翻译为外观模式）提供了一个”static”（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。</p></blockquote><h6 id="5-Contract-是什么？"><a href="#5-Contract-是什么？" class="headerlink" title="5. Contract 是什么？"></a>5. Contract 是什么？</h6><blockquote><p>Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。</p></blockquote><h6 id="6-谈谈-Laravel-和-YII-框架的区别"><a href="#6-谈谈-Laravel-和-YII-框架的区别" class="headerlink" title="6. 谈谈 Laravel 和 YII 框架的区别"></a>6. 谈谈 Laravel 和 YII 框架的区别</h6><blockquote><ol><li>在 YII 框架中的路由是通过书写 Controller、Action 间接定义路由，而 Laravel 中是在 route 路由文件中直接定义路由入口</li><li>Laravel 提供 ORM 对象关系映射，使读写数据库的操作更加简单</li><li>Laravel 提供更多的 Artisan 命令和脚手架开发</li><li>Laravel 的 Composer 扩展包比 Yii 框架更多，开发更加高效</li></ol></blockquote><h6 id="7-谈谈-Laravel-和-TP5-框架的区别"><a href="#7-谈谈-Laravel-和-TP5-框架的区别" class="headerlink" title="7. 谈谈 Laravel 和 TP5 框架的区别"></a>7. 谈谈 Laravel 和 TP5 框架的区别</h6><blockquote><ol><li>提交数据的方式：laravel在提交表单的时候需要在表单中加入{csrc_field}来防止跨域攻击；TP不会。</li><li>路由：laravel必须先定义，再使用；TP在配置文件中开启路由。</li><li>中间件：laravel中间件，就是http请求到达之前经过的层，通过中间件我们可以验证用户是否登录等一些通用操作。</li><li>操作数据库的方式：都可以使用实例化（建立相对应的模型类）和DB::table来操作数据库。使用原生查询时不太一样，laravel使用Db::操作(‘原生sql’)，TP使用Db::query(‘原生sql’)。</li><li>Laravel升级十分简易，而TP大版本的升级要重构代码。</li><li>条件判断语句书写方式的差异： laravel框架里 if else判断语句和foreach语句 书写时必须以@if开头  以@endif结尾,如果没有则报语法错误,@foreach @endforeach同理；而TP框架则和PHP语法规则使用方式一致直接ifesle语句判断和foreach循环遍历。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx和php-fpm结合</title>
      <link href="/2019/08/08/nginx-and-php-fpm/"/>
      <url>/2019/08/08/nginx-and-php-fpm/</url>
      
        <content type="html"><![CDATA[<pre><code>Nginx不只有处理http请求的功能，还能做反向代理。Nginx通过反向代理功能将动态请求转向后端Php-fpm。</code></pre><blockquote><p>在 Linux 上，nginx 与 php-fpm 的通信有 tcp socket 和 unix socket 两种方式。</p></blockquote><ul><li>tcp socket 的优点是可以跨服务器，当 nginx 和 php-fpm 不在同一台机器上时，只能使用这种方式。</li><li>Unix socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信，这种方式需要在 nginx配置文件中填写 php-fpm 的 socket 文件位置。</li></ul><a id="more"></a><p>两种方式的数据传输过程如下图所示：<br><img src="http://www.zlf520.com.cn/storage/blog/157A0895-F0C5-4DF6-AC53-3DB3A8C02F89.png" alt="40ef8c1f5cb07d102bc9b37368a786e5"></p><p>二者的不同：</p><blockquote><p>由于 Unix socket 不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。所以其效率比 tcp socket 的方式要高，可减少不必要的 tcp 开销。不过，unix socket 高并发时不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。而 tcp 这样的面向连接的协议，可以更好的保证通信的正确性和完整性。</p></blockquote><p><strong>下面我们来配置一个全新的Nginx+Php-fpm</strong></p><ol><li><p>配置nginx.conf文件<br>进入nginx目录下，编辑nginx.conf文件。<br>如图，在nginx.conf最后一行，添加include文件<br><img src="https://www.zlf520.com.cn/storage/blog/B7B7E402-287A-48B6-BCBA-AABA649299EC.png" alt="d1e54053831e3288467bad22e8ebaeb5"></p></li><li><p>添加对应的server<br>进入上面的include的路径，添加一个server<br><img src="https://www.zlf520.com.cn/storage/blog/021D27C6-11AC-4B88-B4BA-1F2813999A00.png" alt="dc5882516f01acc2bca56dea6c685fa7"><br>unix socket 方式 修改fastcgi_pass如下<br><code>fastcgi_pass unix:/usr/run/php-fpm.sock</code></p></li></ol><p><strong>下面我们解释下配置项的含义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80; #监听80端口，接收http请求</span><br><span class="line">    server_name  www.example.com; #就是网站地址</span><br><span class="line">    root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径</span><br><span class="line">    #路由到网站根目录www.example.com时候的处理</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.php; #跳转到www.example.com/index.php</span><br><span class="line">        autoindex on;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    #当请求网站下php文件的时候，反向代理到php-fpm</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块</span><br><span class="line">        fastcgi_intercept_errors on;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口</span><br><span class="line">        # fasrcgi_pass /usr/run/php-fpm.sock   #unix socket 连接方式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面我们启用php的php-fpm来处理这个请求</strong><br>打开php-fpm.conf文件，我们看到如下配置：<br><img src="https://www.zlf520.com.cn/storage/blog/D15767C9-0B46-4DF9-97FD-F4D60A5F96B7.png" alt="ab60dcdb0f77e985dc233cd54e0b2fb8"><br>unix socket 方式 修改php-fpm.conf如下<br><code>listen = /usr/run/php-fpm.sock</code></p><blockquote><p>即：php-fpm模块监听127.0.0.1:9000端口 或者 php-fpm.sock文件，等待请求到来去处理。</p></blockquote><blockquote><p>注意：在使用 unix socket 方式连接时，由于 socket 文件本质上是一个文件，存在权限控制的问题，所以需要注意 nginx 进程的权限与 php-fpm 的权限问题，不然会提示无权限访问。（在各自的配置文件里设置用户）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> php-fpm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac + Hexo + GitHub + Next 搭建博客</title>
      <link href="/2019/07/09/mac-hexo/"/>
      <url>/2019/07/09/mac-hexo/</url>
      
        <content type="html"><![CDATA[<h5 id="1-安装node-js-和-git"><a href="#1-安装node-js-和-git" class="headerlink" title="1. 安装node.js 和 git"></a>1. 安装node.js 和 git</h5><p>mac上使用brew安装node 和 git<br>测试安装是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v   </span><br><span class="line"># 同时可以配置下npm镜像：npm config set registry https://registry.npm.taobao.org</span><br><span class="line"># 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info express</span><br><span class="line">git --versoin</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h5><p>安装时注意权限问题，加上sudo，其中-g表示全局安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>npm全局安装的包的存储路径是<code>/usr/local/lib/node_modules/</code></p><h5 id="3-博客初始化"><a href="#3-博客初始化" class="headerlink" title="3. 博客初始化"></a>3. 博客初始化</h5><p>创建博客的文件夹，并进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure><p>初始化博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 安装时 node-pre-gyp 报错，执行如下命令可以解决</span><br><span class="line">sudo npm install --unsafe-perm</span><br></pre></td></tr></table></figure><p>执行下述命令生成本地网页文件并开启服务器，然后通过<a href="http://localhost:4000查看本地博客" target="_blank" rel="noopener">http://localhost:4000查看本地博客</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g</span><br><span class="line">sudo hexo s  或者 sudo hexo s -p 4000</span><br></pre></td></tr></table></figure><h5 id="4-上传github"><a href="#4-上传github" class="headerlink" title="4. 上传github"></a>4. 上传github</h5><p>在github中新建仓库，名称必须为 <code>user.github.io</code>，如：<code>Liwen-Git.github.io</code></p><p>配置hexo的_config.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  blog</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure><p>在文档的最后部分，将deploy配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/Liwen-Git/Liwen-Git.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>注意type、repository、branch后均有空格。通过如下命令在blog下生成静态文件并上传到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g</span><br><span class="line"># 出错执行 sudo npm install hexo --save</span><br><span class="line">sudo hexo d</span><br><span class="line"># 出错执行 sudo npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>执行<code>hexo d</code> 时会提示输入GitHub账号用户名和密码，执行成功之后通过 <a href="https://liwen-git.github.io/" target="_blank" rel="noopener">https://liwen-git.github.io/</a> 访问博客</p><h5 id="5-更换Next主题"><a href="#5-更换Next主题" class="headerlink" title="5. 更换Next主题"></a>5. 更换Next主题</h5><p>推荐使用hexo-theme-next主题<br>在blog目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><p>修改blog目录下_config.yml里的theme名称为：next<br>其他的，如title: 李子园、language: zh-CN、都可以自己配置</p><p>执行如下命令（每次部署文章的步骤）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g  //生成缓存和静态文件</span><br><span class="line">sudo hexo d  //重新部署到服务器</span><br></pre></td></tr></table></figure><p>当本地博客部署到服务器后，网页端无变化时可以采用下述命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo clean  //清楚缓存文件(db.json)和已生成的静态文件(public)</span><br></pre></td></tr></table></figure><h5 id="6-配置next主题"><a href="#6-配置next主题" class="headerlink" title="6. 配置next主题"></a>6. 配置next主题</h5><p>修改next主题的配置文件_config.yml主题为：Gemini（打开注释）</p><p>修改next主题配置文件，在menu处，打开tags和categories的注释</p><ul><li>创建tag页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure></li></ul><p>然后再blog/sources中会多了一个tags文件夹，修改其中的index.md文件，type修改为tags</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-07-08 23:15:25</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>创建categories页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure></li></ul><p>然后再blog/sources中会多了一个categories文件夹，修改其中的index.md文件，type修改为categories</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-07-08 23:15:25</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h5 id="7-安装搜索功能-Local-Search"><a href="#7-安装搜索功能-Local-Search" class="headerlink" title="7. 安装搜索功能 Local Search"></a>7. 安装搜索功能 Local Search</h5><p>在next的_config.yml文件中修改Local Search的<code>enable: true</code><br>在根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-generator-search --save</span><br><span class="line">sudo npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>在根目录的_config.yml文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><h5 id="8-新建文章"><a href="#8-新建文章" class="headerlink" title="8. 新建文章"></a>8. 新建文章</h5><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo new post 文件名可以不是文章名</span><br></pre></td></tr></table></figure><p>给文章添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Mac + Hexo + GitHub + Next 搭建博客</span><br><span class="line">date: 2019-07-08 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- mac</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">- next</span><br><span class="line">- 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>站点首页不显示文章全文，文章摘要设置<br>这里我们可以通过在文章使用<code>&lt;!-- more --&gt;</code>标志来精确控制文章的摘要预览</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/07/08/php-design-patterns/"/>
      <url>/2019/07/08/php-design-patterns/</url>
      
        <content type="html"><![CDATA[<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。</p><p>策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。</p><p>策略模式的三个角色：</p><ol><li>抽象策略角色</li><li>具体策略角色</li><li>环境角色（对抽象策略角色的引用）</li></ol><p>实现步骤：</p><ol><li>定义抽象角色类（定义好各个实现的共同抽象方法）</li><li>定义具体策略类（具体实现父类的共同方法）</li><li>定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法）</li></ol><a id="more"></a><p>就在编程领域外，有许多例子是关于策略模式的。例如：</p><p>如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。</p><p>策略模式的代码实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 抽象策略类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">baseAgent</span> </span>&#123;</span><br><span class="line">            <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">PrintPage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于客户端是IE时调用的类（环境角色）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ieAgent</span> <span class="keyword">extends</span> <span class="title">baseAgent</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">PrintPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'IE'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于客户端不是IE时调用的类（环境角色）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">otherAgent</span> <span class="keyword">extends</span> <span class="title">baseAgent</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">PrintPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'not IE'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">call</span><span class="params">($object)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> $object-&gt;PrintPage();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$bro = <span class="keyword">new</span> Browser();</span><br><span class="line"><span class="keyword">echo</span> $bro-&gt;call(<span class="keyword">new</span> ieAgent());</span><br></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。</p><p>使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">// 简单工厂模式（静态工厂方法模式）</span></span><br><span class="line">    <span class="comment">// Interface people 人类</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">people</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Class man 继承people的男人类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">man</span> <span class="keyword">implements</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">// 具体实现people的say方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我是男人&lt;br&gt;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Class women 继承people的女人类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">women</span> <span class="keyword">implements</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">// 具体实现people的say方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我是女人&lt;br&gt;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Class SimpleFactory 工厂类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单工厂里的静态方法-用于创建男人对象</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createMan</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> man();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 简单工厂里的静态方法-用于创建女人对象</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createWomen</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> women();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体调用</span></span><br><span class="line">    $man = SimpleFactoty::createMan();</span><br><span class="line">    $man-&gt;say();</span><br><span class="line">    $woman = SimpleFactoty::createWomen();</span><br><span class="line">    $woman-&gt;say();</span><br></pre></td></tr></table></figure><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。</p><p>单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。</p><p>单例模式有以下3个特点：</p><ol><li>只能有一个实例</li><li>必须自行创建这个实例</li><li>必须给其他对象提供这一实例</li></ol><p>那么为什么要使用PHP单例模式？</p><p>PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $name;<span class="comment">//声明一个私有的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明私有构造方法为了防止外部代码使用new来创建对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> $instance;<span class="comment">//声明一个静态变量（保存在类中唯一的一个实例）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个getinstance()静态方法，用于检测是否有实例对象</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">self</span>::$instance) &#123;</span><br><span class="line">            <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setname</span><span class="params">($n)</span></span>&#123; <span class="keyword">$this</span>-&gt;name = $n; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getname</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$oa = Single::getinstance();</span><br><span class="line">$ob = Single::getinstance();</span><br><span class="line">$oa-&gt;setname(<span class="string">'hello world'</span>);</span><br><span class="line">$ob-&gt;setname(<span class="string">'good morning'</span>);</span><br><span class="line"><span class="keyword">echo</span> $oa-&gt;getname();<span class="comment">//good morning</span></span><br><span class="line"><span class="keyword">echo</span> $ob-&gt;getname();<span class="comment">//good morning</span></span><br></pre></td></tr></table></figure><h4 id="注册模式"><a href="#注册模式" class="headerlink" title="注册模式"></a>注册模式</h4><p>注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> $objects;</span><br><span class="line">    <span class="comment">//将对象注册到全局的树上</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">($alias, $object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::$objects[$alias]=$object;<span class="comment">//将对象放到树上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$objects[$name];<span class="comment">//获取某个注册到树上的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_unset</span><span class="params">($alias)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="keyword">self</span>::$objects[$alias]);<span class="comment">//移除某个注册到树上的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>将各种截然不同的函数接口封装成统一的API。</p><p>PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 </p><p>首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">接口 IDatabase</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">IMooc</span>;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IDatabase</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MySQL</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">IMooc</span>\<span class="title">Database</span>;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">IMooc</span>\<span class="title">IDatabase</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySql</span> <span class="keyword">implements</span> <span class="title">IDatabase</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> $conn;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span> </span>&#123;</span><br><span class="line">            $conn = mysql_connect($host, $user, $passwd);</span><br><span class="line">            mysql_select_db($dbname);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;conn = $conn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span> </span>&#123;</span><br><span class="line">            $res = mysql_query($sql, <span class="keyword">$this</span>-&gt;conn);</span><br><span class="line">            <span class="keyword">return</span> $res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mysql_close(<span class="keyword">$this</span>-&gt;conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MySQLi</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">IMooc</span>\<span class="title">Database</span>;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">IMooc</span>\<span class="title">IDatabase</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySQLi</span> <span class="keyword">implements</span> <span class="title">IDatabase</span></span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> $conn;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span></span>&#123;</span><br><span class="line">            $conn = mysqli_connect($host, $user, $passwd, $dbname);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;conn = $conn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mysqli_query(<span class="keyword">$this</span>-&gt;conn, $sql);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            mysqli_close(<span class="keyword">$this</span>-&gt;conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ol><li>观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。  </li><li>场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 </li><li>观察者模式实现了低耦合，非侵入式的通知与更新机制。 </li></ol><p>定义一个事件触发抽象类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EventGenerator.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventGenerator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> $observers = <span class="keyword">array</span>();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">addObserver</span><span class="params">(Observer $observer)</span></span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;observers[]=$observer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;observers <span class="keyword">as</span> $observer)&#123;</span><br><span class="line">                $observer-&gt;update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>定义一个观察者接口 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observer.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>; <span class="comment">// 这里就是在事件发生后要执行的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> <span class="keyword">extends</span> <span class="title">EventGenerator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">triger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Event&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"逻辑1 &lt;br/&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"逻辑2 &lt;br/&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$event = <span class="keyword">new</span> Event();</span><br><span class="line">$event-&gt;addObserver(<span class="keyword">new</span> Observer1());</span><br><span class="line">$event-&gt;addObserver(<span class="keyword">new</span> Observer2());</span><br><span class="line">$event-&gt;triger();</span><br><span class="line">$event-&gt;notify();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fmt格式 “占位符”</title>
      <link href="/2019/07/08/go-fmt/"/>
      <url>/2019/07/08/go-fmt/</url>
      
        <content type="html"><![CDATA[<p>golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义示例类型和变量</span><br><span class="line">type Human struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people = Human&#123;Name: &quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>普通占位符</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%v</td><td>相应值的默认格式</td><td>Printf(“%v”, people)</td><td>{zhangsan}</td></tr><tr><td>%+v</td><td>打印结构体时，会添加字段名</td><td>Printf(“%+v”, people)</td><td>{Name:zhangsan}</td></tr><tr><td>%#v</td><td>相应值的Go语法表示</td><td>Printf(“#v”, people)</td><td>main.Human{Name:”zhangsan”}</td></tr><tr><td>%T</td><td>相应值的类型的Go语法表示</td><td>Printf(“%T”, people)</td><td>main.Human</td></tr><tr><td>%%</td><td>字面上的百分号，并非值的占位符</td><td>Printf(“%%”)</td><td>%</td></tr></tbody></table><a id="more"></a><ul><li>布尔占位符</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%t</td><td>true 或 false</td><td>Printf(“%t”, true)</td><td>true</td></tr></tbody></table><ul><li>整数占位符</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%b</td><td>二进制表示</td><td>Printf(“%b”, 5)</td><td>101</td></tr><tr><td>%c</td><td>相应Unicode码点所表示的字符</td><td>Printf(“%c”, 0x4E2D)</td><td>中</td></tr><tr><td>%d</td><td>十进制表示</td><td>Printf(“%d”, 0x12)</td><td>18</td></tr><tr><td>%o</td><td>八进制表示</td><td>Printf(“%d”, 10)</td><td>12</td></tr><tr><td>%q</td><td>单引号围绕的字符字面值，由Go语法安全地转义</td><td>Printf(“%q”, 0x4E2D)</td><td>‘中’</td></tr><tr><td>%x</td><td>十六进制表示，字母形式为小写 a-f</td><td>Printf(“%x”, 13)</td><td>d</td></tr><tr><td>%X</td><td>十六进制表示，字母形式为大写 A-F</td><td>Printf(“%x”, 13)</td><td>D</td></tr><tr><td>%U</td><td>Unicode格式：U+1234，等同于 “U+%04X”</td><td>Printf(“%U”, 0x4E2D)</td><td>U+4E2D</td></tr></tbody></table><ul><li>浮点数和复数的组成部分（实部和虚部）</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%e</td><td>科学计数法，例如 -1234.456e+78</td><td>Printf(“%e”, 10.2)</td><td>1.020000e+01</td></tr><tr><td>%E</td><td>科学计数法，例如 -1234.456E+78</td><td>Printf(“%e”, 10.2)</td><td>1.020000E+01</td></tr><tr><td>%f</td><td>有小数点而无指数，例如 123.456</td><td>Printf(“%f”, 10.2)</td><td>10.200000</td></tr><tr><td>%g</td><td>根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td><td>Printf(“%g”, 10.20)</td><td>10.2</td></tr><tr><td>%G</td><td>根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td><td>Printf(“%G”, 10.20+2i)</td><td>(10.2+2i)</td></tr></tbody></table><ul><li>字符串与字节切片</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%s</td><td>输出字符串表示（string类型或[]byte)</td><td>Printf(“%s”, []byte(“Go语言”))</td><td>Go语言</td></tr><tr><td>%q</td><td>双引号围绕的字符串，由Go语法安全地转义</td><td>Printf(“%q”, “Go语言”)</td><td>“Go语言”</td></tr><tr><td>%x</td><td>十六进制，小写字母，每字节两个字符</td><td>Printf(“%x”, “golang”)</td><td>676f6c616e67</td></tr><tr><td>%X</td><td>十六进制，大写字母，每字节两个字符</td><td>Printf(“%X”, “golang”)</td><td>676F6C616E67</td></tr></tbody></table><ul><li>指针</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>举例</th><th>输出</th></tr></thead><tbody><tr><td>%p</td><td>十六进制表示，前缀 0x</td><td>Printf(“%p”, &amp;people)</td><td>0x4f57f0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 占位符 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
