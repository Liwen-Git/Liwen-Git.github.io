<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[laravel篇]]></title>
    <url>%2F2019%2F08%2F08%2Flaravel-question%2F</url>
    <content type="text"><![CDATA[1. 简述laravel的生命周期 导入composer自动加载功能，加载框架类库 引入laravel应用程序实例App 启动容器 注册http处理器 注册console处理器 注册异常处理器 启动http处理器，接收request请求 以管道的设计模式，执行部分（全局）中间件 路由解析调度 实例化当前控制器 执行web中间件 执行控制器中间件 执行控制器操作 返回response 结束框架 Laravel采用了单一的入口模式，应用的所有请求入口都是public/index.php文件。 注册类文件自动加载器：laravel通过composer进行依赖管理，无需开发者手动导入各种类文件，而由自动加载器自行导入。 创建服务容器：从bootstrap/app.php文件中取得laravel应用实例$app（服务容器） 创建HTTP/Console内核：传入的请求会被发送给HTTP内核或者console内核进行处理 载入服务提供者至容器：在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的应用，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件 分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给路由进行分发。路由将分发请求给一个路由或控制器，同时运行路由指定的中间件 2. 服务提供者是什么？ 服务提供者是所有laravel应用程序引导启动的中心，laravel的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。 3. IoC容器是什么？ IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。 其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。 Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。 4. Facades 是什么？ Facades（一种设计模式，通常翻译为外观模式）提供了一个”static”（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。 5. Contract 是什么？ Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。 6. 谈谈 Laravel 和 YII 框架的区别 在 YII 框架中的路由是通过书写 Controller、Action 间接定义路由，而 Laravel 中是在 route 路由文件中直接定义路由入口 Laravel 提供 ORM 对象关系映射，使读写数据库的操作更加简单 Laravel 提供更多的 Artisan 命令和脚手架开发 Laravel 的 Composer 扩展包比 Yii 框架更多，开发更加高效 7. 谈谈 Laravel 和 TP5 框架的区别 提交数据的方式：laravel在提交表单的时候需要在表单中加入{csrc_field}来防止跨域攻击；TP不会。 路由：laravel必须先定义，再使用；TP在配置文件中开启路由。 中间件：laravel中间件，就是http请求到达之前经过的层，通过中间件我们可以验证用户是否登录等一些通用操作。 操作数据库的方式：都可以使用实例化（建立相对应的模型类）和DB::table来操作数据库。使用原生查询时不太一样，laravel使用Db::操作(‘原生sql’)，TP使用Db::query(‘原生sql’)。 Laravel升级十分简易，而TP大版本的升级要重构代码。 条件判断语句书写方式的差异： laravel框架里 if else判断语句和foreach语句 书写时必须以@if开头 以@endif结尾,如果没有则报语法错误,@foreach @endforeach同理；而TP框架则和PHP语法规则使用方式一致直接ifesle语句判断和foreach循环遍历。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx和php-fpm结合]]></title>
    <url>%2F2019%2F08%2F08%2Fnginx-and-php-fpm%2F</url>
    <content type="text"><![CDATA[Nginx不只有处理http请求的功能，还能做反向代理。 Nginx通过反向代理功能将动态请求转向后端Php-fpm。 在 Linux 上，nginx 与 php-fpm 的通信有 tcp socket 和 unix socket 两种方式。 tcp socket 的优点是可以跨服务器，当 nginx 和 php-fpm 不在同一台机器上时，只能使用这种方式。 Unix socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信，这种方式需要在 nginx配置文件中填写 php-fpm 的 socket 文件位置。 两种方式的数据传输过程如下图所示： 二者的不同： 由于 Unix socket 不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。所以其效率比 tcp socket 的方式要高，可减少不必要的 tcp 开销。不过，unix socket 高并发时不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。而 tcp 这样的面向连接的协议，可以更好的保证通信的正确性和完整性。 下面我们来配置一个全新的Nginx+Php-fpm 配置nginx.conf文件进入nginx目录下，编辑nginx.conf文件。如图，在nginx.conf最后一行，添加include文件 添加对应的server进入上面的include的路径，添加一个serverunix socket 方式 修改fastcgi_pass如下fastcgi_pass unix:/usr/run/php-fpm.sock 下面我们解释下配置项的含义 123456789101112131415161718server &#123; listen 80; #监听80端口，接收http请求 server_name www.example.com; #就是网站地址 root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径 #路由到网站根目录www.example.com时候的处理 location / &#123; index index.php; #跳转到www.example.com/index.php autoindex on; &#125; #当请求网站下php文件的时候，反向代理到php-fpm location ~ \.php$ &#123; include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块 fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口 # fasrcgi_pass /usr/run/php-fpm.sock #unix socket 连接方式 &#125;&#125; 下面我们启用php的php-fpm来处理这个请求打开php-fpm.conf文件，我们看到如下配置：unix socket 方式 修改php-fpm.conf如下listen = /usr/run/php-fpm.sock 即：php-fpm模块监听127.0.0.1:9000端口 或者 php-fpm.sock文件，等待请求到来去处理。 注意：在使用 unix socket 方式连接时，由于 socket 文件本质上是一个文件，存在权限控制的问题，所以需要注意 nginx 进程的权限与 php-fpm 的权限问题，不然会提示无权限访问。（在各自的配置文件里设置用户）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac + Hexo + GitHub + Next 搭建博客]]></title>
    <url>%2F2019%2F07%2F09%2Fmac-hexo%2F</url>
    <content type="text"><![CDATA[1. 安装node.js 和 gitmac上使用brew安装node 和 git测试安装是否成功： 12345node -vnpm -v # 同时可以配置下npm镜像：npm config set registry https://registry.npm.taobao.org# 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info expressgit --versoin 2. 安装Hexo安装时注意权限问题，加上sudo，其中-g表示全局安装 1sudo npm install -g hexo-cli npm全局安装的包的存储路径是/usr/local/lib/node_modules/ 3. 博客初始化创建博客的文件夹，并进入 12sudo mkdir blogcd blog 初始化博客 1sudo hexo init 安装依赖 12## 安装时 node-pre-gyp 报错，执行如下命令可以解决sudo npm install --unsafe-perm 执行下述命令生成本地网页文件并开启服务器，然后通过http://localhost:4000查看本地博客 12sudo hexo gsudo hexo s 或者 sudo hexo s -p 4000 4. 上传github在github中新建仓库，名称必须为 user.github.io，如：Liwen-Git.github.io 配置hexo的_config.yml文件 12cd blogsudo vim _config.yml 在文档的最后部分，将deploy配置如下 1234deploy: type: git repository: https://github.com/Liwen-Git/Liwen-Git.github.io.git branch: master 注意type、repository、branch后均有空格。通过如下命令在blog下生成静态文件并上传到服务器 1234sudo hexo g# 出错执行 sudo npm install hexo --savesudo hexo d# 出错执行 sudo npm install hexo-deployer-git --save 执行hexo d 时会提示输入GitHub账号用户名和密码，执行成功之后通过 https://liwen-git.github.io/ 访问博客 5. 更换Next主题推荐使用hexo-theme-next主题在blog目录下执行： 1sudo git clone https://github.com/theme-next/hexo-theme-next.git themes/next 修改blog目录下_config.yml里的theme名称为：next其他的，如title: 李子园、language: zh-CN、都可以自己配置 执行如下命令（每次部署文章的步骤） 12sudo hexo g //生成缓存和静态文件sudo hexo d //重新部署到服务器 当本地博客部署到服务器后，网页端无变化时可以采用下述命令 1sudo hexo clean //清楚缓存文件(db.json)和已生成的静态文件(public) 6. 配置next主题修改next主题的配置文件_config.yml主题为：Gemini（打开注释） 修改next主题配置文件，在menu处，打开tags和categories的注释 创建tag页面1sudo hexo new page &quot;tags&quot; 然后再blog/sources中会多了一个tags文件夹，修改其中的index.md文件，type修改为tags 12345---title: tagsdate: 2019-07-08 23:15:25type: &quot;tags&quot;--- 创建categories页面1sudo hexo new page &quot;categories&quot; 然后再blog/sources中会多了一个categories文件夹，修改其中的index.md文件，type修改为categories 12345---title: categoriesdate: 2019-07-08 23:15:25type: &quot;categories&quot;--- 7. 安装搜索功能 Local Search在next的_config.yml文件中修改Local Search的enable: true在根目录下执行以下命令： 12sudo npm install hexo-generator-search --savesudo npm install hexo-generator-searchdb --save 在根目录的_config.yml文件中添加 12345search: path: search.xml field: post format: html limit: 10000 8. 新建文章命令： 1sudo hexo new post 文件名可以不是文章名 给文章添加属性 12345678910---title: Mac + Hexo + GitHub + Next 搭建博客date: 2019-07-08 12:12:57categories: - mactags:- hexo- next- 表单验证--- 站点首页不显示文章全文，文章摘要设置这里我们可以通过在文章使用&lt;!-- more --&gt;标志来精确控制文章的摘要预览]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F07%2F08%2Fphp-design-patterns%2F</url>
    <content type="text"><![CDATA[策略模式策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。 策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。 策略模式的三个角色： 抽象策略角色 具体策略角色 环境角色（对抽象策略角色的引用） 实现步骤： 定义抽象角色类（定义好各个实现的共同抽象方法） 定义具体策略类（具体实现父类的共同方法） 定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法） 就在编程领域外，有许多例子是关于策略模式的。例如： 如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。 策略模式的代码实例： 1234567891011121314151617181920212223242526&lt;?php // 抽象策略类 abstract class baseAgent &#123; abstract function PrintPage(); &#125; // 用于客户端是IE时调用的类（环境角色） class ieAgent extends baseAgent &#123; function PrintPage() &#123; return &apos;IE&apos;; &#125; &#125; // 用于客户端不是IE时调用的类（环境角色） class otherAgent extends baseAgent &#123; function PrintPage() &#123; return &apos;not IE&apos;; &#125; &#125; // 具体策略角色 class Browser &#123; public function call($object) &#123; return $object-&gt;PrintPage(); &#125; &#125; $bro = new Browser(); echo $bro-&gt;call(new ieAgent()); 工厂模式工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。 使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php // 简单工厂模式（静态工厂方法模式） // Interface people 人类 interface people &#123; public function say(); &#125; // Class man 继承people的男人类 class man implements people &#123; // 具体实现people的say方法 public function say() &#123; echo &apos;我是男人&lt;br&gt;&apos;; &#125; &#125; // Class women 继承people的女人类 class women implements people &#123; // 具体实现people的say方法 public function say() &#123; echo &apos;我是女人&lt;br&gt;&apos;; &#125; &#125; // Class SimpleFactory 工厂类 class SimpleFactory &#123; // 简单工厂里的静态方法-用于创建男人对象 static function createMan() &#123; return new man(); &#125; // 简单工厂里的静态方法-用于创建女人对象 static function createWomen() &#123; return new women(); &#125; &#125; // 具体调用 $man = SimpleFactoty::createMan(); $man-&gt;say(); $woman = SimpleFactoty::createWomen(); $woman-&gt;say(); 单例模式单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。 单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。 单例模式有以下3个特点： 只能有一个实例 必须自行创建这个实例 必须给其他对象提供这一实例 那么为什么要使用PHP单例模式？ PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。 12345678910111213141516171819202122232425class Single &#123; private $name;//声明一个私有的实例变量 private function __construct()&#123; //声明私有构造方法为了防止外部代码使用new来创建对象。 &#125; static public $instance;//声明一个静态变量（保存在类中唯一的一个实例） static public function getinstance()&#123; //声明一个getinstance()静态方法，用于检测是否有实例对象 if(!self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; public function setname($n)&#123; $this-&gt;name = $n; &#125; public function getname()&#123; return $this-&gt;name; &#125;&#125;$oa = Single::getinstance();$ob = Single::getinstance();$oa-&gt;setname(&apos;hello world&apos;);$ob-&gt;setname(&apos;good morning&apos;);echo $oa-&gt;getname();//good morningecho $ob-&gt;getname();//good morning 注册模式注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。 1234567891011121314&lt;?phpclass Register &#123; protected static $objects; //将对象注册到全局的树上 function set($alias, $object) &#123; self::$objects[$alias]=$object;//将对象放到树上 &#125; static function get($name) &#123; return self::$objects[$name];//获取某个注册到树上的对象 &#125; function _unset($alias) &#123; unset(self::$objects[$alias]);//移除某个注册到树上的对象 &#125;&#125; 适配器模式将各种截然不同的函数接口封装成统一的API。 PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。 12345678接口 IDatabase&lt;?php namespace IMooc; interface IDatabase &#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close(); &#125; 12345678910111213141516171819MySQL&lt;?php namespace IMooc\Database; use IMooc\IDatabase; class MySql implements IDatabase &#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysql_connect($host, $user, $passwd); mysql_select_db($dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; $res = mysql_query($sql, $this-&gt;conn); return $res; &#125; function close() &#123; mysql_close($this-&gt;conn); &#125; &#125; 1234567891011121314151617MySQLi&lt;?php namespace IMooc\Database; use IMooc\IDatabase; class MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname)&#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql)&#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close()&#123; mysqli_close($this-&gt;conn); &#125; &#125; 观察者模式 观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。 场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 观察者模式实现了低耦合，非侵入式的通知与更新机制。 定义一个事件触发抽象类： 12345678910111213EventGenerator.php&lt;?php abstract class EventGenerator&#123; private $observers = array(); function addObserver(Observer $observer)&#123; $this-&gt;observers[]=$observer; &#125; function notify()&#123; foreach ($this-&gt;observers as $observer)&#123; $observer-&gt;update(); &#125; &#125; &#125; 定义一个观察者接口 123456Observer.php&lt;?php //一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件 interface Observer &#123; function update(); // 这里就是在事件发生后要执行的逻辑 &#125; 实现 1234567891011121314151617181920212223class Event extends EventGenerator&#123; function triger()&#123; echo &quot;Event&lt;br&gt;&quot;; &#125;&#125;class Observer1 implements Observer&#123; function update()&#123; echo &quot;逻辑1 &lt;br/&gt;&quot;; &#125;&#125;class Observer2 implements Observer&#123; function update()&#123; echo &quot;逻辑2 &lt;br/&gt;&quot;; &#125;&#125;$event = new Event();$event-&gt;addObserver(new Observer1());$event-&gt;addObserver(new Observer2());$event-&gt;triger();$event-&gt;notify();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt格式 “占位符”]]></title>
    <url>%2F2019%2F07%2F08%2Fgo-fmt%2F</url>
    <content type="text"><![CDATA[golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。 123456# 定义示例类型和变量type Human struct &#123; Name string&#125;var people = Human&#123;Name: &quot;zhangsan&quot;&#125; 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式 Printf(“%v”, people) {zhangsan} %+v 打印结构体时，会添加字段名 Printf(“%+v”, people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(“#v”, people) main.Human{Name:”zhangsan”} %T 相应值的类型的Go语法表示 Printf(“%T”, people) main.Human %% 字面上的百分号，并非值的占位符 Printf(“%%”) % 布尔占位符 占位符 说明 举例 输出 %t true 或 false Printf(“%t”, true) true 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(“%b”, 5) 101 %c 相应Unicode码点所表示的字符 Printf(“%c”, 0x4E2D) 中 %d 十进制表示 Printf(“%d”, 0x12) 18 %o 八进制表示 Printf(“%d”, 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(“%q”, 0x4E2D) ‘中’ %x 十六进制表示，字母形式为小写 a-f Printf(“%x”, 13) d %X 十六进制表示，字母形式为大写 A-F Printf(“%x”, 13) D %U Unicode格式：U+1234，等同于 “U+%04X” Printf(“%U”, 0x4E2D) U+4E2D 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %e 科学计数法，例如 -1234.456e+78 Printf(“%e”, 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(“%e”, 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(“%f”, 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%g”, 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%G”, 10.20+2i) (10.2+2i) 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(“%s”, []byte(“Go语言”)) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(“%q”, “Go语言”) “Go语言” %x 十六进制，小写字母，每字节两个字符 Printf(“%x”, “golang”) 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(“%X”, “golang”) 676F6C616E67 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(“%p”, &amp;people) 0x4f57f0]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>占位符</tag>
      </tags>
  </entry>
</search>
