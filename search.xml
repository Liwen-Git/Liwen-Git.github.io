<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac + Hexo + GitHub + Next 搭建博客]]></title>
    <url>%2F2019%2F07%2F09%2Fmac-hexo%2F</url>
    <content type="text"><![CDATA[1. 安装node.js 和 gitmac上使用brew安装node 和 git测试安装是否成功： 12345node -vnpm -v # 同时可以配置下npm镜像：npm config set registry https://registry.npm.taobao.org# 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info expressgit --versoin 2. 安装Hexo安装时注意权限问题，加上sudo，其中-g表示全局安装 1sudo npm install -g hexo-cli npm全局安装的包的存储路径是/usr/local/lib/node_modules/ 3. 博客初始化创建博客的文件夹，并进入 12sudo mkdir blogcd blog 初始化博客 1sudo hexo init 安装依赖 12## 安装时 node-pre-gyp 报错，执行如下命令可以解决sudo npm install --unsafe-perm 执行下述命令生成本地网页文件并开启服务器，然后通过http://localhost:4000查看本地博客 12sudo hexo gsudo hexo s 或者 sudo hexo s -p 4000 4. 上传github在github中新建仓库，名称必须为 user.github.io，如：Liwen-Git.github.io 配置hexo的_config.yml文件 12cd blogsudo vim _config.yml 在文档的最后部分，将deploy配置如下 1234deploy: type: git repository: https://github.com/Liwen-Git/Liwen-Git.github.io.git branch: master 注意type、repository、branch后均有空格。通过如下命令在blog下生成静态文件并上传到服务器 1234sudo hexo g# 出错执行 sudo npm install hexo --savesudo hexo d# 出错执行 sudo npm install hexo-deployer-git --save 执行hexo d 时会提示输入GitHub账号用户名和密码，执行成功之后通过 https://liwen-git.github.io/ 访问博客 5. 更换Next主题推荐使用hexo-theme-next主题在blog目录下执行： 1sudo git clone https://github.com/theme-next/hexo-theme-next.git themes/next 修改blog目录下_config.yml里的theme名称为：next其他的，如title: 李子园、language: zh-CN、都可以自己配置 执行如下命令（每次部署文章的步骤） 12sudo hexo g //生成缓存和静态文件sudo hexo d //重新部署到服务器 当本地博客部署到服务器后，网页端无变化时可以采用下述命令 1sudo hexo clean //清楚缓存文件(db.json)和已生成的静态文件(public) 6. 配置next主题修改next主题的配置文件_config.yml主题为：Gemini（打开注释） 修改next主题配置文件，在menu处，打开tags和categories的注释 创建tag页面1sudo hexo new page &quot;tags&quot; 然后再blog/sources中会多了一个tags文件夹，修改其中的index.md文件，type修改为tags 12345---title: tagsdate: 2019-07-08 23:15:25type: &quot;tags&quot;--- 创建categories页面1sudo hexo new page &quot;categories&quot; 然后再blog/sources中会多了一个categories文件夹，修改其中的index.md文件，type修改为categories 12345---title: categoriesdate: 2019-07-08 23:15:25type: &quot;categories&quot;--- 7. 安装搜索功能 Local Search在next的_config.yml文件中修改Local Search的enable: true在根目录下执行以下命令： 12sudo npm install hexo-generator-search --savesudo npm install hexo-generator-searchdb --save 在根目录的_config.yml文件中添加 12345search: path: search.xml field: post format: html limit: 10000 8. 新建文章命令： 1sudo hexo new post 文件名可以不是文章名 给文章添加属性 12345678910---title: Mac + Hexo + GitHub + Next 搭建博客date: 2019-07-08 12:12:57categories: - mactags:- hexo- next- 表单验证--- 站点首页不显示文章全文，文章摘要设置这里我们可以通过在文章使用&lt;!-- more --&gt;标志来精确控制文章的摘要预览]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F07%2F08%2Fphp-design-patterns%2F</url>
    <content type="text"><![CDATA[策略模式策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。 策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。 策略模式的三个角色： 抽象策略角色 具体策略角色 环境角色（对抽象策略角色的引用） 实现步骤： 定义抽象角色类（定义好各个实现的共同抽象方法） 定义具体策略类（具体实现父类的共同方法） 定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法） 就在编程领域外，有许多例子是关于策略模式的。例如： 如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。 策略模式的代码实例： 1234567891011121314151617181920212223242526&lt;?php // 抽象策略类 abstract class baseAgent &#123; abstract function PrintPage(); &#125; // 用于客户端是IE时调用的类（环境角色） class ieAgent extends baseAgent &#123; function PrintPage() &#123; return &apos;IE&apos;; &#125; &#125; // 用于客户端不是IE时调用的类（环境角色） class otherAgent extends baseAgent &#123; function PrintPage() &#123; return &apos;not IE&apos;; &#125; &#125; // 具体策略角色 class Browser &#123; public function call($object) &#123; return $object-&gt;PrintPage(); &#125; &#125; $bro = new Browser(); echo $bro-&gt;call(new ieAgent()); 工厂模式工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。 使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php // 简单工厂模式（静态工厂方法模式） // Interface people 人类 interface people &#123; public function say(); &#125; // Class man 继承people的男人类 class man implements people &#123; // 具体实现people的say方法 public function say() &#123; echo &apos;我是男人&lt;br&gt;&apos;; &#125; &#125; // Class women 继承people的女人类 class women implements people &#123; // 具体实现people的say方法 public function say() &#123; echo &apos;我是女人&lt;br&gt;&apos;; &#125; &#125; // Class SimpleFactory 工厂类 class SimpleFactory &#123; // 简单工厂里的静态方法-用于创建男人对象 static function createMan() &#123; return new man(); &#125; // 简单工厂里的静态方法-用于创建女人对象 static function createWomen() &#123; return new women(); &#125; &#125; // 具体调用 $man = SimpleFactoty::createMan(); $man-&gt;say(); $woman = SimpleFactoty::createWomen(); $woman-&gt;say(); 单例模式单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。 单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。 单例模式有以下3个特点： 只能有一个实例 必须自行创建这个实例 必须给其他对象提供这一实例 那么为什么要使用PHP单例模式？ PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。 12345678910111213141516171819202122232425class Single &#123; private $name;//声明一个私有的实例变量 private function __construct()&#123; //声明私有构造方法为了防止外部代码使用new来创建对象。 &#125; static public $instance;//声明一个静态变量（保存在类中唯一的一个实例） static public function getinstance()&#123; //声明一个getinstance()静态方法，用于检测是否有实例对象 if(!self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; public function setname($n)&#123; $this-&gt;name = $n; &#125; public function getname()&#123; return $this-&gt;name; &#125;&#125;$oa = Single::getinstance();$ob = Single::getinstance();$oa-&gt;setname(&apos;hello world&apos;);$ob-&gt;setname(&apos;good morning&apos;);echo $oa-&gt;getname();//good morningecho $ob-&gt;getname();//good morning 注册模式注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。 1234567891011121314&lt;?phpclass Register &#123; protected static $objects; //将对象注册到全局的树上 function set($alias, $object) &#123; self::$objects[$alias]=$object;//将对象放到树上 &#125; static function get($name) &#123; return self::$objects[$name];//获取某个注册到树上的对象 &#125; function _unset($alias) &#123; unset(self::$objects[$alias]);//移除某个注册到树上的对象 &#125;&#125; 适配器模式将各种截然不同的函数接口封装成统一的API。 PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。 12345678接口 IDatabase&lt;?php namespace IMooc; interface IDatabase &#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close(); &#125; 12345678910111213141516171819MySQL&lt;?php namespace IMooc\Database; use IMooc\IDatabase; class MySql implements IDatabase &#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysql_connect($host, $user, $passwd); mysql_select_db($dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; $res = mysql_query($sql, $this-&gt;conn); return $res; &#125; function close() &#123; mysql_close($this-&gt;conn); &#125; &#125; 1234567891011121314151617MySQLi&lt;?php namespace IMooc\Database; use IMooc\IDatabase; class MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname)&#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql)&#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close()&#123; mysqli_close($this-&gt;conn); &#125; &#125; 观察者模式 观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。 场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 观察者模式实现了低耦合，非侵入式的通知与更新机制。 定义一个事件触发抽象类： 12345678910111213EventGenerator.php&lt;?php abstract class EventGenerator&#123; private $observers = array(); function addObserver(Observer $observer)&#123; $this-&gt;observers[]=$observer; &#125; function notify()&#123; foreach ($this-&gt;observers as $observer)&#123; $observer-&gt;update(); &#125; &#125; &#125; 定义一个观察者接口 123456Observer.php&lt;?php //一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件 interface Observer &#123; function update(); // 这里就是在事件发生后要执行的逻辑 &#125; 实现 1234567891011121314151617181920212223class Event extends EventGenerator&#123; function triger()&#123; echo &quot;Event&lt;br&gt;&quot;; &#125;&#125;class Observer1 implements Observer&#123; function update()&#123; echo &quot;逻辑1 &lt;br/&gt;&quot;; &#125;&#125;class Observer2 implements Observer&#123; function update()&#123; echo &quot;逻辑2 &lt;br/&gt;&quot;; &#125;&#125;$event = new Event();$event-&gt;addObserver(new Observer1());$event-&gt;addObserver(new Observer2());$event-&gt;triger();$event-&gt;notify();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt格式 “占位符”]]></title>
    <url>%2F2019%2F07%2F08%2Fgo-fmt%2F</url>
    <content type="text"><![CDATA[golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。 123456# 定义示例类型和变量type Human struct &#123; Name string&#125;var people = Human&#123;Name: &quot;zhangsan&quot;&#125; 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式 Printf(“%v”, people) {zhangsan} %+v 打印结构体时，会添加字段名 Printf(“%+v”, people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(“#v”, people) main.Human{Name:”zhangsan”} %T 相应值的类型的Go语法表示 Printf(“%T”, people) main.Human %% 字面上的百分号，并非值的占位符 Printf(“%%”) % 布尔占位符 占位符 说明 举例 输出 %t true 或 false Printf(“%t”, true) true 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(“%b”, 5) 101 %c 相应Unicode码点所表示的字符 Printf(“%c”, 0x4E2D) 中 %d 十进制表示 Printf(“%d”, 0x12) 18 %o 八进制表示 Printf(“%d”, 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(“%q”, 0x4E2D) ‘中’ %x 十六进制表示，字母形式为小写 a-f Printf(“%x”, 13) d %X 十六进制表示，字母形式为大写 A-F Printf(“%x”, 13) D %U Unicode格式：U+1234，等同于 “U+%04X” Printf(“%U”, 0x4E2D) U+4E2D 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %e 科学计数法，例如 -1234.456e+78 Printf(“%e”, 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(“%e”, 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(“%f”, 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%g”, 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%G”, 10.20+2i) (10.2+2i) 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(“%s”, []byte(“Go语言”)) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(“%q”, “Go语言”) “Go语言” %x 十六进制，小写字母，每字节两个字符 Printf(“%x”, “golang”) 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(“%X”, “golang”) 676F6C616E67 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(“%p”, &amp;people) 0x4f57f0]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>占位符</tag>
      </tags>
  </entry>
</search>
