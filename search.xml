<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设置环境变量PATH 和 查看PATH]]></title>
    <url>%2F2019%2F11%2F14%2Fmac-env-path%2F</url>
    <content type="text"><![CDATA[理论篇Mac系统的环境变量，加载顺序为：/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc /etc/profile和/etc/paths是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。 后面3个按照从前往后的顺序读取，如果/.bash_profile文件存在，则后面的几个文件就会被忽略不读了，如果/.bash_profile文件不存在，才会以此类推读取后面的文件。 ~/.bashrc没有上述规则，它是bash shell打开的时候载入的。 PATH的语法如下： 12#中间用冒号隔开export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt; 上述文件的科普 /etc/paths （全局建议修改这个文件 ）编辑 paths，将环境变量添加到 paths文件中 ，一行一个路径Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。 /etc/profile （建议不修改这个文件 ）全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 /etc/bashrc （一般在这个文件中添加系统级环境变量）全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。 ~/.profile 文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置使用注意：如果你有对/etc/profile有修改的话必须得重启你的修改才会生效，此修改对每个用户都生效。 ~/.bashrc 每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.使用注意：对所有的使用bash的用户修改某个配置并在以后打开的bash都生效的话可以修改这个文件，修改这个文件不用重启，重新打开一个bash即可生效。 /.bash_profile 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）使用注意：需要需要重启才会生效，/etc/profile对所有用户生效，/.bash_profile只对当前用户生效。 source ~/.bash_profile 或者 ~/.profile 环境信息生效 操作篇全局设置 创建一个文件 1sudo touch /etc/paths.d/mysql 用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑） 1sudo vim /etc/paths.d/mysql 编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了） 1/Applications/MAMP/Library/bin source 相应的文件 生效配置环境 该mac的mysql环境变量配置方法如下：创建软连接至/usr/local/bin环境变量目录sudo ln -s /Applications/MAMP/Library/bin/mysql /usr/local/bin/mysql 注： Mac的这个bin目录，是一个已经包含在环境变量里的目录，程序放在里面或者链接到里面就可以在终端里直接执行。 Mac的usr/bin目录是不允许增删文件的，可以通过向usr/local/bin增删文件来实现在终端里直接运行，往后者里面增删文件只要有管理员权限就可以了。 单个环境变量设置 vim ~/.bash_profile （任意一个文件中添加用户级环境变量） 12# 第一个是PHP地址；第二个是nginx地址export PATH=&quot;/Applications/MAMP/bin/php/php7.3.1/bin:/Applications/MAMP/Library/sbin:$PATH&quot; source ~/.bash_profile 生效 查看PATH1echo $PATH]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SSHFS 将远程文件挂载到本地]]></title>
    <url>%2F2019%2F11%2F14%2Fmac-sshfs-to-local%2F</url>
    <content type="text"><![CDATA[SSHFS允许您使用SFTP安装远程文件系统。 大多数SSH服务器默认支持并启用此SFTP访问，因此SSHFS使用起来非常简单，服务器端无需执行任何操作。 在MacOS中使用SSHFS需要FUSE的支持 用于 macOS 的 FUSE 允许您通过第三方文件系统扩展 macOS 的本地文件处理功能。 它是 MacFUSE 的继任者，已被许多产品用作软件构建块，但不再维护; 安装 下载安装从 官网下载最新版的 FUSE for macOS 和 SSHFS 直接安装。下载速度较慢，以存放至百度云备用 HomeBrew安装 (安装太慢，不推荐) 12$ brew cask install osxfuse$ brew cask install sshfs 使用新建本地挂载点 1$ mkdir local-file 挂载 1$ sshfs user@hostname:/absolute/path/to/document local-file 远程的地址最好使用绝对路径。此时打开该文件夹就可以访问远程文件了。 卸载挂载文件 1$ umount local-file]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>sshfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置https 和 HTTP2]]></title>
    <url>%2F2019%2F11%2F14%2Flinux-https-http2%2F</url>
    <content type="text"><![CDATA[配置ssl证书 证书说明：这里使用的证书是阿里云个人一年免费的SSL证书，只需要在阿里云上申请即可获得。 web服务器说明：这里采用的web服务器是Nginx服务器。 服务器操作系统说明：这里使用的是Centos 7.x系统。 终端登陆工具与FTP工具说明：这里使用的是Xshell与Xftp工具。 下载证书登陆到阿里云控制台，今天证书安全下载界面，选择Nginx/Tengine，下载证书，并解压到桌面。 上传证书到服务器 登陆到服务器，并进入到Nginx目录: 创建证书存放目录: 使用Xftp将证书上传至新建的目录下: 配置Nginx使其支持SSL证书 进入nginx下的conf.d目录，创建一个新的.conf文件，命名为ssl.域名.conf(命名可任意，但需以.conf结尾)。 为新建的.conf文件添加如下代码： 1234567891011121314151617181920212223242526272829303132server &#123; listen 443; # 修改为你的域名 server_name 域名.com www.域名.com; ssl on; # root目录，即为你网站的存放目录 root /mnt/www/域名.com/public_html/wordpress/; index index.html index.htm index.php; # 将下面两行修改为SSL证书存放路径 ssl_certificate /etc/nginx/ssl/域名.com/214190949470644.pem; ssl_certificate_key /etc/nginx/ssl/域名.com/214190949470644.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; # 以下为Nginx的基本配置 location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125;&#125; 测试下配置的正确性，成功后重启下Nginx，再打开浏览器测试HTTPS是否能正常访问。 另外说明：可以看到目前conf.d目录里有3个以.conf结尾的配置文件，basic.conf为基本的解析配置文件；域名.conf为不使用SSL证书的http配置文件；ssl.域名.com为新增加的使用SSL证书的HTTPS配置文件。因此，在目前未配置301重定向的情况下，打开浏览器测试网站的时候，可以发现网站即可正常访问http,也可以正常访问https。 为Nginx配置301重定向说明：在上面说了，目前网站的状态应该是http和https都可以正常访问。现在则为Nginx配置一下301重定向，这样当访问网站的时候就会自动定向到https,而不会在通过http访问网站了。 进入Nginx配置目录，打开http的配置文件 编辑域名.conf配置文件 123456server &#123; listen 80; # 将“域名”改为你自己的域名 server_name 域名.com www.域名.com; return 301 https://$host$request_uri;&#125; 注意：这里编辑的是域名.conf，而不是ssl.域名.conf！！！ 重启Nginx，打开浏览器测试1systemctl restart nginx 配置至此，网站已经只会再通过https访问了，但是仍然还不会使用http2.0协议. 配置HTTP2查看网站协议打开浏览器，将审查元素打开，点击Network选项卡，将Protocol调出来，查看传输协议。目前显示的为http/1.1，传输协议。 查看Nginx版本，查看OpenSSL版本目前显示的版本是nginx/1.10.2，OpenSSL 1.0.1e-fips，因为之前安装Nginx时，使用的时系统默认的源，然而Centos7自带的Nginx版本并不够新，想要支持使用http2.0协议，OpenSS必须升级到2.0版本以上才可以。因此要对Nginx重新编译。 编译安装Nginx和openssl 安装编译过程中需要使用的工具 1yum install wget curl perl gcc pcre-devel zlib-devel make -y 下载Nginx源和openssl源 12345678910//下载openssl新版的源和Nginx新版源wget https://www.openssl.org/source/openssl-1.0.2l.tar.gz http://nginx.org/download/nginx-1.11.10.tar.gz//解压两个压缩包tar zxvf nginx-1.11.10.tar.gztar zxvf openssl-1.0.2l.tar.gz//重命名nginx和opensslmv nginx-1.11.10/ nginxmv openssl-1.0.2l/ openssl 编译nginx 首先卸载原先版本的额nginx 1yum remove nginx -y 配置编译nginx 123456789101112131415161718192021222324//进入nginx和openssl所在目录。cd ~//将nginx和openssl移动到/usr/local/src文件夹mv nginx/ openssl/ /usr/local/src///进入/etc/local/src/nginx目录下cd /usr/local/src/nginx//配置nginx./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_stub_status_module --with-http_auth_request_module --with-threads --with-stream --with-stream_ssl_module --with-http_slice_module --with-mail --with-mail_ssl_module --with-file-aio --with-http_v2_module --with-stream_realip_module --with-openssl=/usr/local/src/openssl//使用make命令编译一下,时间较长make//编译完成后执行下make insatllmake install//为新编译的nginx添加用户，创建配置目录useradd nginx &amp;&amp; mkdir /etc/nginx/conf.d//创建nginx缓存目录，并设置一些权限mkdir /var/cache/nginx &amp;&amp; chown nginx:root /var/cache/nginx//删除用不着的文件rm -rf /usr/local/src/nginx &amp;&amp; rm -rf /usr/local/src/openssl &amp;&amp; rm -rf /var/cache/yum 继续配置nginx，并启动它 1234567891011121314151617181920212223//配置nginx服务文件vim /usr/lib/systemd/system/nginx.service//为nginx.service添加配置代码[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network-online.target remote-fs.target nss-lookup.targetWants=network-online.target[Service]Type=forkingPIDFile=/run/nginx.pidExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.confExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPID[Install]WantedBy=multi-user.target//启动下nginx，再设置开机启动systemctl start nginxsystemctl enable nginxsystemctl status nginx 编辑nginx.conf文件 1234567891011//进入nginx目录cd /etc/nginx///为nginx.conf添加代码vim nginx.conf//在nginx.conf中的gzip on代码下面一行添加如下代码include /etc/nginx/conf.d/*.conf;//重启nginxsystemctl restart nginx 配置http2.0协议12345678910//编辑ssl.域名.conf文件vim ssl.域名.conf//在第一行listen配置项中添加 ssl http2server &#123;listen 443 ssl http2;.....见第一篇中的.conf配置文件//重启nginxsystemctl restart nginx 测试至此，http2.0协议配置完成，打开浏览器查看传输协议。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10+Ubuntu17.04双系统安装]]></title>
    <url>%2F2019%2F11%2F14%2Flinux-two-system%2F</url>
    <content type="text"><![CDATA[本教程默认已安装win10，即是在win10正常使用基础上进行的 本教程自动忽略虚拟机和wubi安装，隔靴搔痒而已，毋庸置疑最好的方式还是u盘安装 本教程同样适用于Win10+Ubuntu16.04LTS，亲测一样成功 本教程全部图片来自网络（自己太懒并没有截图，只为讲述教程进行中的画面，因此图仅供参考） 准备Ubuntu系统的的ISO、UltraISO、EasyBCD、U盘 安装数据备份创建磁盘分区 按住Win + X，选择“磁盘管理” 选择剩余空间较大的可分配磁盘，右键并选择“压缩卷”，这里选择压缩E盘50G左右的空间 点击“压缩”之后，E盘后部出现黑色的50G“未分配空间” 至此，磁盘分区过程完成 禁用快速启动(可选但是建议)按住Win + X(请记住这个万能的组合)，选择“电源选项”，依次执行：“选择电源按钮的功能” -&gt; “更改当前不可用的设置” -&gt; 取消选择”启用快速启动” 注： “快速启动”是Windows 8时代引进的新特性，建议关闭该特性的原因是，“快速启动”会影响Grub开机引导过程，可能出现无法载入Ubuntu的状况，最后选择“保存修改”。 制作Ubuntu的启动U盘（用U盘安装过操作系统的童鞋可以跳过这一步） 备份待写入的U盘并将其插入电脑，进入UltraISO，打开镜像文件（即你已经下载好的ubuntu ISO镜像文件） 启动&gt;写入硬盘映像 按默认值写入 完成硬盘映像写入，别拔U盘 U盘安装Ubuntu重启，并按进入bios的快捷键(电脑不同型号快捷键不同，我的联想F2），进入系统bios后设置优先u盘启动，设置后电脑自动重启并进入ubuntu安装界面。 选择“试用Ubuntu Kylin” 进入ubuntu主界面然后双击打开ubuntu安装文件,完成默认设置 注：如果网络和空间匀速，可以选择“安装中下载更新”和“安装这个第三方软件”（可以不选择，我建议不选择，费时间也没啥用） U盘安装Ubuntu本教程最重要的的一步，选择“其他选项” 单击“创建新分区表”，点击的“+”创建4个主要的基础分区（这里之前未分配的50G就是给ubuntu系统的50G），按以下参数设置4个主要的基础分区： 大小 分区 位置 格式 地址 10G 主分区 空间起始位置 Ext4日志文件系统 / 4G 逻辑分区 空间起始位置 交换空间 /swap 200MB 逻辑分区 空间起始位置 Ext4日志文件系统 /boot 剩余的空间 逻辑分区 空间起始位置 Ext4日志文件系统 /home 当然这里还可创建自己的其他分区如/123分区，只要设置为逻辑分区、空间起始位置、Ext4日志文件系统即可，新手强烈建议忽略此步，按上面设置即可 安装启动引导设备的参数选择：与/boot所在的编号一致。设置好后安装即可，之后的选项（所在地点、键盘布局、电脑名称、开机密码等）正常进行直到安装完毕，大功告成。 重启系统，进入Win10完成最后的引导设置。 EasyBCD引导Ubuntu 重启在win10下进入EasyBCD，选择“添加新条目”，选择Linux/BSD操作系统，在“驱动器”栏目选择接近200M（与boot的那个接近）的Linux分区，点添加条目 完成条目添加后，重启电脑，会发现Win10和Ubuntu的双系统已经完成安装 大功告成，祝玩得开心 后记：用Windows引导Ubuntu最大的好处就是，当不再需要Ubuntu的时候，直接在Windows磁盘管理中将其所在所有分区删除，然后将EasyBCD中对应条目删除即可。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 中添加一个新用户并授权]]></title>
    <url>%2F2019%2F11%2F14%2Flinux-centos-add-new-user%2F</url>
    <content type="text"><![CDATA[创建新用户创建一个用户名为：linuxidc 1[root@localhost ~]# adduser linuxidc 为这个用户初始化密码，linux会判断密码复杂度，不过可以强行忽略： 1[root@localhost ~]# passwd linuxidc 授权个人用户的权限只可以在本home下有完整权限，其他目录要看别人授权。而经常需要root用户的权限，这时候sudo可以化身为root来操作。我记得我曾经sudo创建了文件，然后发现自己并没有读写权限，因为查看权限是root创建的。 新创建的用户并不能使用sudo命令，需要给他添加授权。 sudo命令的授权管理是在sudoers文件里的。可以看看sudoers： 12[root@localhost ~]# whereis sudoerssudoers: /etc/sudoers /etc/sudoers.d /usr/libexec/sudoers.so /usr/share/man/man5/sudoers.5.gz 找到这个文件位置之后再查看权限： 12[root@localhost ~]# ls -l /etc/sudoers-r--r----- 1 root root 4251 9月 25 15:08 /etc/sudoers 是的，只有只读的权限，如果想要修改的话，需要先添加w权限： 12[root@localhost ~]# chmod -v u+w /etc/sudoersmode of &quot;/etc/sudoers&quot; changed from 0440 (r--r-----) to 0640 (rw-r-----) 然后就可以添加内容了，在下面的一行下追加新增的用户： 12345[root@localhost ~]# vim /etc/sudoers## Allow root to run any commands anywherroot ALL=(ALL) ALLlinuxidc ALL=(ALL) ALL #这个是新增的用户 wq保存退出，这时候要记得将写权限收回： 12[root@localhost ~]# chmod -v u-w /etc/sudoersmode of &quot;/etc/sudoers&quot; changed from 0640 (rw-r-----) to 0440 (r--r-----) 这时候使用新用户登录，使用sudo： 1234567[linuxidc@localhost ~]$ sudo cat /etc/passwd[sudo] password for linuxidc:We trust you have received the usual lecture from the local SystemAdministrator. It usually boils down to these three things:#1) Respect the privacy of others.#2) Think before you type.#3) With great power comes great responsibility. 第一次使用会提示你，你已经化身超人，身负责任。而且需要输入密码才可以下一步。如果不想需要输入密码怎么办，将最后一个 ALL 修改成 NOPASSWD: ALL 。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux文件权限]]></title>
    <url>%2F2019%2F11%2F14%2Flinux-file-jurisdiction%2F</url>
    <content type="text"><![CDATA[1. 常用权限 444 r–r–r– ： 所有用户都只有读权限 600 rw——- ： 文件所有者具有读、写权限，其他用户没有权限 644 rw-r–r– ： 文件所有者具有读写权限，同组用户具有读权限，其他用户具有读权限 666 rw-rw-rw- ：文件所有者，同组用户，其他用户都具有读写权限，没有执行权限 700 rwx—— ： 文件所有者具有读写执行权限，同组用户其他用户均没有任何权限 744 rwxr–r– ： 文件所有者具有读写执行权限，同组用户和其他用户只有读权限 755 rwxr-xr-x ： 文件所有者具有读、写、执行权限，同组用户和其他用户具有读、执行权限 777 rwxrwxrwx ： 全部用户都用全权限 2. 权限解释从左至右，1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限。 具体的权限是由数字来表示的，读取的权限等于4，用r表示；写入的权限等于2，用w表示；执行的权限等于1，用x表示。 通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行）。 以755为例：1-3位7等于4+2+1，rwx，所有者具有读取、写入、执行权限；4-6位5等于4+1+0，r-x，同组用户具有读取、执行权限但没有写入权限；7-9位5，同上，也是r-x，其他用户具有读取、执行权限但没有写入权限。 3. 语法示例将文件 file1.txt 设为所有人皆可读取 : 123chmod ugo+r file1.txt或者chmod a+r file1.txt u 表示该文件的拥有者(User)，g 表示与该文件的拥有者属于同一个群体(Group)者，o 表示其他以外的人(Other)，a 表示这三者皆是。 +表示增加权限、- 表示取消权限、= 表示唯一设定权限。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的artisan命令]]></title>
    <url>%2F2019%2F11%2F14%2Flaravel-artisan%2F</url>
    <content type="text"><![CDATA[全局篇 查看artisan命令 12php artisanphp artisan list 查看某个帮助命令 1php artisan help make:model 查看laravel版本 1php artisan --version 使用 PHP 内置的开发服务器启动应用 1php artisan serve 生成一个随机的 key，并自动更新到 app/config/app.php 的 key 键值对（刚安装好需要做这一步） 1php artisan key:generate 开启Auth用户功能（开启后需要执行迁移才生效） 1php artisan make:auth 开启维护模式和关闭维护模式（显示503） 12php artisan downphp artisan up 进入tinker工具 1php artisan tinker 列出所有的路由 1php artisan route:list 生成路由缓存以及移除缓存路由文件 12php artisan route:cachephp artisan route:clear 功能篇 创建控制器 1php artisan make:controller StudentController 创建Rest风格资源控制器（带有index、create、store、edit、update、destroy、show方法） 1php artisan make:controller PhotoController --resource 创建模型 1php artisan make:model Student 创建新建表的迁移和修改表的迁移 12php artisan make:migration create_users_table --create=students //创建students表php artisan make:migration add_votes_to_users_table --table=students//给students表增加votes字段 执行迁移 1php artisan migrate 创建模型的时候同时生成新建表的迁移 1php artisan make:model Student -m 回滚上一次的迁移 1php artisan migrate:rollback 回滚所有迁移 1php artisan migrate:reset 创建填充 1php artisan make:seeder StudentTableSeeder 执行单个填充 1php artisan db:seed --class=StudentTableSeeder 执行所有填充 1php artisan db:seed 创建中间件（app/Http/Middleware下） 1php artisan make:middleware Activity 创建队列（数据库）的表迁移（需要执行迁移才生效） 1php artisan queue:table 创建队列类（app/jobs下）： 1php artisan make:job SendEmail 创建请求类（app/Http/Requests下） 1php artisan make:request CreateArticleRequest]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Queue]]></title>
    <url>%2F2019%2F11%2F14%2Flaravel-queue%2F</url>
    <content type="text"><![CDATA[使用队列原因 异步 重试 使用队列场景 耗时比较久的，比如上传一个文件后进行一些格式的转化等。 需要保证送达率的，比如发送短信，因为要调用别人的 api，总会有几率失败，那么为了保证送达，重试就必不可少了。 tips 在开发环境我们想测试的时候，可以把 Queue driver 设置成为 sync ，这样队列就变成了同步执行，方便调试队列里面的任务。 Job 里面的 handle 方法是可以注入别的 class 的，就像在 Controller action 里面也可以注入一样。 什么时候使用 queue:listen 什么时候使用 queue:work ？答：Laravel 5.3 的文档已经不写 queue:listen 这个指令怎么用了，所以你可以看出来可能官方已经不怎么建议使用 queue:listen 了，但是在本地调试的时候要使用 queue:listen ，因为 queue:work 在启动后，代码修改， queue:work 不会再 Load 上下文，但是 queue:listen 仍然会重新 Load 新代码。其余情况全部使用 queue:work 吧，因为效率更高。 命令讲解命令： 1php artisan queue:work --daemon --quiet --queue=default --delay=3 --sleep=3 --tries=3 –daemon总体来说，在 supervisor 中一般要加这个 option，可以节省 CPU 使用。 –quiet不输出任何内容 –delay=3一个任务失败后，延迟 多长时间 后再重试，单位是秒。这个值的设定我个人建议不要太短，因为一个任务失败（比如网络原因），重试时间太短可能会出现连续失败的情况。 –sleep=3去 Redis 中拿任务的时候，发现没有任务，休息 多长时间 ，单位是秒。这个值的设定要看你的任务是否紧急，如果是那种非常紧急的任务，不能等待太长时间。 –tries=3定义 失败任务最多重试次数 。这个值的设定根据任务的重要程度来确定，一般 3 次比较适合。 注意Redis 里面一个任务默认最多执行60秒，如果一个任务60秒没有执行完毕，会继续放回到队列中，循环执行，那酸爽…]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel创建工具类]]></title>
    <url>%2F2019%2F11%2F14%2Flaravel-common-class%2F</url>
    <content type="text"><![CDATA[以Common工具类为例： 首先先介绍这个类的用法：在一般控制器中只要 use Common; 然后在方法里面就能调用到Common类里面的方法了，如Common::getSite();直接能调用到这个方法，一般这种都是比较常用的方法才放到工具类中，这样大家写的方法都能轻易的调用了。 接下来就是如何创建这个工具类：在app文件夹下面，创建一个服务文件夹名字叫做Services，然后在Services文件夹中创建一个CommonUnit.php里面的内容为： 123456789&lt;?phpnamespace App\Services;/*** 通用工具服务类*/class CommonUtils&#123; //写一些通用方法&#125; 如何才能使这个类生效能在控制器中use Common就能调用到里面的方法呢：在config配置文件中打开app.php 在’providers’数组中添加：App\Providers\CommonServiceProvider::class 在’aliases’数组中添加：&#39;Common&#39; =&gt; App\Facades\Common::class 在app文件夹下面创建Facades文件夹：里面创建一个静态类：文件名称为Common.php，里面的内容为： 12345678&lt;?phpnamespace App\Facades;use Illuminate\Support\Facades\Facade;class Common extends Facade&#123; protected static function getFacadeAccessor()&#123; return &apos;CommonService&apos;; &#125;&#125; 绑定功能到IOC容器:在app文件夹下面的Providers文件夹下面创建一个供应商文件，名字为：CommonServiceProvider.php里面的内容为： 12345678910111213141516&lt;?phpnamespace App\Providers;use Illuminate\Support\ServiceProvider;class CommonServiceProvider extends ServiceProvider&#123;/*** Register the application services.** @return void*/public function register()&#123; $this-&gt;app-&gt;singleton(&apos;CommonService&apos;, function () &#123; return new \App\Services\CommonUtils(); &#125;);&#125;&#125; 这样就大工告成啦！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel核心概念]]></title>
    <url>%2F2019%2F11%2F14%2Flaravel-core%2F</url>
    <content type="text"><![CDATA[自动依赖注入 什么是依赖注入：通过类型提示的方式向函数传递参数。 实例1首先，定义一个类: 12/routes/web.phpclass Bar &#123;&#125; 假如我们在其他地方要使用到 Bar 提供的功能（服务），怎么办，直接传入参数即可： 1234/routes/web.phpRoute::get(&apos;bar&apos;, function(Bar $bar) &#123; dd($bar);&#125;); 访问 /bar，显示 $bar 的实例: 1Bar &#123;#272&#125; 也就是说，我们不需要先对其进行实例！如果学过 PHP 的面向对象，都知道，正常做法是这样: 123class Bar &#123;&#125;$bar = new Bar();dd($bar); 实例2可以看一个稍微复杂的例子： 123456789101112class Baz &#123;&#125;class Bar&#123; public $baz; public function __construct(Baz $baz) &#123; $this-&gt;baz = $baz; &#125;&#125;$baz = new Baz();$bar = new Bar($baz);dd($bar); 为了在 Bar 中能够使用 Baz 的功能，我们需要实例化一个 Baz，然后在实例化 Bar 的时候传入 Baz 实例。在 Laravel 中，不仅仅可以自动注入 Bar，也可以自动注入 Baz: 12345678910111213/routes/web.phpclass Baz &#123;&#125;class Bar&#123; public $baz; public function __construct(Baz $baz) &#123; $this-&gt;baz = $baz; &#125;&#125;Route::get(&apos;bar&apos;, function(Bar $bar) &#123; dd($bar-&gt;baz);&#125;); 显示结果: 1Baz &#123;#276&#125; 小结通过上述两个例子，可以看出，在 Laravel 中，我们要在类或者函数中使用其他类体用的服务，只需要通过类型提示的方式传递参数，而 Laravel 会自动帮我们去寻找响对应的依赖。 那么，Laravel 是如何完成这项工作的呢？答案就是通过服务容器。 服务容器什么是服务容器服务容器，很好理解，就是装着各种服务实例的特殊类。可以通过「去餐馆吃饭」来进行类比： 吃饭 - 使用服务，即调用该服务的地方 饭 - 服务 盘子 - 装饭的容器，即服务容器 服务员 - 服务提供者，负责装饭、上饭 实现 饭：定义Rice类： 12345678910/app/Rice.php&lt;?phpnamespace App;class Rice&#123; public function food() &#123; return &apos;香喷喷的白米饭&apos;; &#125;&#125; 把饭装盘子：在容器中定义了名为 rice 的变量（你也可以起其他名字，比如 rice_container），绑定了 Food 的实例： 123app()-&gt;bind(&apos;rice&apos;, function ()&#123; return new \App\Rice();&#125;); 也可以写成: 1app()-&gt;bind(&apos;rice&apos;,\App\Rice::class); 现在，吃饭了，通过 make 方法提供吃饭的服务： 1234Route::get(&apos;eat&apos;, function() &#123; return app()-&gt;make(&apos;rice&apos;)-&gt;food(); // 或者 return resolve(&apos;rice&apos;)-&gt;food()；&#125;); make 方法传入我们刚才定义的变量名即可调用该服务。访问 /eat，返回 香喷喷的白米饭。 为了方便起见，我们在路由文件中直接实现了该过程，相当于自给自足。但是服务通常由服务提供者来管理的。因此，我们可以让 AppServiceProvider 这个服务员来管理该服务： 123456/app/Providers/AppServiceProvider.phpnamespace App\Providers;public function register()&#123; $this-&gt;app-&gt;bind(&apos;rice_container&apos;,Rice::class);&#125; 更为常见的是，我们自己创建一个服务员： 1$ php artisan make:provider RiceServiceProvider 注册: 1234567/app/Providers/RiceServiceProvider.php&lt;?phpuse App\Rice;public function register()&#123; $this-&gt;app-&gt;bind(&apos;rice&apos;,Rice::class);&#125; 这里定义了 register() 方法，但是还需要调用该方法才能真正绑定服务到容器，因此，需要将其添加到 providers 数组中： 1234/config/app.php&apos;providers&apos; =&gt; [ App\Providers\RiceServiceProvider::class,], 这一步有何作用呢？Laravel 在启动的时候会访问该文件，然后调用里面的所有服务提供者的 register() 方法，这样我们的服务就被绑定到容器中了。 小结通过上述的例子，基本上可以理解服务容器和服务提供者的使用。当然了，我们更为常见的还是使用类型提示来传递参数： 1234use App\Rice;Route::get(&apos;eat&apos;, function(Rice $rice) &#123; return $rice-&gt;food();&#125;); 在本例中，使用自动依赖注入即可。不需要在用 bind 来手动绑定以及 make 来调用服务。那么，为什么还需要 bind 和 make 呢？ make 比较好理解，我们有一些场合 Laravel 不能提供自动解析，那么这时候手动使用 make 解析就可以了，而 bind 的学问就稍微大了点，后面将会详细说明。 门面门面是什么，我们回到刚才的「吃饭」的例子: 123Route::get(&apos;eat&apos;, function(Rice $rice) &#123; return $rice-&gt;food();&#125;); 在 Laravel，通常还可以这么写: 123Route::get(&apos;eat&apos;, function() &#123; return Rice::food();&#125;); 或者 123Route::get(&apos;eat&apos;, function() &#123; return rice()-&gt;food();&#125;); 那么，Laravel 是如何实现的呢？答案是通过门面。 门面方法实现先来实现 Rice::food()，只需要一步： 1234567891011/app/RiceFacade.php&lt;?phpnamespace App;use Illuminate\Support\Facades\Facade;class RiceFacade extends Facade&#123; protected static function getFacadeAccessor() &#123; return &apos;rice&apos;; &#125;&#125; 现在，RiceFacade 就代理了 Rice 类了，这就是门面的本质了。我们就可以直接使用： 123Route::get(&apos;eat&apos;, function() &#123; dd(\App\RiceFacade::food());&#125;); 因为 \App\RiceFacade 比较冗长，我们可以用 php 提供的 class_alias 方法起个别名吧： 123456/app/Providers/RiceServiceProvider.phppublic function register()&#123; $this-&gt;app-&gt;bind(&apos;rice&apos;,\App\Rice::class); class_alias(\App\RiceFacade::class, &apos;Rice&apos;);&#125; 这样做的话，就实现了一开始的用法： 123Route::get(&apos;eat&apos;, function() &#123; return Rice::food();&#125;); 看上去就好像直接调用了 Rice 类，实际上，调用的是 RiceFacade 类来代理，因此，个人觉得Facade 翻译成假象比较合适。最后，为了便于给代理类命名，Laravel 提供了统一命名别名的地方： 1234/config/app.php&apos;aliases&apos; =&gt; [ &apos;Rice&apos; =&gt; \App\RiceFacade::class,], 门面实现过程分析首先： 1Rice::food(); 因为 Rice 是别名，所以实际上执行的是: 1\App\RiceFacade::food() 但是我们的 RiceFacade 类里面并没有定义静态方法 food 啊？怎么办呢？直接抛出异常吗？不是，在 PHP 里，如果访问了不可访问的静态方法，会先调用 __callstatic,所以执行的是: 1\App\RiceFacade::__callStatic() 虽然我们在 RiceFacade 中没有定义，但是它的父类 Facade 已经定义好了： 123456789101112/vendor/laravel/framework/src/Illuminate/Support/Facades/Facade.phppublic static function __callStatic($method, $args)&#123;// 实例化 Rice &#123;#270&#125;$instance = static::getFacadeRoot();// 实例化失败，抛出异常if (! $instance) &#123; throw new RuntimeException(&apos;A facade root has not been set.&apos;);&#125;// 调用该实例的方法return $instance-&gt;$method(...$args);&#125; 主要工作就是第一步实例化: 12345public static function getFacadeRoot()&#123; return static::resolveFacadeInstance(static::getFacadeAccessor()); // 本例中：static::resolveFacadeInstance(&apos;rice&apos;)&#125; 进一步查看 resolveFacadeInstance() 方法： 123456789101112protected static function resolveFacadeInstance($name)&#123; // rice 是字符串，因此跳过该步骤 if (is_object($name)) &#123; return $name; &#125; // 是否设置了 `rice` 实例 if (isset(static::$resolvedInstance[$name])) &#123; return static::$resolvedInstance[$name]; &#125; return static::$resolvedInstance[$name] = static::$app[$name];&#125; 第一步比较好理解，如果我们之前在 RiceFacade 这样写： 1234protected static function getFacadeAccessor()&#123; return new \App\Rice;&#125; 那么就直接返回 Rice 实例了，这也是一种实现方式。主要难点在于最后这行： 1return static::$resolvedInstance[$name] = static::$app[$name]; 看上去像是在访问 $app数组，实际上是使用 数组方式来访问对象，PHP 提供了这种访问方式接口，而 Laravel 实现了该接口。也就是说，$app 属性其实就是对 Laravel 容器的引用，因此这里实际上就是访问容器上名为 rice 的对象。而我们之前学习容器的时候，已经将 rice 绑定了 Rice 类： 12345public function register()&#123; $this-&gt;app-&gt;bind(&apos;rice&apos;,\App\Rice::class); // class_alias(\App\RiceFacade::class, &apos;Rice&apos;);&#125; 所以，其实就是返回该类的实例了。懂得了服务容器和服务提供者，理解门面也就不难了。 辅助方法实现辅助方法的实现，更简单了。不就是把 app-&gt;make(‘rice’) 封装起来嘛： 123456789/vendor/laravel/framework/src/Illuminate/Foundation/helpers.phpif (! function_exists(&apos;rice&apos;)) &#123; function rice() &#123; return app()-&gt;make(&apos;rice&apos;); // 等价于 return app(&apos;rice&apos;); // 等价于 return app()[&apos;rice&apos;]; &#125;&#125; 然后我们就可以使用了: 123Route::get(&apos;eat&apos;, function() &#123; dd(rice()-&gt;food());&#125;); 小结Laravel 提供的三种访问类的方式： 依赖注入：通过类型提示的方式实现自动依赖注入 门面：通过代理来访问类 辅助方法：通过方法的方式来访问类本质上，这三种方式都是借助于服务容器和服务提供者来实现。那么，服务容器本身有什么好处呢？我们接下来着重介绍下。 IOC不好的实现我们来看另外一个例子（为了方便测试，该例子都写在路由文件中），假设有三种类型的插座：USB、双孔、三孔插座，分别提供插入充电的服务： 123456789101112131415161718class UsbsocketService&#123; public function insert($deviceName)&#123; return $deviceName.&quot; 正在插入 USB 充电&quot;; &#125;&#125;class DoubleSocketService&#123; public function insert($deviceName)&#123; return $deviceName.&quot; 正在插入双孔插座充电&quot;; &#125;&#125;class ThreeSocketService&#123; public function insert($deviceName)&#123; return $deviceName.&quot; 正在插入三孔插座充电&quot;; &#125;&#125; 设备要使用插座的服务来充电： 1234567891011class Device &#123; protected $socketType; // 插座类型 public function __construct() &#123; $this-&gt;socketType = new UsbSocketService(); &#125; public function power($deviceName) &#123; return $this-&gt;socketType-&gt;insert($deviceName); &#125;&#125; 现在有一台手机要进行充电: 1234Route::get(&apos;/charge&apos;,function()&#123; $device = new Device(); return $device-&gt;power(&quot;手机&quot;);&#125;); 因为 Laravel 提供了自动依赖注入功能，因此可以写成： 123Route::get(&apos;/charge/&#123;device&#125;&apos;,function(Device $device)&#123; return $device-&gt;power(&quot;手机&quot;);&#125;); 访问 /charge/phone，页面显示 phone 正在插入 USB 充电。假如，现在有一台电脑要充电，用的是三孔插座，那么我们就需要去修改 Device 类: 1$this-&gt;socketType = new ThreeSocketService(); 这真是糟糕的设计，设备类对插座服务类产生了依赖。更换设备类型时，经常就要去修改类的内部结构。 好的实现为了解决上面的问题，可以参考「IOC」思路：即将依赖转移到外部。来看看具体怎么做。首先定义插座类型接口： 123interface SocketType &#123; public function insert($deviceName);&#125; 让每一种插座都实现该接口： 123456789101112131415161718class UsbsocketService implements SocketType&#123; public function insert($deviceName)&#123; return $deviceName.&quot; 正在插入 USB 充电&quot;; &#125;&#125;class DoubleSocketService implements SocketType&#123; public function insert($deviceName)&#123; return $deviceName.&quot; 正在插入双孔插座充电&quot;; &#125;&#125;class ThreeSocketService implements SocketType&#123; public function insert($deviceName)&#123; return $deviceName.&quot; 正在插入三孔插座充电&quot;; &#125;&#125; 最后，设备中传入接口类型而非具体的类： 1234567891011class Device &#123; protected $socketType; // 插座类型 public function __construct(SocketType $socketType) // 传入接口 &#123; $this-&gt;socketType = $socketType; &#125; public function power($deviceName) &#123; return $this-&gt;socketType-&gt;insert($deviceName); &#125;&#125; 实例化的时候再决定使用哪种插座类型，这样依赖就转移到了外部： 12345Route::get(&apos;/charge&apos;,function()&#123; $socketType = new ThreeSocketService(); $device = new Device($socketType); echo $device-&gt;power(&quot;电脑&quot;);&#125;); 我们现在可以再不修改类结构的情况下，方便的更换插座来满足不同设备的充电需求: 12345Route::get(&apos;/charge&apos;,function()&#123; $socketType = new DoubleSocketService(); $device = new Device($socketType); echo $device-&gt;power(&quot;台灯&quot;);&#125;); 自动依赖注入的失效上面举的例子，我们通过 Laravel 的自动依赖注入可以进一步简化： 123Route::get(&apos;/charge&apos;,function(Device $device)&#123; echo $device-&gt;power(&quot;电脑&quot;);&#125;); 这里的类型提示有两个，一个是 Device $device，一个是 Device 类内部构造函数传入的 SocketType $sockType。第一个没有问题，之前也试过。但是第二个 SocketType 是接口，而 Laravel 会将其当成类试图去匹配 SocketType 的类并将其实例化，因此访问 /charge 时候就会报错: 1Target [SocketType] is not instantiable while building [Device]. 错误原因很明显，Laravel 没法自动绑定接口。因此，我们就需要之前的 bind 方法来手动绑定接口啦： 1234app()-&gt;bind(&apos;SocketType&apos;,ThreeSocketService::class);Route::get(&apos;/charge&apos;,function(Device $device)&#123; echo $device-&gt;power(&quot;电脑&quot;);&#125;); 现在，如果要更换设备，我们只需要改变绑定的值就可以了: 1234app()-&gt;bind(&apos;SocketType&apos;,DoubleSocketService::class);Route::get(&apos;/charge&apos;,function(Device $device)&#123; echo $device-&gt;power(&quot;台灯&quot;);&#125;); 也就是说，我们将依赖转移到了外部之后，进一步由第三方容器来管理，这就是 IOC。 契约契约，不是什么新奇的概念。其实就是上一个例子中，我们定义的接口: 123interface SocketType &#123; public function insert($deviceName);&#125; 通过契约，我们就可以保持松耦合了: 1234public function __construct(SocketType $socketType) // 传入接口而非具体的插座类型&#123; $this-&gt;socketType = $socketType;&#125; 然后服务容器再根据需要去绑定哪种服务即可: 123app()-&gt;bind(&apos;SocketType&apos;,UsbSocketService::class);app()-&gt;bind(&apos;SocketType&apos;,DoubleSocketService::class);app()-&gt;bind(&apos;SocketType&apos;,ThreeSocketService::class)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel 跨域]]></title>
    <url>%2F2019%2F11%2F11%2Flaravel-cross-domain%2F</url>
    <content type="text"><![CDATA[跨域请求出于安全性的原因，浏览器会限制 Script 中的跨域请求。由于 XMLHttpRequest 遵循同源策略，所有使用 XMLHttpRequest 构造 HTTP 请求的应用只能访问自己的域名，如果需要构造跨域的请求，那么开发者需要配合浏览器做出一些允许跨域的配置。 W3C 应用工作组推荐了一种跨资源共享的机制，这种机制让 Web 应用服务器能支持跨站访问控制，从而使得安全的进行跨站数据传输成为可能，该机制通过几种方式来对原有模式进行了扩展： 响应的头部应该追加 Access-Control-Allow-Orign，用来表明哪些请求源被允许访问资源内容 浏览器会对请求源和响应中的值进行匹配验证 对于跨域的请求，浏览器会预发送一个非简单方式的请求，来判断给定资源是否准备接受跨域资源访问 服务端应用通过检查请求头部的 Orign 来判定请求是否跨域。 跨源资源共享标准跨源资源共享标准通过新增一系列 HTTP 头，让服务器能声明哪些来源可以通过浏览器访问该服务器上的资源。另外，对哪些会对服务器数据造成破坏性响应的 HTTP 请求方法（特别是 GET 以外的 HTTP 方法，或者搭配某些 MIME 类型的 POST 请求），标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求（preflight request），从而获取知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。服务器端也可以通知客户端，是不是需要随同请求一起发送信用信息（包括 Cookies 和 HTTP 认证相关数据）。 响应头Response Header Access-Control-Allow-Origin : 指明哪些请求源被允许访问资源，值可以为 “*”，”null”，或者单个源地址。 Access-Control-Allow-Credentials : 指明当请求中省略 creadentials 标识时响应是否暴露。对于预请求来说，它表明实际的请求中可以包含用户凭证。 Access-Control-Expose-Headers : 指明哪些头信息可以安全的暴露给 CORS API 规范的 API。 Access-Control-Max-Age : 指明预请求可以在预请求缓存中存放多久。 Access-Control-Allow-Methods : 对于预请求来说，哪些请求方式可以用于实际的请求。 Access-Control-Allow-Headers : 对于预请求来说，指明了哪些头信息可以用于实际的请求中。 Origin : 指明预请求或者跨域请求的来源。 Access-Control-Request-Method : 对于预请求来说，指明哪些预请求中的请求方式可以被用在实际的请求中。 Access-Control-Request-Headers : 指明预请求中的哪些头信息可以用于实际的请求中。 请求头Request Header Origin : 表明发送请求或预请求的来源。 Access-Control-Request-Method : 在发送预请求时带该请求头，表明实际的请求将使用的请求方式。 Access-Control-Request-Headers : 在发送预请求时带有该请求头，表明实际的请求将携带的请求头。 中间件12345678910111213141516171819202122232425&lt;?php namespace App\Http\Middleware;use Closure;use Response;class EnableCrossRequestMiddleware &#123; /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; $response = $next($request); $response-&gt;header(&apos;Access-Control-Allow-Origin&apos;, config(&apos;app.allow&apos;)); $response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Origin, Content-Type, Cookie, Accept&apos;); $response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;GET, POST, PATCH, PUT, OPTIONS&apos;); $response-&gt;header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;); return $response; &#125;&#125; 其中有以下需要注意的地方： 对于跨域访问并需要伴随认证信息的请求(需要携带cookie的)，需要在 XMLHttpRequest(axios中) 实例中指定 withCredentials 为 true。 这个中间件你可以根据自己的需求进行构建，如果需要在请求中伴随认证信息（包含 cookie，session）那么你就需要指定 Access-Control-Allow-Credentials 为 true, 因为对于预请求来说如果你未指定该响应头，那么浏览器会直接忽略该响应。 在响应中指定 Access-Control-Allow-Credentials 为 true 时，Access-Control-Allow-Origin 不能指定为 * 后置中间件只有在正常响应时才会被追加响应头，而如果出现异常，这时响应是不会经过中间件的。 注册这个 middleware 到 kernel 中. 分别在 protected $middleware 数组中和 protected $routeMiddleware 数组中，添加我们刚才创建的那个文件class名 和 使用 cors 这个别名. 本地开发过程中，必须在protected $middleware中添加跨域的中间件才能实现本地跨域。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP高并发支撑]]></title>
    <url>%2F2019%2F11%2F11%2Fphp-high-concurrence%2F</url>
    <content type="text"><![CDATA[简单的架构 系统集群化部署添加负载均衡层，将请求均匀打到系统层。系统层采用集群化部署多台机器，扛住初步的并发压力。 数据库分库分表 + 读写分离并发量继续增长时，我们就需要 focus 在数据库层面：分库分表、读写分离。 缓存集群引入不要盲目进行数据库扩容，数据库服务器成本昂贵，且本身就不是用来承载高并发的针对写少读多的请求，引入缓存集群，用缓存集群抗住大量的读请求 引入消息中间件集群消息中间件本身也跟缓存系统一样，可以用很少的资源支撑很高的并发请求，用他来支撑部分允许异步化的高并发写入是没问题的，比使用数据库直接支撑那部分高并发请求要减少很多的机器使用量。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让Google搜索到搭建在Github Pages上的博客]]></title>
    <url>%2F2019%2F10%2F11%2Fgoogle-search-console%2F</url>
    <content type="text"><![CDATA[使用Hexo博客框架和GitHub结合搭建博客是一种很不错的选择，但是如何能让博客被Google到呢？ 查看是否被收录首先查看是否已被Google收录，在Google中搜索：site:https://liwen-git.github.io/如果未查询到则继续往下看。 搜索资源提交进入Google Search Console登录之后，提交自己的博客网址： 选取HTML标记来进行验证，使用推荐方法会被sudo hexo clean命令清除： 将Search Console给的meta标签的信息添加到主题的目录下head.swig文件中，这里使用的是Next主题,其他主题也是类似的，在Hexo/themes/next/layout/_partials/head/head.swig文件中原有meta标签后面添加刚才复制的meta标签。 这时点击验证是无法通过的，需要将你的修改后的Hexo博客更新并部署到Github Pages上之后才可以验证， 12sudo hexo gsudo hexo d 验证后会提示成功，点击”继续“，先不要关闭这个页面，后面还要用。 添加站点地图站点地图(Site Map)是用来注明网站结构的文件，我们希望搜索引擎的爬虫了解我们的网站结构，以便于高效爬取内容，快速建立索引。 安装插件首先为Hexo安装hexo-generator-sitemap插件，在Hexo博客目录下运行： 1npm install hexo-generator-sitemap --save 重新编译配置Hexo的_config.yml文件，添加如下字段: 12sitemap: path: sitemap.xml 然后重新生成博客文件，运行 123sudo hexo cleansudo hexo gsudo hexo d 此时应该可以在public目录下看到sitemap.xml文件了。 添加/测试站点地图回到之前提交搜索资源的页面，在左边侧边栏找到“站点地图”,添加新的站点地图，将https://liwen-git.github.io/sitemap.xml提交并刷新，就可以看到博客的网站结构了。 如果没有什么问题的话，到这里就结束了，但是现在用Google还不能立即查到博客的内容，要等到搜索引擎下一次更新检索时才会有显示。 若站点地图无法获取如果出现了上图的情况，可能是站点地图生成有问题，可以使用XML-Sitemaps重新生成站点地图，然后下载，替换blog/public中的sitemap.xml文件。 若站点地图报错：不允许此网址可能是站点地图sitemap.xml中的所有网址是以yousite.com开头的，所以站点地图报错 解决：在blog/_config.yml中修改url为你自己的地址之后重新编译上传，重新生成sitemap.xml，重新提交即可。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew切换镜像源]]></title>
    <url>%2F2019%2F09%2F24%2Fhomebrew-mirrors%2F</url>
    <content type="text"><![CDATA[切换中科大镜像源： 替换brew.git123cd /usr/local/Homebrewgit remote set-url origin https://mirrors.ustc.edu.cn/brew.git 切换回官方源： https://github.com/Homebrew/brew 替换homebrew-core.git12345cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-coregit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.gitbrew update 切换官方源： https://github.com/Homebrew/homebrew-core 替换Homebrew Bottles源123echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 切换回官方： 删除~/.bash_profile中的HOMEBREW_BOTTLE_DOMAIN源即可]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-ide-helper]]></title>
    <url>%2F2019%2F09%2F24%2Flaravel-ide-helper%2F</url>
    <content type="text"><![CDATA[安装安装命令： 12# 如果只想在开发环境安装请加上 --devcomposer require --dev barryvdh/laravel-ide-helper 在 「config/app.php」的 「providers」数组中加入 1Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class, 如果你的 Laravel 版本小于 5.5 的话，请注册服务提供者，否则请忽略 如果你只在开发环境中安装「larave-ide-helper」，那么可以在「app/Providers/AppServiceProvider.php」的「register」方法中写入下面代码： 1234567public function register()&#123; if ($this-&gt;app-&gt;environment() !== &apos;production&apos;) &#123; $this-&gt;app-&gt;register(\Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class); &#125; // ...&#125; 导出配置文件,即：config/ide-helper.php（如果默认配置就满足需求了，也可以忽略这一步） 1php artisan vendor:publish --provider=&quot;Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider&quot; --tag=config 好了，接下去可以愉快的使用了 自动为 Laravel 的 Facades 生成注释在命令行下运行 1php artisan ide-helper:generate 注: 如果存在文件 「bootstrap/compiled.php」 需要先删除， 可以在生成文当前运行 php artisan clear-compiled。 自动为模型生成注释 多个模型：直接 php artisan ide-helper:models，当然也可以 php artisan ide-helper:models -W 单个模型：这个不能按照 github 上的 readme 来，坑爹。必须指明具体的类全名：php artisan ide-helper:models &quot;App\Http\Models\User&quot;。 为所有模型生成注释 php artisan ide-helper:models, 这时会出现询问： 1Do you want to overwrite the existing model files? Choose no to write to _ide_helper_models.php instead? (Yes/No): (yes/no) [no]: 输入 yes 则会直接在模型文件中写入注释，否则会生成「_ide_helper_models.php」文件。建议选择 yes，这样在跟踪文件的时候不会跳转到「_ide_helper_models.php」文件，不过这么做最好对模型文件做个备份，至少在生成注释之前用 git 控制一下版本，以防万一。 提示： 为模型生成字段信息必须在数据库中存在相应的数据表，不要生成 migration 还没运行 migrate 的时候就生成注释，这样是得不到字段信息的。 自动为链式操作注释这是什么意思呢？举个例子，在 migration 文件中经常可以看见这样的代码： 1$table-&gt;string(&apos;email&apos;)-&gt;unique(); 这时候就算调用过了 php artisan ide-helper:generate，在调用像 -&gt;unique() 这样的链式操作的时候也无法实现代码提示，这时候需要将配置文件「如果导出的话」&#39;include_fluent&#39; =&gt; false 修改为 &#39;include_fluent&#39; =&gt; true，重新运行 php artisan ide-helper:generate。试试效果吧！ 生成 .phpStorm.meta.php可以生成一个PhpStorm meta 文件去支持工厂模式. 对于 Laravel, 这意味着我们可以让 PhpStorm 理解我们从 IoC 容器中解决了什么类型的对象。例如：事件将返回一个「Illuminate\Events\Dispatcher」对象，利用 meta 文件您可以调用 app(‘events’) 并且它将自动完成 Dispatcher 的方法。 12345678app(&apos;events&apos;)-&gt;fire();\App::make(&apos;events&apos;)-&gt;fire();/** @var \Illuminate\Foundation\Application $app */$app-&gt;make(&apos;events&apos;)-&gt;fire();// When the key is not found, it uses the argument as class nameapp(&apos;App\SomeClass&apos;); 提示：您可能需要重启 Phpstorm 使 .phpStorm.meta.php 文件生效。 自动运行 generate想在依赖包更新是自动更新注释，可以在 composer.json 文件中做如下配置： 1234567&quot;scripts&quot;:&#123; &quot;post-update-cmd&quot;: [ &quot;Illuminate\\Foundation\\ComposerScripts::postUpdate&quot;, &quot;php artisan ide-helper:generate&quot;, &quot;php artisan ide-helper:meta&quot; ]&#125; 提示：如果只在 dev 环境下部署 ide helper 还是不要这么做了，防止在生产环境中报错导致不必要的麻烦。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TortoiseGit 和 Git 配置使用同一私钥]]></title>
    <url>%2F2019%2F09%2F24%2Ftortoisegit-key%2F</url>
    <content type="text"><![CDATA[tortoisegit 和 git 私钥格式 tortoisegit 默认使用putty格式的私钥（id_rsa.ppk）： git 默认使用openssh格式的私钥 (id_ras)： 首先通过ssh-keygen命令生产通用的id_ras.pub公钥 和 id_rsa的git私钥1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 然后可以在用户主目录里找到.ssh目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 使用puttyGen将git的openssh格式秘钥转化为putty格式 运行PuTTYGen，在Conversions菜单中点击Import key，选择ssh-keygen生成的私钥文件所在位置，比如id_rsa文件。 点击Save private key按钮，将其保存为.ppk文件。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitLab-ce搭建]]></title>
    <url>%2F2019%2F09%2F24%2Fgitlab-ce%2F</url>
    <content type="text"><![CDATA[安装并配置必要的依赖关系123sudo yum install -y curl policycoreutils-python openssh-server croniesudo lokkit -s http -s ssh 安装Postfix以发送通知电子邮件 123sudo yum install postfixsudo service postfix startsudo chkconfig postfix on 添加gitLab仓库到yum源，并安装123curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bashsudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; yum -y install gitlab-ce EXTERNAL_URL是设置用什么域名访问你的gitlab，此时也可以直接yum install gitlab-ce。安装完成后再修改配置文件/etc/gitlab/gitlab.rb 运行配置命令1sudo gitlab-ctl reconfigure 这样就可以访问你的gitLab了。 修改nginx端口（使用gitLab内置nginx） 修改nginx端口 1234567vim /etc/gitlab/gitlab.rbnginx[&apos;listen_port&apos;] = 82 #默认值即80端口 nginx[&apos;listen_port&apos;] = nilvim /var/opt/gitlab/nginx/conf/gitlab-http.conflisten *:82; #默认值listen *:80; 修改unicorn端口(可以不修改) 1234567vim /etc/gitlab/gitlab.rbunicorn[&apos;port&apos;] = 8082 #原值unicorn[&apos;port&apos;] = 8080vim /var/opt/gitlab/gitlab-rails/etc/unicorn.rblisten &quot;127.0.0.1:8082&quot;, :tcp_nopush =&gt; true #原值listen &quot;127.0.0.1:8080&quot;, :tcp_nopush =&gt; true 保存配置并重启 123sudo gitlab-ctl reconfiguresudo gitlab-ctl restartsudo gitlab-ctl status 访问 ip:82 成功。 gitLab服务命令 说明 常用命令 重新加载配置， 每次修改/etc/gitlab/gitlab.rb文件之后执行 sudo gitlab-ctl reconfigure 启动 sudo gitlab-ctl start 停止 sudo gitlab-ctl stop 重启 sudo gitlab-ctl restart 查看状态 sudo gitlab-ctl status 查看所有日志 sudo gitlab-ctl tail 查看 nginx 访问日志 sudo gitlab-ctl tail nginx/gitlab_acces.log 查看 postgresql 日志 sudo gitlab-ctl tail postgresql 检查gitLab状态 gitlab-rake gitlab:check 检查环境和配置是否正确 gitlab-rake gitlab:env:info 清除缓存 gitlab-rake cache:clear 相关文件位置 内容 位置 日志 /var/log/gitlab gitlab_url /opt/gitlab/embedded/service/gitlab-shell/config.yml nginx配置 /var/opt/gitlab/nginx/conf/gitlab-http.conf gitlab主配置文件 /etc/gitlab/gitlab.rb ssh路径url配置文件 /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml gitLab修改ssh默认端口 vim /etc/gitlab/gitlab.rb找到：gitlab_rails[‘gitlab_shell_ssh_port’] = 22 修改为：【你服务器ssh登录的端口】 重新编译：gitlab-ctl stopgitlab-ctl reconfiguregitlab-ctl start 疑难杂症 问题：访问报500错误原因：运行gitlab-rake gitlab:check，发现gitlab-shell self-check failed；再运行sudo gitlab-ctl restart，发现redis出现timeout；解决：找不到原因，暂时方法是 ps -ef | grep runsv 找到redis 的父级进程，kill -9 xxxx 全部杀掉后会自动拉起。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer autoload]]></title>
    <url>%2F2019%2F09%2F19%2Fcomposer-autoload%2F</url>
    <content type="text"><![CDATA[对于类库的自动加载，Composer 生成了一个 vendor/autoload.php 文件。引入这个文件，就能得到一个免费的自动加载支持。 本文主要是介绍如何利用 Composer 自带的自动加载机制，加载本地自定义的包（即不是来自于 packagist）。 使用在 composer.json 文件中的 autoload 字段中添加自己的 autoloader。 框架结构1234567891011121314151617First/ |---examples/ |---get.php |---src/ |---Curl.php |---vendor/ |---composer/ |---autoload.php |---composer.json |---classmap |---lib |---src |---ext |---common | |---functions |---system |---functions 介绍PSR-4自动加载方式12345678&#123; &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;First\\&quot;: &quot;src/&quot;, &quot;Temp\\&quot;: &quot;lib/&quot; &#125; &#125;&#125; 上面的代码采用 PSR-4 规范，该规范包含了 PHP 最新的自动加载标准，它要求必须使用 namespace （命名空间）的方式。 First\ 表示命名空间，必须以 \ 结尾，避免相似的命名空间导致冲突，若包含子命名空间，可以这样表示：First\Second\。 src/ 表示命名空间所在目录为与 Composer 的 vendor 目录同级的 src 目录，如上图框架结构所示。 如果需要在多个目录下搜索相同的命名前缀，可以用一个数组提供： 1234567&#123; &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;First\\&quot;: [&quot;src/&quot;, &quot;lib/&quot;] &#125; &#125;&#125; 修改完 composer.json 的 autoload 字段后需要更新一下 Composer 的自动加载类： 1composer dump-autoload 对应 Curl.php 的命名空间如下表示： 1234567&lt;?phpnamespace First;class Curl&#123;&#125; 引用 Curl.php 的方式如下： 12345678&lt;?phprequire &apos;../vendor/autoload.php&apos;;use First\Curl;$curl = new Curl();. . .. . . classmap模式懒加载，扫描目录下的所有类文件，支持递归扫描， 生成对应的类名=&gt;路径的映射，当载入需要的类时直接取出路径，速度最快composer.json的autoload中添加： 1234// classmap 扫描目录下的所有类文件 生成对应的类名=&gt;路径的映射&quot;classmap&quot;: [ &quot;classmap/lib/src/&quot;] files模式自动载入的文件，主要用来载入一些没办法懒加载的公共函数composer.json的autoload中添加： 123456// 扫描目录下的所有文件生成 hash =&gt; 路径的映射 运行时实时加载// 主要用来载入工具函数&quot;files&quot;: [ &quot;ext/common/functions.php&quot;, &quot;ext/system/functions.php&quot;]]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer镜像]]></title>
    <url>%2F2019%2F09%2F19%2Fcomposer-images%2F</url>
    <content type="text"><![CDATA[启用镜像服务的方式有两种：系统全局配置 ：即将配置信息添加到composer的全局配置文件config.json中。单个项目配置 ：将配置信息添加到某个项目的composer.json文件中 修改composer 的全局配置文件打开命令行（windows用户）或控制台（Linux、Mac用户）并执行如下命令： 1234--- phpcomposer ---composer config -g repo.packagist composer https://packagist.phpcomposer.com--- aliyun 推荐 ---composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 修改当前项目的composer.json配置文件：进入项目根目录（也就是composer.json文件所在目录），执行如下命令： 1composer config repo.packagist composer https://packagist.phpcomposer.com 上述命令将会在当前项目中的composer.json文件的末尾自动添加镜像的配置信息（你自己也可以手动添加）： 123456&quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot; : &quot;https://packagist.phpcomposer.com&quot; &#125;&#125; 查看composer镜像地址 1composer config -gl 取消配置 1composer config -g --unset repos.packagist]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer简介]]></title>
    <url>%2F2019%2F09%2F19%2Fcomposer%2F</url>
    <content type="text"><![CDATA[PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。 简单解释 composer install - 如有 composer.lock 文件，直接安装，否则从 composer.json 安装最新扩展包和依赖； composer update - 从 composer.json 安装最新扩展包和依赖； composer update vendor/package - 从 composer.json 或者对应包的配置，并更新到最新； composer require new/package - 添加安装 new/package , 可以指定版本，如： composer require new/package ~2.5。 介绍几个日常生产流程 新项目流程 运行 composer install ，安装扩展包并生成 composer.lock ； 提交 composer.lock 到代码版本控制器中，如：git; 项目协作者安装现有项目 克隆项目后，根目录下直接运行 composer install 从 composer.lock 中安装 指定版本 的扩展包以及其依赖； 此流程适用于生产环境代码的部署。 为项目添加新扩展包 使用 composer require vendor/package 添加扩展包； 提交更新后的 composer.json 和 composer.lock 到代码版本控制器中，如：git; 关于 composer.lock 文件 composer.lock 文件里保存着对每一个代码依赖的版本记录（见下图），提交到版本控制器中，并配合 composer install 使用，保证了团队所有协作者开发环境、线上生产环境中运行的代码版本的一致性。 关于扩展包的安装方法那么，准备添加一个扩展包，install, update, require 三个命令都可以用来安装扩展包，选择哪一个才是正确的呢？答案是：使用 composer require 命令 另外，在手动修改 composer.json 添加扩展包后， composer update new/package 进行指定扩展包更新的方式，也可以正确的安装，不过不建议使用这种方法，因为，一旦你忘记敲定后面的扩展包名，就会进入万劫不复的状态，别给自己留坑呀。 上面的概念不论对新手或者老手来说，都比较混淆，主要记住这个概念： 原有项目新添加扩展的，都使用 composer require new/package 这种方式来安装。 更新指定扩展到指定版本可以指定版本号： 1composer require &quot;foo/bar:1.0.0&quot; composer其他 composer 自身升级：composer self-update composer 回滚：composer self-update –rollback composer中require 和 require-dev的区别：前者用于声明项目发布版本的依赖包，后者用于声明项目开发或测试中依赖的包。 composer版本号 前置~和^符号的区别~和^的意思很接近，在x.y的情况下是一样的都是代表x.y &lt;= 版本号 &lt; (x+1).0，但是在版本号是x.y.z的情况下有区别，举个例子吧： ~1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 1.3.0 ^1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 2.0.0]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[govendor]]></title>
    <url>%2F2019%2F09%2F18%2Fgovendor%2F</url>
    <content type="text"><![CDATA[安装go get -u github.com/kardianos/govendor 初始化在项目根目录下执行以下命令进行vendor初始化：govendor init 项目根目录下即会自动生成 vendor 目录和 vendor.json 文件 常用命令 将 已被引用 且在 $GOPATH 下的所有包复制到vendor目录govendor add +external 仅从 $GOPATH 中复制指定包govendor add gopkg.in/yaml.v2 列出代码中所有被引用到的包及其状态govendor list 从远程仓库添加或更新某个包(不会在 $GOPATH 也存一份)govendor fetch golang.org/x/net/context 安装指定版本的包 123govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55govendor fetch golang.org/x/net/context@v1 # Get latest v1.*.* tag or branch.govendor fetch golang.org/x/net/context@=v1 # Get the tag or branch named &quot;v1&quot;. 删除vendor中已有 但是代码中未使用的包govendor remove +unused]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>govendor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor 维护 golang 进程]]></title>
    <url>%2F2019%2F09%2F18%2Fgo-supervisor%2F</url>
    <content type="text"><![CDATA[代码准备工作在代码目录执行go build或者go install来生成可执行文件 注意：如果使用go install生成在bin目录下的可执行文件，需要注意代码中的日志目录问题 安装supervisor官网地址：http://supervisord.org/index.html 12sudo yum install python-setuptoolssudo easy_install supervisor 或者 sudo pip install supervisor 安装成功后，生成配置文件 1sudo echo_supervisord_conf &gt; /etc/supervisord.conf 添加配置文件新建一个文件夹专门放置.conf文件 在/etc/下新建supervisor_conf_file文件夹，并在该文件加下新建gin_api.conf： 12345678910111213141516[program:gin_api]user=rootcommand=/home/go/src/gin_api/gin_api #go可执行文件路劲autostart=trueautorestart=truestartsecs=10stdout_logfile=/root/supervisor_log/gin_api.log #标准输出log，得去相应的目录下新建logstdout_logfile_maxbytes=1MBstdout_logfile_backups=10stdout_capture_maxbytes=1MBstderr_logfile=/root/supervisor_log/gin_api_err.log #错误输出log，得去相应的目录下新建logstderr_logfile_maxbytes=1MBstderr_logfile_backups=10stderr_capture_maxbytes=1MBstopsignal=INT[supervisord] 说明： 12345command：表示运行的命令，我这是填写的我demo安装包的原则路径。autostart：表示是否跟随supervisor一起启动。autorestart：如果该程序挂了，是否重新启动。stdout_logfile：终端标准输出重定向文件。stderr_logfile：终端错误输出重定向文件。 修改配置文件编辑 /etc/supervisord.conf，将文件最下面的 12;[include];files = relative/directory/*.ini 修改为： 12[include]files = /etc/supervisor_conf_file/*.conf 启动supervisord1sudo /usr/bin/supervisord -c /etc/supervisord.conf 若报如下错误： 1Error: Another program is already listening on a port that one of our HTTP servers is configured to use. Shut this program down first before starting supervisord. 解决办法： 12find / -name supervisor.sockunlink /xxx/supervisor.sock 之后再次执行启动命令。 执行命令查看gin_api服务是否启动成功： 1sudo supervisorctl status 输出： 1gin_api RUNNING pid 7648, uptime 0:09:57 ps: 123456789101112[root@accapp /home/go/src/gin_api]# supervisorctl gin_api RUNNING pid 7648, uptime 0:02:39supervisor&gt; helpdefault commands (type help &lt;topic&gt;):=====================================add exit open reload restart start tail avail fg pid remove shutdown status update clear maintail quit reread signal stop versionsupervisor&gt; exit[root@accapp /home/go/src/gin_api]# 相关命令 停止supervisor(子进程也会被停止) 1supervisorctl shutdown 把 supervisor 相关的进程都杀掉 1kill -9 $(ps -ef|grep supervisor | awk &apos;&#123;print $2&#125;&apos;) 解决unix:///tmp/supervisor.sock no such file的问题原因：tmp目录中的文件被Linux自动清除了 新建目录和修改权限 12345sudo mkdir -p /var/supervisor_tmp/runsudo mkdir -p /var/supervisor_tmp/logsudo chmod 777 /var/supervisor_tmp/runsudo chmod 777 /var/supervisor_tmp/log 修改/etc/supervisor.conf配置文件把所有的/tmp路径修改掉：/tmp/supervisor.sock 改成 /var/supervisor_tmp/run/supervisor.sock/tmp/supervisord.log 改成 /var/supervisor_tmp/log/supervisor.log/tmp/supervisord.pid 改成 /var/supervisor_tmp/run/supervisor.pid 重启杀掉supervisor进程和子进程，再启动supervisor]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[provide 和 inject]]></title>
    <url>%2F2019%2F09%2F18%2Fprovide-and-inject%2F</url>
    <content type="text"><![CDATA[官网解释：provider/inject provider/inject：简单的来说就是在父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。 需要注意的是这里不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据。 示例： first：定义一个parent component, 在这里我们在父组件中provide for这个变量。 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;childOne&gt;&lt;/childOne&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childOne from &apos;../components/test/ChildOne&apos; export default &#123; name: &quot;Parent&quot;, provide() &#123; return &#123; for: &quot;demo&quot; &#125; &#125;, components:&#123; childOne &#125; &#125; second 定义一个子组件 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &#123;&#123;demo&#125;&#125; &lt;childtwo&gt;&lt;/childtwo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childtwo from &apos;./ChildTwo&apos; export default &#123; name: &quot;childOne&quot;, inject: [&apos;for&apos;], data() &#123; return &#123; demo: this.for &#125; &#125;, components: &#123; childtwo &#125; &#125;&lt;/script&gt; third 定义另一个子组件 1234567891011121314151617&lt;template&gt; &lt;div&gt; &#123;&#123;demo&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;&quot;, inject: [&apos;for&apos;], data() &#123; return &#123; demo: this.for &#125; &#125; &#125;&lt;/script&gt; 在2个子组件中我们使用jnject注入了provide提供的变量for，并将它提供给了data属性。 运行结果是 demo demo 从上面这个例子可以看出，只要在父组件中调用了，那么在这个父组件生效的生命周期内，所有的子组件都可以调用inject来注入父组件中的值。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keep-alive的作用]]></title>
    <url>%2F2019%2F09%2F18%2Fkeep-alive%2F</url>
    <content type="text"><![CDATA[问题描述在vue项目中,难免会有列表页面或者搜索结果列表页面,点击某个结果之后,返回回来时,如果不对结果页面进行缓存,那么返回列表页面的时候会回到初始状态,但是我们想要的结果是返回时这个页面还是之前搜索的结果列表,这时候就需要用到vue的keep-alive技术了.本人遇到的问题是element切换tab的时候，页面不会缓存，所以需要使用keep-alive。 keep-alive 简介keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 用法也很简单： 12345&lt;keep-alive&gt; &lt;component&gt; &lt;!-- 该组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; props include - 字符串或正则表达，只有匹配的组件会被缓存 exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存 1234567// 组件 aexport default &#123; name: &apos;a&apos;, data () &#123; return &#123;&#125; &#125;&#125; 12345&lt;keep-alive include=&quot;a&quot;&gt; &lt;component&gt; &lt;!-- name 为 a 的组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染 12345&lt;keep-alive exclude=&quot;a&quot;&gt; &lt;component&gt; &lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染 配合vue-router共同使用但实际项目中,常需要配合vue-router共同使用. router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存： 12345&lt;keep-alive&gt; &lt;router-view&gt; &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt; 如果只想 router-view 里面某个组件被缓存，怎么办？ 增加 router.meta 属性 123456789101112131415161718// routes 配置export default [ &#123; path: &apos;/&apos;, name: &apos;home&apos;, component: Home, meta: &#123; keepAlive: true // 需要被缓存 &#125; &#125;, &#123; path: &apos;/:id&apos;, name: &apos;edit&apos;, component: Edit, meta: &#123; keepAlive: false // 不需要被缓存 &#125; &#125;] 12345678&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;&lt;/router-view&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel篇]]></title>
    <url>%2F2019%2F08%2F08%2Flaravel-question%2F</url>
    <content type="text"><![CDATA[1. 简述laravel的生命周期 导入composer自动加载功能，加载框架类库 引入laravel应用程序实例App 启动容器 注册http处理器 注册console处理器 注册异常处理器 启动http处理器，接收request请求 以管道的设计模式，执行部分（全局）中间件 路由解析调度 实例化当前控制器 执行web中间件 执行控制器中间件 执行控制器操作 返回response 结束框架 Laravel采用了单一的入口模式，应用的所有请求入口都是public/index.php文件。 注册类文件自动加载器：laravel通过composer进行依赖管理，无需开发者手动导入各种类文件，而由自动加载器自行导入。 创建服务容器：从bootstrap/app.php文件中取得laravel应用实例$app（服务容器） 创建HTTP/Console内核：传入的请求会被发送给HTTP内核或者console内核进行处理 载入服务提供者至容器：在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的应用，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件 分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给路由进行分发。路由将分发请求给一个路由或控制器，同时运行路由指定的中间件 2. 服务提供者是什么？ 服务提供者是所有laravel应用程序引导启动的中心，laravel的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。 3. IoC容器是什么？ IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。 其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。 Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。 4. Facades 是什么？ Facades（一种设计模式，通常翻译为外观模式）提供了一个”static”（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。 5. Contract 是什么？ Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。 6. 谈谈 Laravel 和 YII 框架的区别 在 YII 框架中的路由是通过书写 Controller、Action 间接定义路由，而 Laravel 中是在 route 路由文件中直接定义路由入口 Laravel 提供 ORM 对象关系映射，使读写数据库的操作更加简单 Laravel 提供更多的 Artisan 命令和脚手架开发 Laravel 的 Composer 扩展包比 Yii 框架更多，开发更加高效 7. 谈谈 Laravel 和 TP5 框架的区别 提交数据的方式：laravel在提交表单的时候需要在表单中加入{csrc_field}来防止跨域攻击；TP不会。 路由：laravel必须先定义，再使用；TP在配置文件中开启路由。 中间件：laravel中间件，就是http请求到达之前经过的层，通过中间件我们可以验证用户是否登录等一些通用操作。 操作数据库的方式：都可以使用实例化（建立相对应的模型类）和DB::table来操作数据库。使用原生查询时不太一样，laravel使用Db::操作(‘原生sql’)，TP使用Db::query(‘原生sql’)。 Laravel升级十分简易，而TP大版本的升级要重构代码。 条件判断语句书写方式的差异： laravel框架里 if else判断语句和foreach语句 书写时必须以@if开头 以@endif结尾,如果没有则报语法错误,@foreach @endforeach同理；而TP框架则和PHP语法规则使用方式一致直接ifesle语句判断和foreach循环遍历。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx和php-fpm结合]]></title>
    <url>%2F2019%2F08%2F08%2Fnginx-and-php-fpm%2F</url>
    <content type="text"><![CDATA[Nginx不只有处理http请求的功能，还能做反向代理。 Nginx通过反向代理功能将动态请求转向后端Php-fpm。 在 Linux 上，nginx 与 php-fpm 的通信有 tcp socket 和 unix socket 两种方式。 tcp socket 的优点是可以跨服务器，当 nginx 和 php-fpm 不在同一台机器上时，只能使用这种方式。 Unix socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信，这种方式需要在 nginx配置文件中填写 php-fpm 的 socket 文件位置。 两种方式的数据传输过程如下图所示： 二者的不同： 由于 Unix socket 不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。所以其效率比 tcp socket 的方式要高，可减少不必要的 tcp 开销。不过，unix socket 高并发时不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。而 tcp 这样的面向连接的协议，可以更好的保证通信的正确性和完整性。 下面我们来配置一个全新的Nginx+Php-fpm 配置nginx.conf文件进入nginx目录下，编辑nginx.conf文件。如图，在nginx.conf最后一行，添加include文件 添加对应的server进入上面的include的路径，添加一个serverunix socket 方式 修改fastcgi_pass如下fastcgi_pass unix:/usr/run/php-fpm.sock 下面我们解释下配置项的含义 123456789101112131415161718server &#123; listen 80; #监听80端口，接收http请求 server_name www.example.com; #就是网站地址 root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径 #路由到网站根目录www.example.com时候的处理 location / &#123; index index.php; #跳转到www.example.com/index.php autoindex on; &#125; #当请求网站下php文件的时候，反向代理到php-fpm location ~ \.php$ &#123; include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块 fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口 # fasrcgi_pass /usr/run/php-fpm.sock #unix socket 连接方式 &#125;&#125; 下面我们启用php的php-fpm来处理这个请求打开php-fpm.conf文件，我们看到如下配置：unix socket 方式 修改php-fpm.conf如下listen = /usr/run/php-fpm.sock 即：php-fpm模块监听127.0.0.1:9000端口 或者 php-fpm.sock文件，等待请求到来去处理。 注意：在使用 unix socket 方式连接时，由于 socket 文件本质上是一个文件，存在权限控制的问题，所以需要注意 nginx 进程的权限与 php-fpm 的权限问题，不然会提示无权限访问。（在各自的配置文件里设置用户）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac + Hexo + GitHub + Next 搭建博客]]></title>
    <url>%2F2019%2F07%2F09%2Fmac-hexo%2F</url>
    <content type="text"><![CDATA[1. 安装node.js 和 gitmac上使用brew安装node 和 git测试安装是否成功： 12345node -vnpm -v # 同时可以配置下npm镜像：npm config set registry https://registry.npm.taobao.org# 配置后可通过下面方式来验证是否成功 npm config get registry 或 npm info expressgit --versoin 2. 安装Hexo安装时注意权限问题，加上sudo，其中-g表示全局安装 1sudo npm install -g hexo-cli npm全局安装的包的存储路径是/usr/local/lib/node_modules/ 3. 博客初始化创建博客的文件夹，并进入 12sudo mkdir blogcd blog 初始化博客 1sudo hexo init 安装依赖 12## 安装时 node-pre-gyp 报错，执行如下命令可以解决sudo npm install --unsafe-perm 执行下述命令生成本地网页文件并开启服务器，然后通过http://localhost:4000查看本地博客 12sudo hexo gsudo hexo s 或者 sudo hexo s -p 4000 4. 上传github在github中新建仓库，名称必须为 user.github.io，如：Liwen-Git.github.io 配置hexo的_config.yml文件 12cd blogsudo vim _config.yml 在文档的最后部分，将deploy配置如下 1234deploy: type: git repository: https://github.com/Liwen-Git/Liwen-Git.github.io.git branch: master 注意type、repository、branch后均有空格。通过如下命令在blog下生成静态文件并上传到服务器 1234sudo hexo g# 出错执行 sudo npm install hexo --savesudo hexo d# 出错执行 sudo npm install hexo-deployer-git --save 执行hexo d 时会提示输入GitHub账号用户名和密码，执行成功之后通过 https://liwen-git.github.io/ 访问博客 5. 更换Next主题推荐使用hexo-theme-next主题在blog目录下执行： 1sudo git clone https://github.com/theme-next/hexo-theme-next.git themes/next 修改blog目录下_config.yml里的theme名称为：next其他的，如title: 李子园、language: zh-CN、都可以自己配置 执行如下命令（每次部署文章的步骤） 12sudo hexo g //生成缓存和静态文件sudo hexo d //重新部署到服务器 当本地博客部署到服务器后，网页端无变化时可以采用下述命令 1sudo hexo clean //清楚缓存文件(db.json)和已生成的静态文件(public) 6. 配置next主题修改next主题的配置文件_config.yml主题为：Gemini（打开注释） 修改next主题配置文件，在menu处，打开tags和categories的注释 创建tag页面1sudo hexo new page &quot;tags&quot; 然后再blog/sources中会多了一个tags文件夹，修改其中的index.md文件，type修改为tags 12345---title: tagsdate: 2019-07-08 23:15:25type: &quot;tags&quot;--- 创建categories页面1sudo hexo new page &quot;categories&quot; 然后再blog/sources中会多了一个categories文件夹，修改其中的index.md文件，type修改为categories 12345---title: categoriesdate: 2019-07-08 23:15:25type: &quot;categories&quot;--- 7. 安装搜索功能 Local Search在next的_config.yml文件中修改Local Search的enable: true在根目录下执行以下命令： 12sudo npm install hexo-generator-search --savesudo npm install hexo-generator-searchdb --save 在根目录的_config.yml文件中添加 12345search: path: search.xml field: post format: html limit: 10000 8. 新建文章命令： 1sudo hexo new post 文件名可以不是文章名 给文章添加属性 12345678910---title: Mac + Hexo + GitHub + Next 搭建博客date: 2019-07-08 12:12:57categories: - mactags:- hexo- next- 表单验证--- 站点首页不显示文章全文，文章摘要设置这里我们可以通过在文章使用&lt;!-- more --&gt;标志来精确控制文章的摘要预览]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F07%2F08%2Fphp-design-patterns%2F</url>
    <content type="text"><![CDATA[策略模式策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。 策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。 策略模式的三个角色： 抽象策略角色 具体策略角色 环境角色（对抽象策略角色的引用） 实现步骤： 定义抽象角色类（定义好各个实现的共同抽象方法） 定义具体策略类（具体实现父类的共同方法） 定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法） 就在编程领域外，有许多例子是关于策略模式的。例如： 如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。 策略模式的代码实例： 1234567891011121314151617181920212223242526&lt;?php // 抽象策略类 abstract class baseAgent &#123; abstract function PrintPage(); &#125; // 用于客户端是IE时调用的类（环境角色） class ieAgent extends baseAgent &#123; function PrintPage() &#123; return &apos;IE&apos;; &#125; &#125; // 用于客户端不是IE时调用的类（环境角色） class otherAgent extends baseAgent &#123; function PrintPage() &#123; return &apos;not IE&apos;; &#125; &#125; // 具体策略角色 class Browser &#123; public function call($object) &#123; return $object-&gt;PrintPage(); &#125; &#125; $bro = new Browser(); echo $bro-&gt;call(new ieAgent()); 工厂模式工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。 使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php // 简单工厂模式（静态工厂方法模式） // Interface people 人类 interface people &#123; public function say(); &#125; // Class man 继承people的男人类 class man implements people &#123; // 具体实现people的say方法 public function say() &#123; echo &apos;我是男人&lt;br&gt;&apos;; &#125; &#125; // Class women 继承people的女人类 class women implements people &#123; // 具体实现people的say方法 public function say() &#123; echo &apos;我是女人&lt;br&gt;&apos;; &#125; &#125; // Class SimpleFactory 工厂类 class SimpleFactory &#123; // 简单工厂里的静态方法-用于创建男人对象 static function createMan() &#123; return new man(); &#125; // 简单工厂里的静态方法-用于创建女人对象 static function createWomen() &#123; return new women(); &#125; &#125; // 具体调用 $man = SimpleFactoty::createMan(); $man-&gt;say(); $woman = SimpleFactoty::createWomen(); $woman-&gt;say(); 单例模式单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。 单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。 单例模式有以下3个特点： 只能有一个实例 必须自行创建这个实例 必须给其他对象提供这一实例 那么为什么要使用PHP单例模式？ PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。 12345678910111213141516171819202122232425class Single &#123; private $name;//声明一个私有的实例变量 private function __construct()&#123; //声明私有构造方法为了防止外部代码使用new来创建对象。 &#125; static public $instance;//声明一个静态变量（保存在类中唯一的一个实例） static public function getinstance()&#123; //声明一个getinstance()静态方法，用于检测是否有实例对象 if(!self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; public function setname($n)&#123; $this-&gt;name = $n; &#125; public function getname()&#123; return $this-&gt;name; &#125;&#125;$oa = Single::getinstance();$ob = Single::getinstance();$oa-&gt;setname(&apos;hello world&apos;);$ob-&gt;setname(&apos;good morning&apos;);echo $oa-&gt;getname();//good morningecho $ob-&gt;getname();//good morning 注册模式注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。 1234567891011121314&lt;?phpclass Register &#123; protected static $objects; //将对象注册到全局的树上 function set($alias, $object) &#123; self::$objects[$alias]=$object;//将对象放到树上 &#125; static function get($name) &#123; return self::$objects[$name];//获取某个注册到树上的对象 &#125; function _unset($alias) &#123; unset(self::$objects[$alias]);//移除某个注册到树上的对象 &#125;&#125; 适配器模式将各种截然不同的函数接口封装成统一的API。 PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。 12345678接口 IDatabase&lt;?php namespace IMooc; interface IDatabase &#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close(); &#125; 12345678910111213141516171819MySQL&lt;?php namespace IMooc\Database; use IMooc\IDatabase; class MySql implements IDatabase &#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysql_connect($host, $user, $passwd); mysql_select_db($dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; $res = mysql_query($sql, $this-&gt;conn); return $res; &#125; function close() &#123; mysql_close($this-&gt;conn); &#125; &#125; 1234567891011121314151617MySQLi&lt;?php namespace IMooc\Database; use IMooc\IDatabase; class MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname)&#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql)&#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close()&#123; mysqli_close($this-&gt;conn); &#125; &#125; 观察者模式 观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。 场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 观察者模式实现了低耦合，非侵入式的通知与更新机制。 定义一个事件触发抽象类： 12345678910111213EventGenerator.php&lt;?php abstract class EventGenerator&#123; private $observers = array(); function addObserver(Observer $observer)&#123; $this-&gt;observers[]=$observer; &#125; function notify()&#123; foreach ($this-&gt;observers as $observer)&#123; $observer-&gt;update(); &#125; &#125; &#125; 定义一个观察者接口 123456Observer.php&lt;?php //一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件 interface Observer &#123; function update(); // 这里就是在事件发生后要执行的逻辑 &#125; 实现 1234567891011121314151617181920212223class Event extends EventGenerator&#123; function triger()&#123; echo &quot;Event&lt;br&gt;&quot;; &#125;&#125;class Observer1 implements Observer&#123; function update()&#123; echo &quot;逻辑1 &lt;br/&gt;&quot;; &#125;&#125;class Observer2 implements Observer&#123; function update()&#123; echo &quot;逻辑2 &lt;br/&gt;&quot;; &#125;&#125;$event = new Event();$event-&gt;addObserver(new Observer1());$event-&gt;addObserver(new Observer2());$event-&gt;triger();$event-&gt;notify();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt格式 “占位符”]]></title>
    <url>%2F2019%2F07%2F08%2Fgo-fmt%2F</url>
    <content type="text"><![CDATA[golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。 123456# 定义示例类型和变量type Human struct &#123; Name string&#125;var people = Human&#123;Name: &quot;zhangsan&quot;&#125; 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式 Printf(“%v”, people) {zhangsan} %+v 打印结构体时，会添加字段名 Printf(“%+v”, people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(“#v”, people) main.Human{Name:”zhangsan”} %T 相应值的类型的Go语法表示 Printf(“%T”, people) main.Human %% 字面上的百分号，并非值的占位符 Printf(“%%”) % 布尔占位符 占位符 说明 举例 输出 %t true 或 false Printf(“%t”, true) true 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(“%b”, 5) 101 %c 相应Unicode码点所表示的字符 Printf(“%c”, 0x4E2D) 中 %d 十进制表示 Printf(“%d”, 0x12) 18 %o 八进制表示 Printf(“%d”, 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(“%q”, 0x4E2D) ‘中’ %x 十六进制表示，字母形式为小写 a-f Printf(“%x”, 13) d %X 十六进制表示，字母形式为大写 A-F Printf(“%x”, 13) D %U Unicode格式：U+1234，等同于 “U+%04X” Printf(“%U”, 0x4E2D) U+4E2D 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %e 科学计数法，例如 -1234.456e+78 Printf(“%e”, 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(“%e”, 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(“%f”, 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%g”, 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%G”, 10.20+2i) (10.2+2i) 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(“%s”, []byte(“Go语言”)) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(“%q”, “Go语言”) “Go语言” %x 十六进制，小写字母，每字节两个字符 Printf(“%x”, “golang”) 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(“%X”, “golang”) 676F6C616E67 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(“%p”, &amp;people) 0x4f57f0]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>占位符</tag>
      </tags>
  </entry>
</search>
